"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[4024],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3263:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={slug:"kuzu-0.0.4-release",authors:["team"],tags:["release"]},l="K\xf9zu 0.0.4 Release",o={permalink:"/docusaurus/blog/kuzu-0.0.4-release",source:"@site/blog/2023-06-05-kuzu-v-0.0.4.md",title:"K\xf9zu 0.0.4 Release",description:"We are very happy to release K\xf9zu 0.0.4 today! This release comes with the following new main features and improvements:",date:"2023-06-05T00:00:00.000Z",formattedDate:"June 5, 2023",tags:[{label:"release",permalink:"/docusaurus/blog/tags/release"}],readingTime:7.01,hasTruncateMarker:!0,authors:[{name:"K\xf9zu Team",url:"https://github.com/kuzudb/",key:"team"}],frontMatter:{slug:"kuzu-0.0.4-release",authors:["team"],tags:["release"]},prevItem:{title:"K\xf9zu 0.0.5 Release",permalink:"/docusaurus/blog/kuzu-0.0.5-release"},nextItem:{title:"Scaling Pytorch Geometric GNNs With K\xf9zu",permalink:"/docusaurus/blog/kuzu-pyg-remote-backend"}},s={authorsImageUrls:[void 0]},p=[{value:"Data Ingestion Improvements",id:"data-ingestion-improvements",level:2},{value:"New Cypher Features",id:"new-cypher-features",level:2},{value:"Undirected Relationships in Queries",id:"undirected-relationships-in-queries",level:3},{value:"Recursive Queries: Shortest Path Queries and Improved Variable-length Queries",id:"recursive-queries-shortest-path-queries-and-improved-variable-length-queries",level:3},{value:"New Data Types",id:"new-data-types",level:2},{value:"<code>SERIAL</code>",id:"serial",level:3},{value:"<code>STRUCT</code>",id:"struct",level:3},{value:"Client APIs",id:"client-apis",level:2},{value:"Windows compatibility",id:"windows-compatibility",level:3},{value:"C",id:"c",level:3},{value:"Node.js",id:"nodejs",level:3}],u={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"We are very happy to release K\xf9zu 0.0.4 today! This release comes with the following new main features and improvements: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#data-ingestion-improvements"},"Data Ingestion Improvements")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#new-cypher-features"},"New Cypher Features"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#undirected-relationships-in-queries"},"Undirected Relationships in Queries")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#recursive-queries-shortest-path-queries-and-improved-variable-length-queries"},"Recursive Queries: Shortest Path Queries and Improved Variable-length Queries")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#new-data-types"},"New Data Types"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#serial"},(0,r.kt)("inlineCode",{parentName:"a"},"SERIAL"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#struct"},(0,r.kt)("inlineCode",{parentName:"a"},"STRUCT"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#client-apis"},"Client APIs"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#windows-compatibility"},"Windows compatibility")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#c"},"C")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docusaurus/blog/kuzu-0.0.4-release#nodejs"},"Node.js"))))),(0,r.kt)("h2",{id:"data-ingestion-improvements"},"Data Ingestion Improvements"),(0,r.kt)("p",null,"We continue to improve our data ingestion in this release.\nWe still rely on Apache Arrow to parse parquet and csv files.\nSeveral bottlenecks in our earlier implementation are identified and optimized now, including copying from arrow arrays and construction of hash indexes.\nWe now also store null bits separately, which simplifies our loading logic and makes it faster."),(0,r.kt)("p",null,"Here are some benchmark numbers for loading two node and two rel tables that only contain primitive types or strings from the LDBC benchmark:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CPU: MAC M1 MAX"),(0,r.kt)("li",{parentName:"ul"},"Disk: 2TB SSD"),(0,r.kt)("li",{parentName:"ul"},"System Memory: 32GB"),(0,r.kt)("li",{parentName:"ul"},"Dataset: LDBC-100"),(0,r.kt)("li",{parentName:"ul"},"Number of thread: 10")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Files"),(0,r.kt)("th",{parentName:"tr",align:null},"# lines"),(0,r.kt)("th",{parentName:"tr",align:null},"file size"),(0,r.kt)("th",{parentName:"tr",align:null},"v0.0.3"),(0,r.kt)("th",{parentName:"tr",align:null},"v0.0.4"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"comment.csv"),(0,r.kt)("td",{parentName:"tr",align:null},"220M"),(0,r.kt)("td",{parentName:"tr",align:null},"22.49 GB"),(0,r.kt)("td",{parentName:"tr",align:null},"890s"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"108s (8.2x)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"post.csv"),(0,r.kt)("td",{parentName:"tr",align:null},"58M"),(0,r.kt)("td",{parentName:"tr",align:null},"7.68 GB"),(0,r.kt)("td",{parentName:"tr",align:null},"304s"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"32s (9.5x)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"likesComment.csv"),(0,r.kt)("td",{parentName:"tr",align:null},"242M"),(0,r.kt)("td",{parentName:"tr",align:null},"13 GB"),(0,r.kt)("td",{parentName:"tr",align:null},"772s"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"142s (5.4x)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"knows.csv"),(0,r.kt)("td",{parentName:"tr",align:null},"20M"),(0,r.kt)("td",{parentName:"tr",align:null},"1.1 GB"),(0,r.kt)("td",{parentName:"tr",align:null},"80s"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"21s (3.8x)"))))),(0,r.kt)("p",null,"Besides performance improvement, we now also allow interrupting ",(0,r.kt)("inlineCode",{parentName:"p"},"COPY")," statements in the shell.\nYou can interrupt long running ",(0,r.kt)("inlineCode",{parentName:"p"},"COPY")," statements without crashing the shell."),(0,r.kt)("p",null,"We will continue to improve our data ingestion to make it more efficient and robust as we're moving to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/kuzu/issues/1474"},"new storage design")," in the coming releases. Please stay tuned!"),(0,r.kt)("h2",{id:"new-cypher-features"},"New Cypher Features"),(0,r.kt)("h3",{id:"undirected-relationships-in-queries"},"Undirected Relationships in Queries"),(0,r.kt)("p",null,"K\xf9zu now supports undirected relationships in Cypher queries. An undirected relationship is the union of both in-coming and out-going relationships. This feature is mostly useful in the following two cases. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Case 1: Relationship is undirected by nature"),"\nRelationships between nodes in K\xf9zu are currently directed (though we are internally debating to add a native undirected relationship type). A relationship file must contain ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TO")," columns each of which refers to a primary key column of a node table. However, sometimes the nature of the relationships are undirected, e.g., an ",(0,r.kt)("inlineCode",{parentName:"p"},"isFriendOf")," relationships in a social network. "),(0,r.kt)("p",null,"Currently, you have two options: (1) you can either store each friendship twice, e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice isFriendOf Bob")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob isFriendOf Alice"),". This is a bad choice because internally K\xf9zu will index each edge twice (in the forward and backward) edges, so this one fact ends up getting stored 4 times. Or (2) you can store it once, say ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice isFriendOf Bob"),". "),(0,r.kt)("p",null,"The advantage of option (1) was that in K\xf9zu v 0.0.3, if you want to find all friends of ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice"),", you could simply ask this query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:Person)-[:isFriendOf]->(b:Person)\nWHERE a.name = 'Alice' RETURN b;\n")),(0,r.kt)("p",null,"Instead, if you chose option (2), you would have to ask two queries, one to ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:Person)-[:isFriendOf]->(b:Person)")," and the other to ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:Person)<-[:isFriendOf]-(b:Person)"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"UNION")," them, which gets messy if you want to do more with those neighbors (e.g., find their neighbors etc.). "),(0,r.kt)("p",null,"With undirected edge support, you can now choose option (2) and find ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice"),"'s friends with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:Person)-[:isFriendOf]-(b:Person)\nWHERE a.name = 'Alice'\nRETURN b;\n")),(0,r.kt)("p",null,"So if you do not specify a direction in your relationships, K\xf9zu will automatically query both the forward and backward relationships for you."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note from K\xf9zu developers: As noted above, we are debating a native undirected relationship type. That seems to solve the problem of, in which fake direction should an undirected relationship be saved at? Should be a ",(0,r.kt)("inlineCode",{parentName:"em"},"Alice-[isFriendOf]->Bob")," or vice versa. Happy to hear your thoughts on this.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Case 2: Relationship direction is not of interest"),"\nAlthough relationship is stored in a directed way, its direction may not be of interest in the query. The following query tries to find all comments that have interacted with comment ",(0,r.kt)("inlineCode",{parentName:"p"},"K\xf9zu"),". These comments could be either replying to or replied by ",(0,r.kt)("inlineCode",{parentName:"p"},"K\xf9zu"),". The query can be asked naturally in an undirected way."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (c:Comment)-[:replyOf]-(other:Comment)\nWHERE c.author = 'K\xf9zu'\nRETURN other;\n")),(0,r.kt)("h3",{id:"recursive-queries-shortest-path-queries-and-improved-variable-length-queries"},"Recursive Queries: Shortest Path Queries and Improved Variable-length Queries"),(0,r.kt)("p",null,"This release brings in the beginnings of a series of major improvements we will do to recursive joins.\nThe two major changes in this release are: "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multilabeled and undirected Variable-length Join Queries"),"\nPrior to this release we supported variable-length join queries only in the restricted case when the variable-length relationship could have a single relationship label and was directed. For example you could write this query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:Person)-[:knows*1..2]->(b:Person)\nWHERE a.name = 'Alice' \nRETURN b\n")),(0,r.kt)("p",null,"But you couldn't ask for arbitrary labeled variable-length relationships between Persons ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," (though you\ncould write the non-recursive version of that query: ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:Person)-[:knows]->(b:Person) ..."),".\nSimilarly we did not support undirected version of the query: ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:Person)-[:knows*1..2]-(b:Person)"),".\nK\xf9zu now supports multi-label as well as undirected variable-length relationships.\nFor example, the following query finds all nodes that are reachable within 1 to 3 hops from ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice"),", irrespective\nof the labels on the connections or destination ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," nodes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:Person)-[e:*1..3]-(b)\nWHERE a.name = 'Alice'\nRETURN b;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Shortest path")),(0,r.kt)("p",null,"Finally, we got to implementing an initial version of shortest path queries. You can find (one of the) shortest paths between nodes by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"SHORTEST")," keyword to a varible-length relationship. The following query asks for a shortest path between ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice")," and all active users that ",(0,r.kt)("inlineCode",{parentName:"p"},"Alice")," follows within 10 hops and return these users, and the length of the shortest path."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[p:Follows* SHORTEST 1..10]->(b:User)\nWHERE a.name = 'Alice' AND b.state = 'Active'\nRETURN b, p, length(p)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," in the query binds to the sequences of relationship, node, relationship, node, etc. Currently we only return the internal IDs of the relationships and nodes (soon, we will return all their properties)."),(0,r.kt)("h2",{id:"new-data-types"},"New Data Types"),(0,r.kt)("h3",{id:"serial"},(0,r.kt)("inlineCode",{parentName:"h3"},"SERIAL")),(0,r.kt)("p",null,"This release introduces ",(0,r.kt)("inlineCode",{parentName:"p"},"SERIAL")," data type. Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"AUTO_INCREMENT")," supported by many other databases, ",(0,r.kt)("inlineCode",{parentName:"p"},"SERIAL")," is mainly used to create\nan incremental sequence of unique identifier column which can serve as a primary key column."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"person.csv")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Alice\nBob\nCarol\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE NODE TABLE Person(ID SERIAL, name STRING, PRIMARY KEY(ID));\nCOPY Person FROM `person.csv`;\nMATCH (a:Person) RETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-------------------------------------------\n| a                                       |\n-------------------------------------------\n| (label:Person, 3:0, {ID:0, name:Alice}) |\n-------------------------------------------\n| (label:Person, 3:1, {ID:1, name:Bob})   |\n-------------------------------------------\n| (label:Person, 3:2, {ID:2, name:Carol}) |\n-------------------------------------------\n")),(0,r.kt)("p",null,"When the primary key of your node tables are already consecutive integers starting from 0, you should omit the primary key column in the input file and make primary key a SERIAL type. This will improve loading time significantly. Similarly, queries that need to scan primary key will also get faster. That's because internally we will not store a HashIndex or primary key column so any scan over primary key will not trigger a disk I/O."),(0,r.kt)("h3",{id:"struct"},(0,r.kt)("inlineCode",{parentName:"h3"},"STRUCT")),(0,r.kt)("p",null,"K\xf9zu now supports ",(0,r.kt)("inlineCode",{parentName:"p"},"STRUCT")," data type similar to ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/rowtypes.html"},"composite type")," in Postgres. Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"WITH {name:'University of Waterloo', province:'ON'} AS institution\nRETURN institution.name AS name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------------\n| name                   |\n--------------------------\n| University of Waterloo |\n--------------------------\n")),(0,r.kt)("p",null,"We support storing structs as node properties for now. For example you can create: ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE NODE TABLE Foo(name STRING, exStruct STRUCT(x INT16, y STRUCT(z INT64, w STRING)), PRIMARY KEY (name))"),". We will support storing structs on relationships soon. As shown in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE NODE")," example above, you can store arbitrarily\nnested structs, e.g., structs that contain structs as a field, on nodes. One missing feature we have for now is storing and processing a ",(0,r.kt)("inlineCode",{parentName:"p"},"LIST<STRUCT>")," composite type. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": Updating ",(0,r.kt)("inlineCode",{parentName:"p"},"STRUCT")," column with update statement is not supported in this release but will come soon."),(0,r.kt)("h2",{id:"client-apis"},"Client APIs"),(0,r.kt)("h3",{id:"windows-compatibility"},"Windows compatibility"),(0,r.kt)("p",null,"Developers can now build K\xf9zu from scratch on Windows platform! Together with this release we also provide pre-built libraries and python wheels on Windows."),(0,r.kt)("h3",{id:"c"},"C"),(0,r.kt)("p",null,"We provide official C language binding in this release. Developers can now embed K\xf9zu with native C interfaces."),(0,r.kt)("h3",{id:"nodejs"},"Node.js"),(0,r.kt)("p",null,"We provide official Node.js language binding. With Node.js API, developer can leverage K\xf9zu analytical capability in their Node.js projects. We will\nsoon follow this blog post with one (or a few) blog posts on developing some applications with Node.js."))}m.isMDXComponent=!0}}]);