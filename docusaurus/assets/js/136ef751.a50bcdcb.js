"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[8705],{3905:(e,n,a)=>{a.d(n,{Zo:()=>h,kt:()=>c});var t=a(7294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},h=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),u=p(a),m=r,c=u["".concat(s,".").concat(m)]||u[m]||d[m]||l;return a?t.createElement(c,i(i({ref:n},h),{},{components:a})):t.createElement(c,i({ref:n},h))}));function c(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7543:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var t=a(7462),r=(a(7294),a(3905));a(5973);const l={title:"Match",sidebar_position:1,description:'MATCH is the clause where you define a graph pattern", i.e., a join of node or relationship records, to find in the database.'},i="MATCH",o={unversionedId:"cypher/query-clauses/match",id:"cypher/query-clauses/match",title:"Match",description:'MATCH is the clause where you define a graph pattern", i.e., a join of node or relationship records, to find in the database.',source:"@site/docs/cypher/query-clauses/match.md",sourceDirName:"cypher/query-clauses",slug:"/cypher/query-clauses/match",permalink:"/docusaurus/cypher/query-clauses/match",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Match",sidebar_position:1,description:'MATCH is the clause where you define a graph pattern", i.e., a join of node or relationship records, to find in the database.'},sidebar:"docSidebar",previous:{title:"Example database",permalink:"/docusaurus/cypher/query-clauses/example-database"},next:{title:"Optional Match",permalink:"/docusaurus/cypher/query-clauses/optional-match"}},s={},p=[{value:"Notes:",id:"notes",level:4},{value:"Match Nodes",id:"match-nodes",level:2},{value:"Match Nodes With a Single Label",id:"match-nodes-with-a-single-label",level:3},{value:"Match Nodes With Multiple Labels",id:"match-nodes-with-multiple-labels",level:3},{value:"Match Nodes With Any Label",id:"match-nodes-with-any-label",level:3},{value:"Match Relationships",id:"match-relationships",level:2},{value:"Match Directed Relationships With a Label",id:"match-directed-relationships-with-a-label",level:3},{value:"Match Relationships With Multi Labels",id:"match-relationships-with-multi-labels",level:3},{value:"Match Relationships With Any Label",id:"match-relationships-with-any-label",level:3},{value:"Match Undirected Relationships",id:"match-undirected-relationships",level:3},{value:"Omit Binding Variables to Nodes or Relationships",id:"omit-binding-variables-to-nodes-or-relationships",level:3},{value:"Match Multiple Patterns",id:"match-multiple-patterns",level:3},{value:"Equality Predicates on Node/Rel Properties",id:"equality-predicates-on-noderel-properties",level:3},{value:"Match Variable Length Relationships",id:"match-variable-length-relationships",level:2},{value:"Returning Variable Length Relationships",id:"returning-variable-length-relationships",level:3},{value:"Filter Variable Length Relationships",id:"filter-variable-length-relationships",level:3},{value:"Projecting Properties of Intermediate Nodes and Relationships in Variable Length Relationships",id:"projecting-properties-of-intermediate-nodes-and-relationships-in-variable-length-relationships",level:3},{value:"Single Shortest Path",id:"single-shortest-path",level:3},{value:"All Shortest Path",id:"all-shortest-path",level:3},{value:"Named Path",id:"named-path",level:2},{value:"Extracting Nodes, Rels From a Path",id:"extracting-nodes-rels-from-a-path",level:3}],h={toc:p},u="wrapper";function d(e){let{components:n,...a}=e;return(0,r.kt)(u,(0,t.Z)({},h,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"match"},"MATCH"),(0,r.kt)("p",null,'MATCH is the clause where you define a "graph pattern", i.e., a join of node or relationship records,\nto find in the database.',(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". There are several different ways to match patterns and we go through them\nbelow. MATCH is often accompanied by ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/query-clauses/where"},"WHERE")," (equivalent to SQL's WHERE clause) to define more predicates on the patterns that are matched."),(0,r.kt)("h4",{id:"notes"},"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Similar to other high-level database query languages, nodes and relationships in the patterns\nare bound to variables, which can be referenced in other clauses (e.g., WHERE or RETURN) of the query.\nopenCypher allows you to omit these variables, if you do not need to reference them."),(0,r.kt)("li",{parentName:"ul"},"Node/Rel table names in K\xf9zu are case sensitive. So you need to specify the labels of nodes/rels\nusing the same letter cases you used in your node/rel table schema definitions. ")),(0,r.kt)("p",null,"We will use the example database for demonstration, whose schema and data import commands are given ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/query-clauses/example-database"},"here"),"."),(0,r.kt)("h2",{id:"match-nodes"},"Match Nodes"),(0,r.kt)("h3",{id:"match-nodes-with-a-single-label"},"Match Nodes With a Single Label"),(0,r.kt)("p",null,'The query below matches variable "a" to nodes with label User and returns "a", which\nis a shortcut in openCypher to return all properties of the node together with label and internal ID that variable "a" matches.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)\nRETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------\n| a                                                |\n----------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30}    |\n----------------------------------------------------\n| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40} |\n----------------------------------------------------\n| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50}   |\n----------------------------------------------------\n| {_ID: 0:3, _LABEL: User, name: Noura, age: 25}   |\n----------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=xjiF39SzeCb7"},"Colab"),"."),(0,r.kt)("h3",{id:"match-nodes-with-multiple-labels"},"Match Nodes With Multiple Labels"),(0,r.kt)("p",null,'The query below matches variable "a" to nodes with label User or label City. "Return a" will return all properties of the node together with label and internal ID. Properties not exist in a label will be returned as NULL value (e.g. "population" not exists in "User"). Properties exists in multiple labels are expected to have the same data type (e.g. "name" has STRING data type in "User" and "City" ).'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User:City)\nRETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------\n| a                                                             |\n-----------------------------------------------------------------\n| {_ID: 1:0, _LABEL: City, name: Waterloo, population: 150000}  |\n-----------------------------------------------------------------\n| {_ID: 1:1, _LABEL: City, name: Kitchener, population: 200000} |\n-----------------------------------------------------------------\n| {_ID: 1:2, _LABEL: City, name: Guelph, population: 75000}     |\n-----------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30, }               |\n-----------------------------------------------------------------\n| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40, }            |\n-----------------------------------------------------------------\n| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50, }              |\n-----------------------------------------------------------------\n| {_ID: 0:3, _LABEL: User, name: Noura, age: 25, }              |\n-----------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=3yO3HHwNeBy3"},"Colab"),"."),(0,r.kt)("h3",{id:"match-nodes-with-any-label"},"Match Nodes With Any Label"),(0,r.kt)("p",null,'Below query matches variable "a" to nodes with any label. In example database, it is equivalent to ',(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:User:City) RETURN a;"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a)\nRETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------\n| a                                                             |\n-----------------------------------------------------------------\n| {_ID: 1:0, _LABEL: City, name: Waterloo, population: 150000}  |\n-----------------------------------------------------------------\n| {_ID: 1:1, _LABEL: City, name: Kitchener, population: 200000} |\n-----------------------------------------------------------------\n| {_ID: 1:2, _LABEL: City, name: Guelph, population: 75000}     |\n-----------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30, }               |\n-----------------------------------------------------------------\n| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40, }            |\n-----------------------------------------------------------------\n| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50, }              |\n-----------------------------------------------------------------\n| {_ID: 0:3, _LABEL: User, name: Noura, age: 25, }              |\n-----------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=4NBsUUP_evvh"},"Colab"),"."),(0,r.kt)("h2",{id:"match-relationships"},"Match Relationships"),(0,r.kt)("h3",{id:"match-directed-relationships-with-a-label"},"Match Directed Relationships With a Label"),(0,r.kt)("p",null,"Similar to binding variables to node records, you can bind variables to relationship records and return them. You can specify the direction of relationship by ",(0,r.kt)("inlineCode",{parentName:"p"},"<-")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"->"),'. The following query finds all "a" Users that follow a "b" User through an outgoing relationship from "a", and returns name of "a", relationship "e", and name of "b", where "e" will match the relationship from "a" to "b".'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows]->(b:User)\nRETURN a.name, e, b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------------------\n| a.name  | e                                                     | b.name  |\n-----------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) | Karissa |\n-----------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) | Zhang   |\n-----------------------------------------------------------------------------\n| Karissa | (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) | Zhang   |\n-----------------------------------------------------------------------------\n| Zhang   | (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) | Noura   |\n-----------------------------------------------------------------------------\n")),(0,r.kt)("p",null,'The following query matches all the relationships through an incoming relationship from "a" (so "a" and "b" are swapped in output):'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)<-[e:Follows]-(b:User)\nRETURN a.name, e, b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------------------\n| a.name  | e                                                     | b.name  |\n-----------------------------------------------------------------------------\n| Karissa | (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) | Adam    |\n-----------------------------------------------------------------------------\n| Zhang   | (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) | Adam    |\n-----------------------------------------------------------------------------\n| Zhang   | (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) | Karissa |\n-----------------------------------------------------------------------------\n| Noura   | (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) | Zhang   |\n-----------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=Djpu4aDafG5U"},"Colab"),"."),(0,r.kt)("h3",{id:"match-relationships-with-multi-labels"},"Match Relationships With Multi Labels"),(0,r.kt)("p",null,'Similar to matching nodes with multiple labels, you can bind variables to relationships with multiple labels. Below query finds all "a" User that Follows "b" User or LivesIn "b" City.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows|:LivesIn]->(b:User:City)\nRETURN a.name, e, b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-------------------------------------------------------------------------------\n| a.name  | e                                                     | b.name    |\n-------------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) | Karissa   |\n-------------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) | Zhang     |\n-------------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: LivesIn, _ID: 3:0, }->(1:0)            | Waterloo  |\n-------------------------------------------------------------------------------\n| Karissa | (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) | Zhang     |\n-------------------------------------------------------------------------------\n| Karissa | (0:1)-{_LABEL: LivesIn, _ID: 3:1, }->(1:0)            | Waterloo  |\n-------------------------------------------------------------------------------\n| Zhang   | (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) | Noura     |\n-------------------------------------------------------------------------------\n| Zhang   | (0:2)-{_LABEL: LivesIn, _ID: 3:2, }->(1:1)            | Kitchener |\n-------------------------------------------------------------------------------\n| Noura   | (0:3)-{_LABEL: LivesIn, _ID: 3:3, }->(1:2)            | Guelph    |\n-------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=ylYHrLeQfLao"},"Colab"),"."),(0,r.kt)("h3",{id:"match-relationships-with-any-label"},"Match Relationships With Any Label"),(0,r.kt)("p",null,"Similar to matching nodes with any label, you can bind variables to relationships with any label by not specifying a label. Below query finds all relationships in the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH ()-[e]->()\nRETURN e;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"---------------------------------------------------------\n| e                                                     |\n---------------------------------------------------------\n| (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) |\n---------------------------------------------------------\n| (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) |\n---------------------------------------------------------\n| (0:0)-{_LABEL: LivesIn, _ID: 3:0, }->(1:0)            |\n---------------------------------------------------------\n| (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) |\n---------------------------------------------------------\n| (0:1)-{_LABEL: LivesIn, _ID: 3:1, }->(1:0)            |\n---------------------------------------------------------\n| (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) |\n---------------------------------------------------------\n| (0:2)-{_LABEL: LivesIn, _ID: 3:2, }->(1:1)            |\n---------------------------------------------------------\n| (0:3)-{_LABEL: LivesIn, _ID: 3:3, }->(1:2)            |\n---------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=lEZAboFLfLku"},"Colab"),"."),(0,r.kt)("h3",{id:"match-undirected-relationships"},"Match Undirected Relationships"),(0,r.kt)("p",null,"Users can match a relationship in both directions by not specifiying a relationship direction (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"-"),'). The following query finds all "b" users who either follows or being followed by "Karissa". '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows]-(b:User) Where a.name = 'Karissa' RETURN b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------\n| b.name |\n----------\n| Adam   |\n----------\n| Zhang  |\n----------\n")),(0,r.kt)("h3",{id:"omit-binding-variables-to-nodes-or-relationships"},"Omit Binding Variables to Nodes or Relationships"),(0,r.kt)("p",null,'You can also omit binding a variable to a node or relationship in your graph patterns if\nyou will not use them in somewhere else in your query (e.g., WHERE or RETURN). For example, below, we query for 2-hop paths searching for "the cities of Users that "a" Follows".\nBecause we do not need to return the Users that "a" Users follows or the properties\nof the Follows and LivesIn edges that form these 2-paths, we can omit giving variable names to them.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MATCH (a:User)-[:Follows]->(:User)-[:LivesIn]->(c:City)\nWHERE a.name = "Adam"\nRETURN a, c.name, c.population;\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------------\n| a                                             | c.name    | c.population |\n----------------------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30} | Waterloo  | 150000       |\n----------------------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30} | Kitchener | 200000       |\n----------------------------------------------------------------------------\n")),(0,r.kt)("h3",{id:"match-multiple-patterns"},"Match Multiple Patterns"),(0,r.kt)("p",null,"Although paths can be matched in a single pattern, some patterns, in particular\ncyclic patterns, require specifying multiple patterns/paths that form the pattern.\nThese multiple paths are separated by a comma. The following is a (directed) triangle\nquery and returns the only triangle in the database between Adam, Karissa, and Zhang."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[:Follows]->(b:User)-[:Follows]->(c:User), (a)-[:Follows]->(c)\nRETURN a.name, b.name, c.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------\n| a.name | b.name  | c.name |\n-----------------------------\n| Adam   | Karissa | Zhang  |\n-----------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=NQIITQTloYO_"},"Colab"),"."),(0,r.kt)("p",null,"Note that in the query node variables a and c appear twice, once on each of the 2 paths\nin the query. In such cases, their labels need to be specified ",(0,r.kt)("em",{parentName:"p"},"only the first time they appear\nin the pattern"),". In the above query a and c's labels are defined on the first/left path,\nso you don't have to specify them on the right path (though you still can)."),(0,r.kt)("h3",{id:"equality-predicates-on-noderel-properties"},"Equality Predicates on Node/Rel Properties"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/query-clauses/where"},"WHERE clause"),' is the main clause to specify arbitary predicates on the nodes and relationships in your patters (e.g., a.age < b.age in where "a" and "b" bind to User nodes).\nAs a syntactic sugar openCypher allows ',(0,r.kt)("em",{parentName:"p"},"equality predicates")," to be matched on\nnodes and edges using the ",(0,r.kt)("inlineCode",{parentName:"p"},"{prop1 : value1, prop2 : value2, ...}")," syntax. For example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MATCH (a:User)-[e:Follows {since: 2020}]->(b:User {name: "Zhang"})\nRETURN a, e.since, b.name;\n')),(0,r.kt)("p",null,"is a syntactic sugar for:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MATCH (a:User)-[e:Follows]->(b:User)\nWHERE e.since = 2020 AND b.name = "Zhang"\nRETURN a, e.since, b.name;\n')),(0,r.kt)("p",null,"and both queries output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------------------------------------------------------\n| a                                             | e.since | b.name |\n--------------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30} | 2020    | Zhang  |\n--------------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=1frFFis4onqw"},"Colab"),"."),(0,r.kt)("h2",{id:"match-variable-length-relationships"},"Match Variable Length Relationships"),(0,r.kt)("p",null,"You can also find paths that are variable-length between node records. Specifically, you can find variable-hop connections between nodes by specifying in the relationship patterns,\ne.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"-[:Label*min..max]->"),", where min and max specify the minimum and the maximum number of hops",(0,r.kt)("sup",{parentName:"p",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),'.\nThe following query finds all Users that "Adam" follows within 1 to 2 hops and returns their names as well as length of the path.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows*1..2]->(b:User) \nWHERE a.name = 'Adam'\nRETURN b.name, length(e) AS length;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------\n| b.name  | length |\n--------------------\n| Karissa | 1      |\n--------------------\n| Zhang   | 2      |\n--------------------\n| Zhang   | 1      |\n--------------------\n| Noura   | 2      |\n--------------------\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Karissa is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Karissa")),(0,r.kt)("li",{parentName:"ul"},"Zhang is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Zhang")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Karissa -> Zhang")),(0,r.kt)("li",{parentName:"ul"},"Noura is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Zhang -> Noura"))),(0,r.kt)("p",null,'Similar to matching relationships, you can match undirected relationships or relationship with multiple labels.\nThe following query finds all Nodes excluding "Noura" that connects to "Noura" in both directions through any relationship with 2 hops.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e*2..2]-(b) \nWHERE a.name = 'Noura' AND b.name <> 'Noura'\nRETURN b.name, length(e) AS length;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------\n| b.name    | length |\n----------------------\n| Adam      | 2      |\n----------------------\n| Karissa   | 2      |\n----------------------\n| Kitchener | 2      |\n----------------------\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Adam is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Noura <- User -> Adam")),(0,r.kt)("li",{parentName:"ul"},"Karissa is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Noura <- User -> Karissa")),(0,r.kt)("li",{parentName:"ul"},"Kitchener is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Noura <- User -> Kitchener"))),(0,r.kt)("h3",{id:"returning-variable-length-relationships"},"Returning Variable Length Relationships"),(0,r.kt)("p",null,"A varible length relationship is a ",(0,r.kt)("inlineCode",{parentName:"p"},"STURCT{LIST[NODE], LIST[REL]}"),". Returning a variable length relationship will return all properties "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows*1..2]->(b:User) \nWHERE a.name = 'Adam'\nRETURN b.name, e;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------------------------------\n| b.name  | e                                                                                |\n----------------------------------------------------------------------------------------------\n| Karissa | {_NODES: [], _RELS: [(0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1)]}     |\n----------------------------------------------------------------------------------------------\n| Zhang   | {_NODES: [{_ID: 0:1, _LABEL: User, name: Karissa, age: 40}], _RELS: [(0:0)-{_... |\n----------------------------------------------------------------------------------------------\n| Zhang   | {_NODES: [], _RELS: [(0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2)]}     |\n----------------------------------------------------------------------------------------------\n| Noura   | {_NODES: [{_ID: 0:2, _LABEL: User, name: Zhang, age: 50}], _RELS: [(0:0)-{_LA... |\n----------------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Further notes on variable length relationships")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The maximum length of variable length relationships is capped at 30. ")),(0,r.kt)("h3",{id:"filter-variable-length-relationships"},"Filter Variable Length Relationships"),(0,r.kt)("p",null,"We also support running predicates on recursive patterns to constrain the relationship being traversed."),(0,r.kt)("p",null,"The following query finds name of users and the number of path that are followed between 1 - 2 hops from Adam by person with age more than 45 and before 2022."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows*1..2 (r, n | WHERE r.since < 2022 AND n.age > 45) ]->(b:User)\nWHERE a.name = 'Adam' \nRETURN b.name, COUNT(*);\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------------\n| b.name  | COUNT_STAR() |\n--------------------------\n| Karissa | 1            |\n--------------------------\n| Zhang   | 1            |\n--------------------------\n")),(0,r.kt)("p",null,"Our filter grammar follows ",(0,r.kt)("a",{parentName:"p",href:"https://memgraph.com/docs/memgraph/reference-guide/built-in-graph-algorithms"},"Memgraph")," using list comprehension. The first variable represents intermedaite relationships and the second one represents intermediate nodes. "),(0,r.kt)("h3",{id:"projecting-properties-of-intermediate-nodes-and-relationships-in-variable-length-relationships"},"Projecting Properties of Intermediate Nodes and Relationships in Variable Length Relationships"),(0,r.kt)("p",null,"You can project a subset of properties for the intermediate nodes and relationships that bind within a variable length\nrelationship. You can define the projection list of intermediate nodes and rels within two curly brackets ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," at\nthe end of the variable length pattern. The first ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," is used for projecting relationship properties and the second ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," for\nnode properties. Currently, K\xf9zu only supports directly projecting properties and not of expresions using\nthe properties. Projecting properties of intermedaite nodes and relashionships can improve both performance and memory footprint."),(0,r.kt)("p",null,"Below is an example that projects only the ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," property of the intermediate relationship and the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," property of the\nintermediate nodes that will bind to the variable length relationship pattern of ",(0,r.kt)("inlineCode",{parentName:"p"},"e"),". Readers can assume\nthat there are other properties than ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Follow")," relationship table for our purposes (in our running example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," nodes already have a second property ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),", which will be removed from the output as shown below)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows*1..2 (r, n | WHERE r.since > 2020 | {r.since}, {n.name})]->(b:User) \nRETURN nodes(e), rels(e);\n")),(0,r.kt)("p",null,"Returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"------------------------------------------------------------------------------------------------------------------------------\n| NODES(e)                                | RELS(e)                                                                          |\n------------------------------------------------------------------------------------------------------------------------------\n| []                                      | [(0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2)]                          |\n------------------------------------------------------------------------------------------------------------------------------\n| [{_ID: 0:2, _LABEL: User, name: Zhang}] | [(0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2),(0:2)-{_LABEL: Follows... |\n------------------------------------------------------------------------------------------------------------------------------\n| []                                      | [(0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3)]                          |\n------------------------------------------------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"As can be seen in the output, the nodes that bind to ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," contain only the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," property and the relationships that\nbind to ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," contain only the ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," property."),(0,r.kt)("h3",{id:"single-shortest-path"},"Single Shortest Path"),(0,r.kt)("p",null,"On top of variable length relationships, users can search for single shortest path by specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"SHORTEST")," key word in relationship, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"-[:Label* SHORTEST 1..max]"),".\nThe following query finds a shortest path between ",(0,r.kt)("inlineCode",{parentName:"p"},"Adam")," and any city and returns city name as well as length of the path."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e* SHORTEST 1..4]->(b:City) \nWHERE a.name = 'Adam'\nRETURN b.name, length(e) AS length;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------\n| b.name    | length |\n----------------------\n| Waterloo  | 1      |\n----------------------\n| Kitchener | 2      |\n----------------------\n| Guelph    | 3      |\n----------------------\n")),(0,r.kt)("h3",{id:"all-shortest-path"},"All Shortest Path"),(0,r.kt)("p",null,"You can also search for all shortest path with ",(0,r.kt)("inlineCode",{parentName:"p"},"ALL SHORTEST")," key word, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"-[:Label* ALL SHORTEST 1..max]")),(0,r.kt)("p",null,"The following query finds all shortest path between ",(0,r.kt)("inlineCode",{parentName:"p"},"Zhang")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Waterloo"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a)-[* ALL SHORTEST 1..3 ]-(b) \nWHERE a.name = 'Zhang' AND b.name = 'Waterloo' \nRETURN COUNT(*) AS num_shortest_path;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"---------------------\n| num_shortest_path |\n---------------------\n| 2                 |\n---------------------\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Further notes on shortest path"),"\nWe force the lower bound of shortest path to be 1 to avoid ambiguity. There are two interpretations when the lower bound is greater than 1, "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Compute shortest path and then return the path whose length is greater than the lower bound."),(0,r.kt)("li",{parentName:"ul"},"Compute the path with length greater than lower bound and then return the shortest path.")),(0,r.kt)("h2",{id:"named-path"},"Named Path"),(0,r.kt)("p",null,"K\xf9zu treats paths as a first-class citizen, so users can assign a named variable to a path (i.e. connected graph ) and use it later on."),(0,r.kt)("p",null,"The following query returns all paths between ",(0,r.kt)("inlineCode",{parentName:"p"},"Adam")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Karissa"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows]->(b:User) \nWHERE a.name = 'Adam' AND b.name = 'Karissa' \nRETURN p;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"------------------------------------------------------------------------------------\n| p                                                                                |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: Us... |\n------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"Named paths can also be assigned to recursive graph patterns."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows*1..2]->(:User)-[:LivesIn]->(:City) \nWHERE a.name = 'Adam' \nRETURN p;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"------------------------------------------------------------------------------------\n| p                                                                                |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:1, _LABEL: ... |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:2, _LABEL: ... |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:1, _LABEL: ... |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:2, _LABEL: ... |\n------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"Multiple named path can appear in a single ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH")," clause."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p1 = (a:User)-[:Follows]->(b:User), p2 = (b)-[:LivesIn]->(:City) \nWHERE a.name = 'Adam' \nRETURN p1, p2;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| p1                                                                               | p2                                                                               |\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: Us... | {_NODES: [{_ID: 0:1, _LABEL: User, name: Karissa, age: 40, },{_ID: 1:0, _LABE... |\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:2, _LABEL: Us... | {_NODES: [{_ID: 0:2, _LABEL: User, name: Zhang, age: 50, },{_ID: 1:1, _LABEL:... |\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n")),(0,r.kt)("h3",{id:"extracting-nodes-rels-from-a-path"},"Extracting Nodes, Rels From a Path"),(0,r.kt)("p",null,"Interanally ",(0,r.kt)("inlineCode",{parentName:"p"},"PATH")," is processed as a ",(0,r.kt)("inlineCode",{parentName:"p"},"STRUCT{LIST[NODE], LIST[REL]}")," see ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/data-types/path"},(0,r.kt)("inlineCode",{parentName:"a"},"PATH data type"))," for details. Users can access nodes and rels within a path through ",(0,r.kt)("inlineCode",{parentName:"p"},"nodes(p)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"rels(p)")," function calls."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows*1..2]->(:User) \nWHERE a.name = 'Adam' \nRETURN nodes(p), (rels(p)[1]).since AS since;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------------------------------------------------------------------------------\n| NODES(p)                                                                         | since |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:2, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:2, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"More path functions can be found ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/expressions/path_functions"},"here"),"."),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"MATCH is similar to the FROM clause of SQL, where the list of tables that need to be joined are specified. ",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},"Max number of hop will be set to 30 if omitted. You can change the configuration through ",(0,r.kt)("inlineCode",{parentName:"li"},"SET")," statement.",(0,r.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0},5973:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/images/running-example-db76aa393fd70d29c831f1527455440a.png"}}]);