"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[6499],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),p=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(u.Provider,{value:t},e.children)},s="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),s=p(n),m=r,y=s["".concat(u,".").concat(m)]||s[m]||d[m]||i;return n?a.createElement(y,l(l({ref:t},c),{},{components:n})):a.createElement(y,l({ref:t},c))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o[s]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},754:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={title:"UDF",sidebar_position:8},l="UDF API",o={unversionedId:"client-apis/cpp-api/udf",id:"client-apis/cpp-api/udf",title:"UDF",description:"K\xf9zu provides users with two interfaces that enable them to define their own custom scalar and vectorized functions.",source:"@site/docs/client-apis/cpp-api/udf.md",sourceDirName:"client-apis/cpp-api",slug:"/client-apis/cpp-api/udf",permalink:"/docusaurus/client-apis/cpp-api/udf",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"UDF",sidebar_position:8},sidebar:"docSidebar",previous:{title:"C++ API",permalink:"/docusaurus/client-apis/cpp-api/"},next:{title:"C",permalink:"/docusaurus/client-apis/c"}},u={},p=[{value:"Connection::createScalarFunction",id:"connectioncreatescalarfunction",level:2},{value:"1. Create a scalar function by automatically inferring the parameter and result type in K\xf9zu.",id:"1-create-a-scalar-function-by-automatically-inferring-the-parameter-and-result-type-in-k\xf9zu",level:3},{value:"a. Parameters:",id:"a-parameters",level:4},{value:"b. Inference rule for c++ type to cypher type is defined as:",id:"b-inference-rule-for-c-type-to-cypher-type-is-defined-as",level:4},{value:"c. Example:",id:"c-example",level:4},{value:"2. Create a scalar function with input and return type in cypher.",id:"2-create-a-scalar-function-with-input-and-return-type-in-cypher",level:3},{value:"a. Parameters:",id:"a-parameters-1",level:4},{value:"b. Cypher and C++ type mapping:",id:"b-cypher-and-c-type-mapping",level:4},{value:"c. Example:",id:"c-example-1",level:4},{value:"Connection::createVectorizedFunction",id:"connectioncreatevectorizedfunction",level:2},{value:"Vector types in K\xf9zu:",id:"vector-types-in-k\xf9zu",level:3},{value:"1. Flat vector: The vector only holds one value at <code>selectedPositions[0]</code> position.",id:"1-flat-vector-the-vector-only-holds-one-value-at-selectedpositions0-position",level:4},{value:"2. Unflat vector: The vector can hold SELECTED_SIZE number of values.",id:"2-unflat-vector-the-vector-can-hold-selected_size-number-of-values",level:4},{value:"1. Create a vectorized function by automatically inferring the parameter and result type in K\xf9zu.",id:"1-create-a-vectorized-function-by-automatically-inferring-the-parameter-and-result-type-in-k\xf9zu",level:3},{value:"a. Parameters:",id:"a-parameters-2",level:4},{value:"b. Inference rule for c++ type to cypher type is defined as:",id:"b-inference-rule-for-c-type-to-cypher-type-is-defined-as-1",level:4},{value:"c. Example:",id:"c-example-2",level:4},{value:"2. Create a vectorized function with input and return type in cypher.",id:"2-create-a-vectorized-function-with-input-and-return-type-in-cypher",level:3},{value:"a. Parameters:",id:"a-parameters-3",level:4},{value:"b. Inference rule for c++ type to cypher type is defined as:",id:"b-inference-rule-for-c-type-to-cypher-type-is-defined-as-2",level:4},{value:"c. Example:",id:"c-example-3",level:4}],c={toc:p},s="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(s,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"udf-api"},"UDF API"),(0,r.kt)("p",null,"K\xf9zu provides users with two interfaces that enable them to define their own custom scalar and vectorized functions."),(0,r.kt)("h2",{id:"connectioncreatescalarfunction"},"Connection::createScalarFunction"),(0,r.kt)("p",null,"This API allows user to register ordinary scalar functions which are defined in c++ and use them as K\xf9zu built-in functions in a query. UDF functions are as efficient as the built-in functions.\nSince two c++ primitive types may map to the same Cypher data types(e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"int32")," can map to both ",(0,r.kt)("inlineCode",{parentName:"p"},"INT32")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"DATE")," in K\xf9zu), K\xf9zu provides two overloaded APIs which can eliminate the ambiguity in datatype mapping."),(0,r.kt)("h3",{id:"1-create-a-scalar-function-by-automatically-inferring-the-parameter-and-result-type-in-k\xf9zu"},"1. Create a scalar function by automatically inferring the parameter and result type in K\xf9zu."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"template<typename TR, typename... Args>\nvoid createScalarFunction(const std::string& name, TR (*udfFunc)(Args...))\n")),(0,r.kt)("h4",{id:"a-parameters"},"a. Parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"template parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"TR: return type of the UDF in c++."),(0,r.kt)("li",{parentName:"ul"},"ARGS: are the type of the arguments in c++, K\xf9zu currently support UDF functions with up to 3 parameters."))),(0,r.kt)("li",{parentName:"ul"},"parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"name: the name of the function to be created in K\xf9zu (note: function name must be unique)."),(0,r.kt)("li",{parentName:"ul"},"udfFunc: the UDF defined in c++.")))),(0,r.kt)("h4",{id:"b-inference-rule-for-c-type-to-cypher-type-is-defined-as"},"b. Inference rule for c++ type to cypher type is defined as:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"C++ type"),(0,r.kt)("th",{parentName:"tr",align:null},"Cypher type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"BOOL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int16"),(0,r.kt)("td",{parentName:"tr",align:null},"INT16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int32"),(0,r.kt)("td",{parentName:"tr",align:null},"INT32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"INT64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"FLOAT")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::string"),(0,r.kt)("td",{parentName:"tr",align:null},"STRING")))),(0,r.kt)("h4",{id:"c-example"},"c. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Create a unary scalar function which adds 5 to the input value.\nstatic int32_t add5(int32_t x) {\n    return x + 5;\n}\n// Register the unary scalar function using the createScalarFunction API.\nconn->createScalarFunction("add5", &add5);\n// Issue a query using the UDF.\nconn->query("MATCH (p:person) return add5(to_int32(p.age))");\n')),(0,r.kt)("h3",{id:"2-create-a-scalar-function-with-input-and-return-type-in-cypher"},"2. Create a scalar function with input and return type in cypher."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"template<typename TR, typename... Args>\nvoid createScalarFunction(const std::string& name, TR (*udfFunc)(Args...))\n")),(0,r.kt)("h4",{id:"a-parameters-1"},"a. Parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"template parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"TR: return type of the UDF in c++."),(0,r.kt)("li",{parentName:"ul"},"ARGS: are the type of the arguments in c++, K\xf9zu currently support UDF functions with up to 3 parameters."))),(0,r.kt)("li",{parentName:"ul"},"parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"name: the name of the function to be created in K\xf9zu (note: function name must be unique)."),(0,r.kt)("li",{parentName:"ul"},"parameterTypes: the type of parameters in cypher."),(0,r.kt)("li",{parentName:"ul"},"returnType: the type of return value in cypher."),(0,r.kt)("li",{parentName:"ul"},"udfFunc: the UDF defined in c++.\nNote: This function also checks the template types of UDF against the Cypher types passed as arguments(parameterTypes and returnType) and they must follow the rule defined in the data type mapping table.")))),(0,r.kt)("h4",{id:"b-cypher-and-c-type-mapping"},"b. Cypher and C++ type mapping:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Cypher type"),(0,r.kt)("th",{parentName:"tr",align:null},"C++ type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,r.kt)("td",{parentName:"tr",align:null},"bool")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT16"),(0,r.kt)("td",{parentName:"tr",align:null},"int16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT32, DATE"),(0,r.kt)("td",{parentName:"tr",align:null},"int32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT64, TIMESTAMP"),(0,r.kt)("td",{parentName:"tr",align:null},"int64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FLOAT"),(0,r.kt)("td",{parentName:"tr",align:null},"float")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE"),(0,r.kt)("td",{parentName:"tr",align:null},"double")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"STRING"),(0,r.kt)("td",{parentName:"tr",align:null},"std::string")))),(0,r.kt)("h4",{id:"c-example-1"},"c. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Create a binary scalar function which adds microseconds to the timestamp value.\nstatic int64_t addMicroSeconds(int64_t timestamp, int32_t microSeconds) {\n    return timestamp + microSeconds;\n}\n// Register the binary scalar function using the createScalarFunction API.\nconn->createScalarFunction("addMicro",\n        std::vector<common::LogicalTypeID>{\n            common::LogicalTypeID::TIMESTAMP, common::LogicalTypeID::INT32},\n        common::LogicalTypeID::TIMESTAMP, &addMicroSeconds);\n// Issue a query using the UDF.\nconn->query("MATCH (p:person) return addMicro(p.registerTime, to_int32(p.ID))")\n')),(0,r.kt)("h2",{id:"connectioncreatevectorizedfunction"},"Connection::createVectorizedFunction"),(0,r.kt)("p",null,"K\xf9zu executes functions on input data in an efficient and vectorized way. In addition to creating scalar user-defined functions(UDFs), K\xf9zu also provides support for vectorized UDFs. Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"createScalarFunction"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"createVectorizedFunction")," also offers two APIs to enhance clarity in datatype mapping."),(0,r.kt)("h3",{id:"vector-types-in-k\xf9zu"},"Vector types in K\xf9zu:"),(0,r.kt)("h4",{id:"1-flat-vector-the-vector-only-holds-one-value-at-selectedpositions0-position"},"1. Flat vector: The vector only holds one value at ",(0,r.kt)("inlineCode",{parentName:"h4"},"selectedPositions[0]")," position."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Example:\n// Get the position, which stores the value, in the flatVector.\nauto pos = flatVector->state->selVector->selectedPositions[0];\n// Check whether the value is null.\nauto isNull = flatVector->isNull(pos)\n// Get the value in the vector using the position.\nauto value = flatVector->getValue<datatype>(pos)\n// Set the value in the vector using the position.\nflatVector->setValue(pos, 5 /* valueToSet */)\n// Set the value to not-null in the vector using the position.\nflatVector->setNull(pos, false /* notNull */)\n")),(0,r.kt)("h4",{id:"2-unflat-vector-the-vector-can-hold-selected_size-number-of-values"},"2. Unflat vector: The vector can hold SELECTED_SIZE number of values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Example:\n// Traverse the unflat int64 vector, and add 5 to each value if not null.\n for (auto i = 0u; i < vector.state->selVector->selectedSize; i++) {\n        // Get the position which stores the ith value in the vector.\n        auto pos = vector.state->selVector->selectedPositions[i];\n        // Check whether the value is null.\n        if (!vector.isNull(pos)) {\n            // Retrieve the ith value.\n            auto originalVal = vector.getValue<int64_t>(pos);\n            // Update the ith value.\n            vector.setValue(pos, originalVal + 5);\n        }\n}\n")),(0,r.kt)("h3",{id:"1-create-a-vectorized-function-by-automatically-inferring-the-parameter-and-result-type-in-k\xf9zu"},"1. Create a vectorized function by automatically inferring the parameter and result type in K\xf9zu."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"template<typename TR, typename... Args>\nvoid createVectorizedFunction(const std::string& name, function::scalar_exec_func scalarFunc)\n")),(0,r.kt)("h4",{id:"a-parameters-2"},"a. Parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"template parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"TR: return type of the UDF in c++."),(0,r.kt)("li",{parentName:"ul"},"ARGS: are the type of the arguments in c++, K\xf9zu currently support UDF functions with up to 3 parameters."))),(0,r.kt)("li",{parentName:"ul"},"parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"name: the name of the function to be created in K\xf9zu (note: function name must be unique)."),(0,r.kt)("li",{parentName:"ul"},"scalarFunc: a vectorized udf function. The vectorized udf function takes in a vector of ValueVectors and puts the result in the resultVector.")))),(0,r.kt)("h4",{id:"b-inference-rule-for-c-type-to-cypher-type-is-defined-as-1"},"b. Inference rule for c++ type to cypher type is defined as:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"C++ type"),(0,r.kt)("th",{parentName:"tr",align:null},"Cypher type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"BOOL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int16"),(0,r.kt)("td",{parentName:"tr",align:null},"INT16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int32"),(0,r.kt)("td",{parentName:"tr",align:null},"INT32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"INT64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"FLOAT")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::string"),(0,r.kt)("td",{parentName:"tr",align:null},"STRING")))),(0,r.kt)("h4",{id:"c-example-2"},"c. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Create a vectorized function which adds 4 to each value.\nstatic void addFour(\n    const std::vector<std::shared_ptr<ValueVector>>& parameters, ValueVector& result) {\n    assert(parameters.size() == 1);\n    auto parameter = parameters[0];\n    result.resetAuxiliaryBuffer();\n    result.state = parameter->state;\n    if (parameter->state->isFlat()) {\n        auto pos = parameter->state->selVector->selectedPositions[0];\n        result.setValue(pos, parameter->getValue<int64_t>(pos) + 4);\n    } else {\n        for (auto i = 0u; i < parameter->state->selVector->selectedSize; i++) {\n            auto pos = parameter->state->selVector->selectedPositions[i];\n            result.setValue(pos, parameter->getValue<int64_t>(pos) + 4);\n        }\n    }\n}\n// Register the vectorized function using the createVectorizedFunction API.\nconn->createVectorizedFunction<int64_t, int64_t>("addFour", &addFour);\n// Issue a query using the UDF.\nconn->query("MATCH (p:person) return addFour(p.age)");\n')),(0,r.kt)("h3",{id:"2-create-a-vectorized-function-with-input-and-return-type-in-cypher"},"2. Create a vectorized function with input and return type in cypher."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," void createVectorizedFunction(const std::string& name,\n        std::vector<common::LogicalTypeID> parameterTypes, common::LogicalTypeID returnType,\n        function::scalar_exec_func scalarFunc)\n")),(0,r.kt)("h4",{id:"a-parameters-3"},"a. Parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"parameters:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"name: the name of the function to be created in K\xf9zu (note: function name must be unique)."),(0,r.kt)("li",{parentName:"ul"},"parameterTypes: the type of parameters in cypher."),(0,r.kt)("li",{parentName:"ul"},"returnType: the type of return value in cypher."),(0,r.kt)("li",{parentName:"ul"},"scalarFunc: a vectorized udf function. The vectorized udf function takes in a vector of ValueVectors and puts the result in the resultVector.")))),(0,r.kt)("h4",{id:"b-inference-rule-for-c-type-to-cypher-type-is-defined-as-2"},"b. Inference rule for c++ type to cypher type is defined as:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Cypher type"),(0,r.kt)("th",{parentName:"tr",align:null},"C++ type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,r.kt)("td",{parentName:"tr",align:null},"bool")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT16"),(0,r.kt)("td",{parentName:"tr",align:null},"int16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT32, DATE"),(0,r.kt)("td",{parentName:"tr",align:null},"int32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT64, TIMESTAMP"),(0,r.kt)("td",{parentName:"tr",align:null},"int64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FLOAT"),(0,r.kt)("td",{parentName:"tr",align:null},"float")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE"),(0,r.kt)("td",{parentName:"tr",align:null},"double")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"STRING"),(0,r.kt)("td",{parentName:"tr",align:null},"std::string")))),(0,r.kt)("h4",{id:"c-example-3"},"c. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Create a scalar function which adds right(number of days) to the left(date).\nstruct AddDate {\n    static inline void operation(date_t& left, int64_t& right, date_t& result) {\n        result.days = (int32_t)(left.days + right);\n    }\n};\n// Utilize the pre-defined `function::BinaryFunctionExecutor::execute` API to execute the AddDate function on parameters.\n// Note: Users can utilize K\xf9zu pre-defined FunctionExecutors(UnaryFunctionExecutor, BinaryFunctionExecutor, TernaryFunctionExecutor) to execute operations on parameters without writing code to retrieve the valueVectors.\nstatic void addDate(\n    const std::vector<std::shared_ptr<ValueVector>>& parameters, ValueVector& result) {\n    assert(parameters.size() == 2);\n    function::BinaryFunctionExecutor::execute<date_t, int64_t, date_t, AddDate>(\n        *parameters[0], *parameters[1], result);\n}\n// Register the vectorized function using the createVectorizedFunction API.\nconn->createVectorizedFunction("addDate", std::vector<LogicalTypeID>{LogicalTypeID::DATE, LogicalTypeID::INT64}, LogicalTypeID::DATE, &addDate);\n// Issue a query using the UDF.\nconn->query("MATCH (p:person) return addDate(p.birthdate, p.age)");\n')))}d.isMDXComponent=!0}}]);