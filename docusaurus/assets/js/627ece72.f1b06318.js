"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[9589],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=r,u=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return a?n.createElement(u,s(s({ref:t},h),{},{components:a})):n.createElement(u,s({ref:t},h))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},94:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>d,default:()=>y,frontMatter:()=>h,metadata:()=>p,toc:()=>u});var n=a(7462),r=(a(7294),a(3905)),i=a(6151),s=a(3036),o=a(6624),l=a(3826),c=a(3249);const h={slug:"transforming-your-data-to-graphs-1",authors:["prashanth"],tags:["use-case"]},d="Transforming your data to graphs - Part 1",p={permalink:"/docusaurus/blog/transforming-your-data-to-graphs-1",source:"@site/blog/2024-01-24-transforming-your-data-1/index.md",title:"Transforming your data to graphs - Part 1",description:"Ever since the birth of database management systems (DBMSs), tabular relations and graphs have been",date:"2024-01-24T00:00:00.000Z",formattedDate:"January 24, 2024",tags:[{label:"use-case",permalink:"/docusaurus/blog/tags/use-case"}],readingTime:13.595,hasTruncateMarker:!0,authors:[{name:"Prashanth Rao",title:"AI Engineer at K\xf9zu Inc.",url:"https://github.com/prrao87",imageURL:"https://kuzudb.com/img/blog/prashanth.png",key:"prashanth"}],frontMatter:{slug:"transforming-your-data-to-graphs-1",authors:["prashanth"],tags:["use-case"]},prevItem:{title:"K\xf9zu 0.2.0 Release",permalink:"/docusaurus/blog/kuzu-0.2.0-release"},nextItem:{title:"RAG Using Unstructured Data & Role of Knowledge Graphs",permalink:"/docusaurus/blog/llms-graphs-part-2"}},m={authorsImageUrls:[void 0]},u=[{value:"When are graphs useful?",id:"when-are-graphs-useful",level:2},{value:"Extract, Transform, Load (ETL)",id:"extract-transform-load-etl",level:2},{value:"Relational schema",id:"relational-schema",level:3},{value:"Graph schema",id:"graph-schema",level:3},{value:"Transforming relational data to graphs",id:"transforming-relational-data-to-graphs",level:3},{value:"Node tables",id:"node-tables",level:3},{value:"Edge tables",id:"edge-tables",level:3},{value:"Insert data into K\xf9zu",id:"insert-data-into-k\xf9zu",level:2},{value:"Querying the graph",id:"querying-the-graph",level:2},{value:"Visualization",id:"visualization",level:2},{value:"Verify schema",id:"verify-schema",level:3},{value:"Visualize nodes and edges",id:"visualize-nodes-and-edges",level:3},{value:"Conclusions",id:"conclusions",level:2},{value:"Code",id:"code",level:2},{value:"Further reading",id:"further-reading",level:2}],g={toc:u},k="wrapper";function y(e){let{components:t,...a}=e;return(0,r.kt)(k,(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Ever since the birth of database management systems (DBMSs), tabular relations and graphs have been\nthe core data structures used to model application data in two broad classes of systems:\nrelational DBMSs (RDBMS) and graph DBMSs (GDBMS)."),(0,r.kt)("p",null,'In this post, we\'ll look at how to transform data that might exist in a typical relational system\nto a graph and load it into a K\xf9zu database. The aim of this post and the next one is to showcase\n"graph thinking"',(0,r.kt)("sup",{parentName:"p",id:"fnref-1-105625"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1-105625",className:"footnote-ref"},"1")),", where you explore connections in your existing structured data and apply\nit to potentially uncover new insights."),(0,r.kt)("admonition",{title:"Code",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The code to reproduce the workflow shown in this post can be found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/graphdb-demo/tree/main/src/python/transactions"},"graphdb-demo")," repository.\nIt uses K\xf9zu's Python API, but you are welcome to use the client API ",(0,r.kt)("a",{parentName:"p",href:"https://kuzudb.com/docusaurus/client-apis"},"of your choice"),".")),(0,r.kt)("h2",{id:"when-are-graphs-useful"},"When are graphs useful?"),(0,r.kt)("p",null,"Enterprise data often exists in the form of relational tables. In an RDBMS, connections\nbetween entities are often implicitly defined by the schema of the tables via foreign key\nconstraints. Graphs instead represent records in a more object-oriented manner by explicitly defining\nentities (or objects) and relationships (or edges) between these entities, offering several benefits:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A graph data model provides a more natural abstraction to represent indirect or recursive\nrelationships between entities as paths."),(0,r.kt)("li",{parentName:"ol"},"Graph models generally have better support for less-structured or heterogenous data,\nwhere objects can be of multiple types or connect to other objects in non-uniform ways.\nThe relational data model on the other hand, requires strict schematization of the data and SQL\nrequires joining records through explicitly named tables.")),(0,r.kt)("p",null,"Query languages over graphs often provide the means to find relationships between nodes without\nexplicitly naming them, e.g., in Cypher, the ",(0,r.kt)("inlineCode",{parentName:"p"},'(a:Person {name: "Alice})-[]->(b:Person {name:Bob})'),"\npattern will find all possible relationships between nodes with names Alice and Bob. Although SQL is\nsuitable to express queries for a variety of standard data analytics tasks, it is arguably not as\nsuitable when it comes to expressing queries with recursive joins or those that describe complex\npatterns \u2014 they are expressed more naturally as paths or graph patterns. Graph queries\nin a well-designed GDBMS like K\xf9zu contain ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Kleene_star"},"specialized syntaxes"),"\nand operators for these types of query workloads."),(0,r.kt)("p",null,"For a much more detailed description on the benefits of graph modeling and GDBMSs, see our earlier\n",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/blog/what-every-gdbms-should-do-and-vision"},"blog post"),"."),(0,r.kt)("admonition",{title:"Note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"It's important to understand that ",(0,r.kt)("em",{parentName:"p"},"data itself")," doesn't exist as graphs, tables, arrays and so on.\nThese are just different ways of representing and storing the data. It's completely up to the\ndeveloper to choose the right data structure depending on question being answered or the application\nbeing developed.")),(0,r.kt)("h2",{id:"extract-transform-load-etl"},"Extract, Transform, Load (ETL)"),(0,r.kt)("p",null,"The dataset we'll use in this post involves a set of merchants, customers and transactions",(0,r.kt)("sup",{parentName:"p",id:"fnref-2-105625"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2-105625",className:"footnote-ref"},"2")),". The\ngoal is to study the transactions and their relationships using graph queries."),(0,r.kt)("h3",{id:"relational-schema"},"Relational schema"),(0,r.kt)("p",null,"We can imagine this dataset as it exists in a typical relational system. The schema might look\nsomething like this:"),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:i.Z})),(0,r.kt)("p",null,"The client table stores unique client IDs and their metadata. The merchant table stores unique\ninstances of merchants and what parent company they belong to. Transaction data is stored in the\ntransaction table, which shows the transaction ID, the client ID, the merchant ID, the amount\nof the transaction and when it occurred. Company and city tables exist to store metadata about\nthe parent companies and cities where the merchants are located. The connectivity between the\ntables is expressed via foreign key constraints."),(0,r.kt)("h3",{id:"graph-schema"},"Graph schema"),(0,r.kt)("p",null,"While the relational schema is useful for rapidly storing transactional data and for performing\naggregate queries, it's not as useful when it comes to answering questions about the relationships\nin the data. Some such questions are listed below:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Who are the clients of Company X, i.e., clients who transacted with the merchants of Company X?"),(0,r.kt)("li",{parentName:"ol"},"Who are the clients who transacted with at least 2 separate merchants operating in City A?"),(0,r.kt)("li",{parentName:"ol"},"Which companies have merchants in City X, City Y ",(0,r.kt)("strong",{parentName:"li"},"and")," City Z (i.e., in all 3 cities)?"),(0,r.kt)("li",{parentName:"ol"},"What connections exist between Client A and Client B (maybe they transacted with the same\nmerchant, or with merchants in the same city, or with merchants belonging to the same company)?")),(0,r.kt)("p",null,"With these questions in mind, we can proceed to sketch the following graph schema, which is a visual\nrepresentation of a data model that considers how the concepts are connected in the real world."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:s.Z})),(0,r.kt)("p",null,"In the schema above, note how the implicit foreign keys defined in the relational\nschema, such as the one between ",(0,r.kt)("inlineCode",{parentName:"p"},"Merchant")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"City"),", get ",(0,r.kt)("em",{parentName:"p"},"explicit")," names, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"LocatedIn"),".\nSimilarly, the two foreign keys in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Transaction")," relation between ",(0,r.kt)("inlineCode",{parentName:"p"},"Client")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Merchant")," get an\nexplicit name ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactedWith"),"."),(0,r.kt)("h3",{id:"transforming-relational-data-to-graphs"},"Transforming relational data to graphs"),(0,r.kt)("p",null,"A key feature of K\xf9zu is that it's a ",(0,r.kt)("strong",{parentName:"p"},"schema-based")," graph database, making it\nhighly convenient to read data that already exists in relational systems. Like RDBMSs, K\xf9zu also relies\non strongly-typed values in columns and uses primary key constraints on tables to model the data.\nThe only difference is that K\xf9zu uses separate node and edge tables, which we'll show how to\ncreate below."),(0,r.kt)("admonition",{title:"Note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"As such, K\xf9zu can be viewed as a relational system that provides graph\nmodeling capabilities over your tables, allowing you to express graph-based paths and patterns very\nefficiently in Cypher, the query language implemented by K\xf9zu.")),(0,r.kt)("p",null,"In this post, for simplicity, we'll assume that the tables we showed in the relational schema are available\nas CSV files in the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," directory. The ",(0,r.kt)("inlineCode",{parentName:"p"},"load_data.py")," script will transform and load the\ndata into a K\xf9zu database, while the ",(0,r.kt)("inlineCode",{parentName:"p"},"query.py")," file will run some simple queries to test that\nthe load was successful."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},".\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 client.csv\n\u2502   \u251c\u2500\u2500 city.csv\n\u2502   \u251c\u2500\u2500 company.csv\n\u2502   \u251c\u2500\u2500 merchant.csv\n\u2502   \u2514\u2500\u2500 transaction.csv\n\u251c\u2500\u2500 load_data.py\n\u2514\u2500\u2500 query.py\n")),(0,r.kt)("h3",{id:"node-tables"},"Node tables"),(0,r.kt)("p",null,"The data in the ",(0,r.kt)("inlineCode",{parentName:"p"},"client.csv"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"city.csv"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"company.csv")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"merchant.csv")," files are already in the\nright structure for K\xf9zu to load them as node tables. You can create the node tables using the\nfollowing Cypher queries and run them via the K\xf9zu CLI, or the client SDK of your choice."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Client node table\nCREATE NODE TABLE Client(\n    client_id INT64,\n    name STRING,\n    age INT64,\n    PRIMARY KEY (client_id)\n)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// City node table\nCREATE NODE TABLE City(\n    city_id INT64,\n    city STRING,\n    PRIMARY KEY (city_id)\n)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Company node table\nCREATE NODE TABLE Company(\n    company_id INT64,\n    type STRING,\n    company STRING,\n    PRIMARY KEY (company_id)\n)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Merchant node table\nCREATE NODE TABLE Merchant(\n    merchant_id INT64,\n    company_id INT64,\n    city_id INT64,\n    PRIMARY KEY (merchant_id)\n)\n")),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"PRIMARY KEY")," constraints are required on every node table in K\xf9zu, as they are used to\nensure that edges are always created on unique node pairs. In this case, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"client_id"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"city_id"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"company_id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"merchant_id")," columns as the primary keys for each respective table."),(0,r.kt)("h3",{id:"edge-tables"},"Edge tables"),(0,r.kt)("p",null,"The graph schema we designed above requires us to transform some of the existing CSV files in order to\nrepresent the right columns as edge connections in the graph. We'll need to create the following files:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"transacted_with.csv"),": connects a client to a merchant"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"belongs_to.csv"),": connects a merchant to its parent company"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"located_in.csv"),": connects a merchant to a city")),(0,r.kt)("p",null,"We first define the empty table schemas using the ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TO")," keywords that indicate the\ndirection of the edge. The names of the tables: ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactedWith"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"BelongsTo")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LocatedIn"),"\nare the relationship type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// TransactedWith edge table\nCREATE REL TABLE TransactedWith(\n    FROM Client TO Merchant,\n    amount_usd FLOAT,\n    timestamp TIMESTAMP\n)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// BelongsTo edge table\nCREATE REL TABLE LocatedIn(FROM Merchant TO City)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// LocatedIn edge table\nCREATE REL TABLE BelongsTo(FROM Merchant TO Company)\n")),(0,r.kt)("p",null,"In the above code, only ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactedWith")," edges have properties associated with them, namely the\ntransaction amount and the timestamp. The other two edges don't have properties and are simply\nused to connect the nodes based on the values that match a primary key constraint."),(0,r.kt)("p",null,"The data for the edges require minor transformations to the existing CSV files in which the first\nand second columns respectively represent the ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TO")," nodes' primary keys. To help reduce\nthe amount of custom code you have to write, K\xf9zu provides convenient APIs to\nscan/read from CSV files and to copy data from CSV files to a node or edge table. An example is\nshown below."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:o.Z})),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"transaction.csv")," file contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"client_id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"merchant_id")," columns, which are the ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"TO")," nodes' primary keys respectively, but these are not present in the first and second columns\nas the edge table requires. To do this, ",(0,r.kt)("inlineCode",{parentName:"p"},"transaction.csv")," file isn't loaded as-is, but is instead\ntransformed into the ",(0,r.kt)("inlineCode",{parentName:"p"},"transacted_with.csv")," file via the following query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Generate `transacted_with.csv` from `transaction.csv`\nCOPY (\n    LOAD FROM 'transaction.csv' (header=true)\n    RETURN\n        client_id,\n        merchant_id,\n        amount_usd,\n        timestamp\n)\nTO 'transacted_with.csv';\n")),(0,r.kt)("p",null,"The example above consists of two subquery blocks: ",(0,r.kt)("inlineCode",{parentName:"p"},"LOAD")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"COPY"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"LOAD")," block is used to\nscan the CSV file, check for headers and data types and return the columns we need. The ",(0,r.kt)("inlineCode",{parentName:"p"},"COPY"),"\nblock is used to write the results we obtained from the scan to a new file."),(0,r.kt)("p",null,"We can do the same for the other two edge tables as well."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Generate `belongs_to.csv` from `merchant.csv`\nCOPY (\n    LOAD FROM 'merchant.csv' (header=true)\n    RETURN\n        merchant_id,\n        company_id\n)\nTO 'belongs_to.csv';\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Generate `located_in.csv` from `merchant.csv`\nCOPY (\n    LOAD FROM 'merchant.csv' (header=true)\n    RETURN\n        merchant_id,\n        city_id\n)\nTO 'located_in.csv';\n")),(0,r.kt)("p",null,"With all the input files in place, we can now proceed to insert the data and build the graph!"),(0,r.kt)("h2",{id:"insert-data-into-k\xf9zu"},"Insert data into K\xf9zu"),(0,r.kt)("p",null,"Collecting all the above functions, we can write a script that performs the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Transform node/edge tables as needed"),(0,r.kt)("li",{parentName:"ol"},"Create the node tables"),(0,r.kt)("li",{parentName:"ol"},"Create edge tables"),(0,r.kt)("li",{parentName:"ol"},"Load the node tables into the database"),(0,r.kt)("li",{parentName:"ol"},"Load the edge tables into the database")),(0,r.kt)("p",null,"In Python, it would look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Copy from CSV to node tables\nCOPY Client FROM 'client.csv' (header=true)\nCOPY City FROM 'city.csv' (header=true)\nCOPY Company FROM 'company.csv' (header=true)\nCOPY Merchant FROM 'merchant.csv' (header=true)\n\n// Copy from CSV to edge tables\nCOPY TransactedWith FROM 'transacted_with.csv' \nCOPY BelongsTo FROM 'belongs_to.csv'\nCOPY LocatedIn FROM 'located_in.csv'\n")),(0,r.kt)("p",null,"The queries above require that the empty tables were created beforehand. The ",(0,r.kt)("inlineCode",{parentName:"p"},"COPY <edge_table> FROM <file>")," statement\nwrites the data into a K\xf9zu database. Running the queries on an existing database connection\nresults in the graph being saved to a local directory."),(0,r.kt)("h2",{id:"querying-the-graph"},"Querying the graph"),(0,r.kt)("p",null,"We then run some simple queries to test that the data was loaded correctly. We can either create\na standalone script using the client SDK of your choice, or fire up a ",(0,r.kt)("a",{parentName:"p",href:"https://kuzudb.com/docusaurus/getting-started/cli"},"K\xf9zu CLI"),"\nshell and run some Cypher queries."),(0,r.kt)("p",null,'The first query finds all the clients who transacted with the merchants of "Starbucks".'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'// Q1. Who are the clients that transacted with the merchants of "Starbucks"?\nMATCH (c:Client)-[:TransactedWith]->(:Merchant)-[:BelongsTo]->(co:Company)\nWHERE co.company = "Starbucks"\nRETURN DISTINCT c.client_id AS id, c.name AS name;\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"id"),(0,r.kt)("th",{parentName:"tr",align:"center"},"name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"Boris")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"4"),(0,r.kt)("td",{parentName:"tr",align:"center"},"Diana")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"5"),(0,r.kt)("td",{parentName:"tr",align:"center"},"Eve")))),(0,r.kt)("p",null,"Query 2 traverses multiple paths to find clients who transacted with at least 2 separate merchants."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'// Q2. Who are the clients who transacted with at least 2 separate merchants operating in Los Angeles?\nMATCH (c:Client)-[:TransactedWith]->(m1:Merchant)-[:LocatedIn]->(ci:City),\n      (c)-[:TransactedWith]->(m2:Merchant)-[:LocatedIn]->(ci)\nWHERE ci.city = "Los Angeles" AND m1.merchant_id <> m2.merchant_id\nRETURN DISTINCT c.client_id AS id, c.name as name;\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"id"),(0,r.kt)("th",{parentName:"tr",align:"center"},"name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"3"),(0,r.kt)("td",{parentName:"tr",align:"center"},"Cecil")))),(0,r.kt)("p",null,"We can ask more such questions that involve finding multiple paths between nodes as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'// Q3. Which companies have merchants in New York City, Boston **and** Los Angeles?\nMATCH (:City {city: "New York City"})<-[]-(m1:Merchant)-[]->(co:Company),\n      (:City {city: "Boston"})<-[]-(m2)-[]->(co),\n      (:City {city: "Los Angeles"})<-[]-(m3)-[]->(co)\nRETURN DISTINCT co.company AS company\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"company"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"Verizon Wireless")))),(0,r.kt)("p",null,"We can also perform recursive path traversal to see how many common connections exist between\ntwo clients."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"// Q4. How many common connections (cities, merchants, companies) exist between Client IDs 4 and 5?\nMATCH (c1:Client)-[*1..2]->(common)<-[*1..2]-(c2:Client)\nWHERE c1.client_id = 4 AND c2.client_id = 5\nRETURN label(common) AS connectionType, COUNT(label(common)) AS count;\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"connectionType"),(0,r.kt)("th",{parentName:"tr",align:"center"},"count"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"Merchant"),(0,r.kt)("td",{parentName:"tr",align:"center"},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"City"),(0,r.kt)("td",{parentName:"tr",align:"center"},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"Company"),(0,r.kt)("td",{parentName:"tr",align:"center"},"2")))),(0,r.kt)("p",null,"You can verify that the results above are correct by inspecting the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/graphdb-demo/tree/main/src/python/transactions/data"},"raw data"),".\nClients 4 and 5 (Diana and Eve) have both transacted in 2 cities, with 2 merchants belonging to\n2 companies."),(0,r.kt)("p",null,"As can be seen through these examples, we can express queries in Cypher that are naturally expressed\nas patterns and paths (possibly recursive ones), with an intuitive syntax."),(0,r.kt)("h2",{id:"visualization"},"Visualization"),(0,r.kt)("p",null,"Running Cypher queries in a shell editor is great during initial testing, but on completion, obtaining visual\nfeedback is very useful in refining the data model. In a recent blog post, we introduced\n",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/blog/kuzuexplorer"},"K\xf9zu Explorer"),", a browser-based frontend that allows\nusers to visualize their graph data and run queries interactively."),(0,r.kt)("p",null,"The explorer is currently only accessible via Docker, but a standalone application is on the way. To visualize\nthe graph you just created, ensure you have Docker installed, and run the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Ensure you use absolute paths when mounting the database\ndocker run -p 8000:8000 \\\n        -v /absolute/path/to/transaction_db:/database \\\n        --rm kuzudb/explorer:latest\n")),(0,r.kt)("p",null,"You can then see a query editor in your browser at ",(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost:8000"),"."),(0,r.kt)("h3",{id:"verify-schema"},"Verify schema"),(0,r.kt)("p",null,"In the K\xf9zu explorer window on the browser, click on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," tab on the top right."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:l.Z})),(0,r.kt)("p",null,"The above schema is very similar to the one we designed earlier, which is a good sign!"),(0,r.kt)("h3",{id:"visualize-nodes-and-edges"},"Visualize nodes and edges"),(0,r.kt)("p",null,"The following query can be entered to visualize the graph."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (a)-[b]->(c)\nRETURN * LIMIT 50;\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURN *")," keyword passes all the named variables in the query to the visualization engine which\nthen renders the graph as follows."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:c.Z})),(0,r.kt)("p",null,"It's possible to customize the visual style of the graph by clicking on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Settings")," tab on the top right."),(0,r.kt)("h2",{id:"conclusions"},"Conclusions"),(0,r.kt)("p",null,"The aim of this blog post is to show how to transform data that might exist in a typical relational\nsystem to a graph and load it into a K\xf9zu database. We also show how to visualize the graph and\nrun some simple queries to test our data model."),(0,r.kt)("p",null,"What's important to take away from this exercise is that using a graph database like K\xf9zu for the\nkinds of queries we ran above makes a ",(0,r.kt)("strong",{parentName:"p"},"lot")," of sense. The raw transaction data that may have been\nsitting in an RDBMS system wasn't simple to reason about when it came to answering questions\nabout connected entities. Doing so in SQL would have required multiple joins and subqueries, whereas\nthe Cypher queries we wrote were more intuitive and easier to read. That being said, not ",(0,r.kt)("em",{parentName:"p"},"all")," kinds of queries\nbenefit from a graph data model, and there are many cases where SQL and RDBMS are right tools for the job."),(0,r.kt)("p",null,"Another key takeaway is that designing a graph data model is an\n",(0,r.kt)("em",{parentName:"p"},"iterative")," exercise. You may not get it right the first time, and that's okay! The key is to have\na good understanding of the data and the questions you want to answer, and to keep refining the\nmodel as you learn more about the data. Using an embeddable solution like K\xf9zu is really helpful\nin this regard, as you can quickly load the data and test your queries without having to worry\nabout setting up servers or authentication."),(0,r.kt)("p",null,"In the next post, we'll look at a larger dataset of a similar nature, to answer more complex\nquestions about disputed transactions. In the meantime, give ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/kuzu"},"K\xf9zu"),"\na try out on your own data, and begin thinking about whether knowledge graphs are a good fit for\nyour use case!"),(0,r.kt)("h2",{id:"code"},"Code"),(0,r.kt)("p",null,"All code for this post can be found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/graphdb-demo/tree/main/src/python/transactions"},"graphdb-demo")," repository."),(0,r.kt)("h2",{id:"further-reading"},"Further reading"),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1-105625"},(0,r.kt)("em",{parentName:"li"},"The Practitioners Guide to Graph Data"),",\n",(0,r.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/the-practitioners-guide/9781492044062/ch01.html#ch1"},"Ch. 1"),".\nBy Denise Gosnell & Matthias Broecheler, O'Reilly Media, Inc., 2020.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1-105625",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2-105625"},(0,r.kt)("em",{parentName:"li"},"Graph Powered Machine Learning"),",\n",(0,r.kt)("a",{parentName:"li",href:"https://livebook.manning.com/concept/graphs/transaction"},"Ch. 2"),", By Alessandro Negro, Manning\nPublications, 2021.",(0,r.kt)("a",{parentName:"li",href:"#fnref-2-105625",className:"footnote-backref"},"\u21a9")))))}y.isMDXComponent=!0},6624:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/edge_tables-2c45d07c46ffcb668b37cf3549be1cd5.png"},3036:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/graph_schema-0fd223f531931459a7c510f4557a563c.png"},3249:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/graph_viz-c60896920413f5185e52915d23fbd2a4.png"},3826:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/kuzu_schema_viz-00e4b0901dfb1554052663e47fabf219.png"},6151:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/relational_schema-b9e2c8514503c17a0990490673bc9968.png"}}]);