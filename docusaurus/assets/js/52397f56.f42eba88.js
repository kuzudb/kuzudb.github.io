"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[502],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),c=o,m=u["".concat(s,".").concat(c)]||u[c]||h[c]||r;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8338:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const r={title:"Data Definition",sidebar_position:2},i="Defining A Graph Schema: Data Definition Language",l={unversionedId:"cypher/ddl",id:"cypher/ddl",title:"Data Definition",description:'As a first step to creating your database, you need to define your node and directed relationships. In the property graph model, nodes and relationships have labels. In K\xf9zu, every node or relationship can have 1 label. The node and relationships and the predefined properties on them are defined through CREATE NODE TABLE and CREATE REL TABLE commands. The choice of using the term "table" over "label" is intentional and explained below.',source:"@site/docs/cypher/ddl.md",sourceDirName:"cypher",slug:"/cypher/ddl",permalink:"/docusaurus/cypher/ddl",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Data Definition",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Union Functions",permalink:"/docusaurus/cypher/expressions/union-functions"},next:{title:"Query Clauses",permalink:"/docusaurus/category/query-clauses"}},s={},d=[{value:"Defining Node Tables",id:"defining-node-tables",level:2},{value:"Defining Relationship Tables",id:"defining-relationship-tables",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Relationship Multiplicities",id:"relationship-multiplicities",level:3},{value:"DROP TABLE",id:"drop-table",level:2},{value:"ALTER TABLE",id:"alter-table",level:2},{value:"1. Add a column:",id:"1-add-a-column",level:3},{value:"2. Drop a column:",id:"2-drop-a-column",level:3},{value:"3. Rename a node/rel table:",id:"3-rename-a-noderel-table",level:3},{value:"4. Rename a column of a node/rel table:",id:"4-rename-a-column-of-a-noderel-table",level:3}],p={toc:d},u="wrapper";function h(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"defining-a-graph-schema-data-definition-language"},"Defining A Graph Schema: Data Definition Language"),(0,o.kt)("p",null,"As a first step to creating your database, you need to define your node and directed relationships. In the property graph model, nodes and relationships have labels. In K\xf9zu, every node or relationship can have 1 label. The node and relationships and the predefined properties on them are defined through ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE NODE TABLE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE REL TABLE"),' commands. The choice of using the term "table" over "label" is intentional and explained below',(0,o.kt)("sup",{parentName:"p",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"."),(0,o.kt)("h2",{id:"defining-node-tables"},"Defining Node Tables"),(0,o.kt)("p",null,"For example, the following statement defines a table of User nodes. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"CREATE NODE TABLE User(name STRING, age INT64, reg_date DATE, PRIMARY KEY (name))\n")),(0,o.kt)("p",null,"This adds a User table to the catalog of the system with 3 predefined properties. During querying, the name of the table will serve as the label of the nodes, e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"MATCH (a:User) RETURN sum(a.age)")," returns the sum of the ages of all User nodes in the system. "),(0,o.kt)("p",null,"K\xf9zu requires a primary key column for node table which can be either a ",(0,o.kt)("inlineCode",{parentName:"p"},"STRING")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"INT64")," property of the node. K\xf9zu will generate an index to do quick lookups on the primary key (e.g., name in the above example). Alternativly, you can use ",(0,o.kt)("a",{parentName:"p",href:"/docusaurus/cypher/data-types/serial"},(0,o.kt)("inlineCode",{parentName:"a"},"SERIAL")," data type")," to generate an auto-increment column as primary key."),(0,o.kt)("h2",{id:"defining-relationship-tables"},"Defining Relationship Tables"),(0,o.kt)("p",null,"Here are some examples of defining tables of relationships."),(0,o.kt)("h3",{id:"basic-usage"},"Basic Usage"),(0,o.kt)("p",null,"The following adds to the catalog a Follows relationship table between User and User nodes with one date property. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"CREATE REL TABLE Follows(FROM User TO User, since DATE)\n")),(0,o.kt)("p",null,"There are several things to note:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Note that there is no comma between the FROM and TO clauses. "),(0,o.kt)("li",{parentName:"ul"},"Relationship directions: Each relationship has a direction following the property graph model. So when Follows relationship records are added, each one has a specific source/from node and a specific destination/to node",(0,o.kt)("sup",{parentName:"li",id:"fnref-2"},(0,o.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"."),(0,o.kt)("li",{parentName:"ul"},'Relationship primary keys: You cannot define a primary key for relationship records. Each relationship gets a unique system-level edge ID, which are internally generated. You can check if two edges are the same, i.e., have the same edge ID, using the "=" and "!=" operator between "ID()" function on two variables that bind to relationships. For example, you can query ',(0,o.kt)("inlineCode",{parentName:"li"},"MATCH (n1:User)-[r1:Follows]->(n2:User)<-[r2:Follows]-(n3:User) WHERE ID(r1) != ID(r2) RETURN *")," to ensure that the same relationship does not bind to both r1 and r2."),(0,o.kt)("li",{parentName:"ul"},"Relationship can only be defined as being from one node table/label to one node table/label.")),(0,o.kt)("h3",{id:"relationship-multiplicities"},"Relationship Multiplicities"),(0,o.kt)("p",null,"For any relationship label E, e.g., , by default there can be multiple relationships from any node v both in the forward and backward direction. In database terminology, relationships are by default many-to-many. For example in the first Follows example above: (i) any User node v can follow multiple User nodes; and (ii) be followed by multiple User nodes. You can also constrain the multiplicity to ",(0,o.kt)("em",{parentName:"p"},"at most 1")," (we don't yet support exactly 1 semantics as in foreign key constraints in relational systems)  in either direction. You can restrict the multiplicities for two reasons: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Constraint: Multiplicities can serve as constraints you would like to enforce (e..g, you want K\xf9zu to error if an application tries to add a second relationship of a particular label to some node)"),(0,o.kt)("li",{parentName:"ol"},"Performance: K\xf9zu can store 1-to-1, many-to-1, or 1-to-many relationships (explained momentarily) in more efficient/compressed format, which is also faster to scan. ")),(0,o.kt)("p",null,"You can optionally declare the multiplicity of relationships by adding MANY_MANY, ONE_MANY, MANY_ONE, or ONE_ONE clauses to the end of the CREATE REL TABLE command.\nHere are a few  example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"CREATE REL TABLE LivesIn(FROM User TO City, MANY_ONE)\n")),(0,o.kt)("p",null,'The above ddl indicates that LivesIn has n-1 multiplicity. This command puts an additional constraint that each User node v might LiveIn at most 1 City node (assuming our database has City nodes). It does not put any constraint in the "backward" direction, i.e., there can be multiple Users living in the same City. As another example to explain the semantics of multiplicity constraints in the presence of multiple node labels, consider this: '),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"CREATE REL TABLE Likes(FROM Pet TO User, ONE_MANY)\n")),(0,o.kt)("p",null,"The above ddl indicates that Likes has 1-to-n multiplicity. This ddl command puts the constraint: that each User node v might be Liked by one Pet node. It does not put any constraint in the forward direction, i.e., each Pet node might know multiple Users."),(0,o.kt)("p",null,'In general in a relationship E\'s multiplicity, if the "source side" is "ONE", then for each node v that can be the destination of E relationships, v can have at most 1 backward edge. If the "destination side" is ONE, then each node v that can be the source of E relationships, v can have at most 1 forward edge. '),(0,o.kt)("h2",{id:"drop-table"},"DROP TABLE"),(0,o.kt)("p",null,"You can drop tables from the database with the ",(0,o.kt)("inlineCode",{parentName:"p"},"DROP TABLE")," command.",(0,o.kt)("br",null),"\nTwo important notes:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"To drop a node table X, you need to first drop all of the relationship tables\nthat refer to X in its FROM or TO first."),(0,o.kt)("li",{parentName:"ol"},"You can drop any relationship table at any time.")),(0,o.kt)("p",null,"For example if you have a database with User and Follows tables defined as above and you\ntried to drop User without dropping Follows first, K\xf9zu will error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"DROP TABLE User\nError: Binder exception: Cannot delete a node table with edges. It is on the edges of rel: Follows.\n")),(0,o.kt)("p",null,"But you can first delete Follows and the User as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"DROP TABLE Follows\n---------------------------------------\n| RelTable: Follows has been dropped. |\n---------------------------------------\nDROP TABLE User\n-------------------------------------\n| NodeTable: User has been dropped. |\n-------------------------------------\n")),(0,o.kt)("h2",{id:"alter-table"},"ALTER TABLE"),(0,o.kt)("p",null,"You can change the schema of a table using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ALTER TABLE")," command.",(0,o.kt)("br",null)),(0,o.kt)("h3",{id:"1-add-a-column"},"1. Add a column:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ADD COLUMN")," allows you to add a new column to a node/rel table.\nBy default, if you don't specify a default value, the newly added column is filled with NULLs."),(0,o.kt)("p",null,"Note: column names must be unique within a node/rel table. If the column name has already been used in the table, ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD COLUMN")," command will fail.",(0,o.kt)("br",null),"\nFor example: the following query will fail since the age column already exists in the User table."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ALTER TABLE User ADD age INT64;\n")),(0,o.kt)("p",null,"Will throw the error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"Binder exception: Property: age already exists."\n')),(0,o.kt)("p",null,"Examples:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ALTER TABLE User ADD grade INT64;\n")),(0,o.kt)("p",null,"This adds a new column with the default value NULL to the User table."),(0,o.kt)("p",null,"The user can also define the default value of the new column."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ALTER TABLE User ADD grade INT64 DEFAULT 40;\n")),(0,o.kt)("p",null,"This adds a new column grade with default value 40 to the User table."),(0,o.kt)("h3",{id:"2-drop-a-column"},"2. Drop a column:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DROP COLUMN")," allows you to remove a column from a node/rel table.",(0,o.kt)("br",null)),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ALTER TABLE User DROP age;\n")),(0,o.kt)("p",null,"This drops the age column from the User table."),(0,o.kt)("h3",{id:"3-rename-a-noderel-table"},"3. Rename a node/rel table:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"RENAME TABLE")," allows the user to rename a table.",(0,o.kt)("br",null),"\nNote: table name must be unique. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ALTER TABLE User RENAME TO Student;\n")),(0,o.kt)("p",null,"This renames the table User to Student."),(0,o.kt)("h3",{id:"4-rename-a-column-of-a-noderel-table"},"4. Rename a column of a node/rel table:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"RENAME COLUMN")," allows the user to rename a column of a table.",(0,o.kt)("br",null),"\nNote: column name must be unique within a node/rel table. Different node/rel tables can have columns with the same name."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ALTER TABLE User RENAME age TO grade;\n")),(0,o.kt)("p",null,"This renames the age column to grade."),(0,o.kt)("div",{className:"footnotes"},(0,o.kt)("hr",{parentName:"div"}),(0,o.kt)("ol",{parentName:"div"},(0,o.kt)("li",{parentName:"ol",id:"fn-1"},'We prefer the term "table" instead of "label" because K\xf9zu, as well as other GDBMSs are ultimately relational systems in the sense that they store and process sets of tuples, i.e., tables or relations. A good way to understand the property graph model is as tagging your tables as "node" and "relationship tables" depending on their roles in your application data. Nodes are generally suitable to represent entities in your applications, while relationships represent the relationships/connections. Relationships are the primary means to join nodes with each other to find paths and patterns in your graph database. So when you define a node label and a set of nodes/relationships, this is equivalent to defining a table or records as nodes or relationships. During querying you can bind node records in syntax like (a:Person), while relationships in syntax like (..)-',"[e:Knows]","->(...). Similar to table definitions in SQL, node and relationship tables have primary keys, a term that is defined in the context of tables: node tables explicitly define primary keys as one of their properties, while the primary keys of relationship tables are implicitly defined by the primary keys of their FROM and TO node records. Further observe that similar to relational systems, properties can be thought equivalently as columns of a table, justifying our choice of using the term table in these definitions.",(0,o.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,o.kt)("li",{parentName:"ol",id:"fn-2"},"We have currently not decided if K\xf9zu will support undirected edges or support it in a way similar to Neo4j, which always forces directed edges but allow querying in an undirected way. See ",(0,o.kt)("a",{parentName:"li",href:"https://neo4j.com/docs/cypher-manual/current/introduction/uniqueness/"},"examples here"),' for the details how Neo4j supports "undirected querying", which matches edges from both directions.',(0,o.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}h.isMDXComponent=!0}}]);