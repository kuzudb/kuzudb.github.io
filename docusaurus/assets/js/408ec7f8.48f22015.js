"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[1060],{3905:(t,e,a)=>{a.d(e,{Zo:()=>d,kt:()=>c});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var p=n.createContext({}),u=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},d=function(t){var e=u(t.components);return n.createElement(p.Provider,{value:e},t.children)},s="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),s=u(a),k=r,c=s["".concat(p,".").concat(k)]||s[k]||m[k]||l;return a?n.createElement(c,i(i({ref:e},d),{},{components:a})):n.createElement(c,i({ref:e},d))}));function c(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=k;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o[s]="string"==typeof t?t:r,i[1]=o;for(var u=2;u<l;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},8207:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const l={title:"Variant",sidebar_position:14},i=void 0,o={unversionedId:"cypher/data-types/variant",id:"cypher/data-types/variant",title:"Variant",description:"Variant is a data type that can store values of various data types (similar to the sql_variant data type of SQLServer).",source:"@site/docs/cypher/data-types/variant.md",sourceDirName:"cypher/data-types",slug:"/cypher/data-types/variant",permalink:"/docusaurus/cypher/data-types/variant",draft:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{title:"Variant",sidebar_position:14},sidebar:"docSidebar",previous:{title:"Union",permalink:"/docusaurus/cypher/data-types/union"},next:{title:"UUID",permalink:"/docusaurus/cypher/data-types/uuid"}},p={},u=[{value:"K\xf9zu Data Types that can be Stored in a Variant Column",id:"k\xf9zu-data-types-that-can-be-stored-in-a-variant-column",level:2},{value:"Supported Data Types When Loading From Turtle Files",id:"supported-data-types-when-loading-from-turtle-files",level:2},{value:"Parsing RDF Literals from Turtle Files",id:"parsing-rdf-literals-from-turtle-files",level:2}],d={toc:u},s="wrapper";function m(t){let{components:e,...a}=t;return(0,r.kt)(s,(0,n.Z)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Variant is a data type that can store values of various data types (similar to the sql_variant data type of SQLServer).\nCurrently it can only be used to store ",(0,r.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal"},"RDF literals")," in ",(0,r.kt)("a",{parentName:"p",href:"../../rdf-graphs"},"RDFGraphs"),".\nThat is, you cannot create a regular node or relationship table that holds a column of type VARIANT.\nWhen working with RDFGraphs, the ",(0,r.kt)("a",{parentName:"p",href:"../../rdf-graphs/rdfgraphs-overview#rdfgraphs-mapping-of-triples-to-property-graph-tables"},"Literals node table"),"'s\n",(0,r.kt)("inlineCode",{parentName:"p"},"val")," column stores RDF literal values. RDF literals, and K\xf9zu's Variant data type can store values of different data types.\nFor example, consider the following triples in a Turtle file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'@prefix kz: <http://kuzu.io/rdf-ex#> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n\nkz:Waterloo a kz:City ;\n        kz:name "Waterloo" ;\n        kz:population 10000 ;\n        kz:altitude1 "329.0"^^xsd:decimal .\n')),(0,r.kt)("p",null,"Suppose that you insert these into an RDFGraph named ",(0,r.kt)("inlineCode",{parentName:"p"},"UniKG"),". You will get the following values in the ",(0,r.kt)("inlineCode",{parentName:"p"},"val")," column\nof the Literals node table ",(0,r.kt)("inlineCode",{parentName:"p"},"UniKG_l"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:UniKG_r)-[p:UniKG_lt]->(o:UniKG_l \nRETURN a.iri, p.iri, o.val;\n-------------------------------------------------------------------------------------------------\n| a.iri                          | p.iri                                           | o.val      |\n-------------------------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#altitude1                 | 329.000000 |\n-------------------------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#population                | 10000      |\n-------------------------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#name                      | Waterloo   |\n-------------------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"In the output above the data types of the values in ",(0,r.kt)("inlineCode",{parentName:"p"},"o.val")," are as follows (data types are not rendered in K\xf9zu cli's output)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"329.000000 is a double"),(0,r.kt)("li",{parentName:"ul"},"10000 is an integer"),(0,r.kt)("li",{parentName:"ul"},'"Waterloo" is a string')),(0,r.kt)("p",null,"These different types are stored under the same column ",(0,r.kt)("inlineCode",{parentName:"p"},"val")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Literals")," node table."),(0,r.kt)("h2",{id:"k\xf9zu-data-types-that-can-be-stored-in-a-variant-column"},"K\xf9zu Data Types that can be Stored in a Variant Column"),(0,r.kt)("p",null,"The following K\xf9zu data types can be stored in a Variant column. You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," function to cast a value to a\nspecific data type before storing it in a Variant column (as will be demonstrated in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE")," statement\nexamples momentarily)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"K\xf9zu Data Type"),(0,r.kt)("th",{parentName:"tr",align:null},"CAST Function Example"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT8"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "INT8")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT16"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "INT16")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT32"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "INT32")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT64"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "INT64")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UINT8"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "UINT8")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UINT16"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "UINT16")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UINT32"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "UINT32")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UINT64"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(2, "UINT64")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(4.4, "DOUBLE")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FLOAT"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(4.4, "FLOAT")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BLOB"),(0,r.kt)("td",{parentName:"tr",align:null},'cast("',"\\",'xB2", "BLOB")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,r.kt)("td",{parentName:"tr",align:null},'cast("true", "BOOL")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"STRING"),(0,r.kt)("td",{parentName:"tr",align:null},'cast(123, "STRING")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DATE"),(0,r.kt)("td",{parentName:"tr",align:null},'cast("2024-01-01", "DATE")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TIMESTAMP"),(0,r.kt)("td",{parentName:"tr",align:null},'cast("2024-01-01 11:25:30Z+00:00", "TIMESTAMP")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INTERVAL"),(0,r.kt)("td",{parentName:"tr",align:null},'cast("1 year", "INTERVAL")')))),(0,r.kt)("p",null,"For example, the below code adds new triples into an RDFGraph with type date and float, respectively:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'CREATE (a:UniKG_r {iri:"http://kuzu.io/rdf-ex#foo"})-[p:UniKG_lt {iri:"http://kuzu.io/rdf-ex#datepredicate"}]->(o:UniKG_l {val:cast("2024-01-01", "DATE")});\nCREATE (a:UniKG_r {iri:"http://kuzu.io/rdf-ex#foo"})-[p:UniKG_lt {iri:"http://kuzu.io/rdf-ex#doublepredicate"}]->(o:UniKG_l {val:4.4});\n')),(0,r.kt)("p",null,'Above, DATE type needs to be cast explicitly as in "cast("2024-01-01", "DATE")" while 4.4, which is of type DOUBLE,\ncan be provided as is. This is because DATE is not an automatically inferred data type. The above two CREATE statements will create\nthe following two triples:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#foo | http://kuzu.io/rdf-ex#doublepredicate | 4.400000   |\n----------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#foo | http://kuzu.io/rdf-ex#datepredicate   | 2024-01-01 |\n----------------------------------------------------------------------------------\n")),(0,r.kt)("h2",{id:"supported-data-types-when-loading-from-turtle-files"},"Supported Data Types When Loading From Turtle Files"),(0,r.kt)("p",null,"Although we can store any of the above data types in a Variant column through CREATE statements,\nwhen loading from a Turtle file, currently only a subset of these data types are supported.\nThe data types that can be loaded from Turtle files along with their XML Schema Definition (XSD) tags are as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"K\xf9zu Data Type"),(0,r.kt)("th",{parentName:"tr",align:null},"XSD Tag"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INT64"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:integer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UINT64"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:nonNegativeInteger")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UINT64"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:positiveInteger")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FLOAT"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:float")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:double")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DOUBLE"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:decimal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:boolean")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DATE"),(0,r.kt)("td",{parentName:"tr",align:null},"xsd:date")))),(0,r.kt)("p",null,"By default any literal that is not tagged explicitly with the above XSD tags will be stored as a K\xf9zu STRING data type."),(0,r.kt)("h2",{id:"parsing-rdf-literals-from-turtle-files"},"Parsing RDF Literals from Turtle Files"),(0,r.kt)("p",null,"When parsing RDF literals from Turtle files, if you explicitly\ntype your literals with an XSD tag, then those will be the data types. In other cases,\nK\xf9zu will try to infer the data types. Consider the below Turtle file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'@prefix kz: <http://kuzu.io/rdf-ex#> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n\nkz:Waterloo a kz:City ;\n        kz:population 10000 ;\n        kz:altitude1 329.0 ;\n        kz:altitude2 "329.0"^^xsd:decimal ;\n        kz:altitude3 "329.0" .\n')),(0,r.kt)("p",null,"This will result in the following triples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------------------\n| a.iri                          | p.iri                            | o.val      |\n----------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#population | 10000      |\n----------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#altitude1  | 329.000000 |\n----------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#altitude2  | 329.000000 |\n----------------------------------------------------------------------------------\n| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#altitude3  | 329.0      |\n----------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"The data types above are as follows (again data types are not rendered in K\xf9zu cli's output):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"10000 is an INT64 (automatically inferred)"),(0,r.kt)("li",{parentName:"ul"},"329.000000 (for altitude1 and altitude2) are DOUBLE. Note that altitude1 is automatically inferred, while altitude2 is explicitly typed with an xsd tag."),(0,r.kt)("li",{parentName:"ul"},"329.0 (for altitude3) is a STRING (automatically inferred)")))}m.isMDXComponent=!0}}]);