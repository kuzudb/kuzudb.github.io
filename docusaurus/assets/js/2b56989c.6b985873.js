"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[6798],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(a),c=r,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},8270:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={slug:"kuzu-0.0.7-release",authors:["team"],tags:["release"]},l="K\xf9zu 0.0.7 Release",o={permalink:"/docusaurus/blog/kuzu-0.0.7-release",source:"@site/blog/2023-08-16-kuzu-v-0.0.7.md",title:"K\xf9zu 0.0.7 Release",description:"We are very happy to release K\xf9zu 0.0.7 today! This release comes with the following new main features and improvements:",date:"2023-08-16T00:00:00.000Z",formattedDate:"August 16, 2023",tags:[{label:"release",permalink:"/docusaurus/blog/tags/release"}],readingTime:7.54,hasTruncateMarker:!0,authors:[{name:"K\xf9zu Team",url:"https://github.com/kuzudb/",imageURL:"https://kuzudb.com/img/blog/team.jpg",key:"team"}],frontMatter:{slug:"kuzu-0.0.7-release",authors:["team"],tags:["release"]},nextItem:{title:"IAMGraphViz: Visualizing AWS IAM Permissions with K\xf9zu",permalink:"/docusaurus/blog/iamgraphviz"}},s={authorsImageUrls:[void 0]},p=[{value:"Macro and UDF",id:"macro-and-udf",level:2},{value:"Create Macro Statements",id:"create-macro-statements",level:3},{value:"C++ UDFs",id:"c-udfs",level:3},{value:"Data Update and Return Clauses",id:"data-update-and-return-clauses",level:2},{value:"Merge Clause",id:"merge-clause",level:3},{value:"Multi-label Set/Delete",id:"multi-label-setdelete",level:3},{value:"Return After Update",id:"return-after-update",level:3},{value:"Return with .*",id:"return-with-",level:3},{value:"Data Export",id:"data-export",level:2},{value:"New Data Types and APIs",id:"new-data-types-and-apis",level:2},{value:"MAP",id:"map",level:3},{value:"UNION",id:"union",level:3},{value:"Converting Query Results to Arrow",id:"converting-query-results-to-arrow",level:3},{value:"NodeGroup Based Node Table Storage",id:"nodegroup-based-node-table-storage",level:2},{value:"Unnesting Arbitrary Subqueries",id:"unnesting-arbitrary-subqueries",level:2}],u={toc:p},d="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"We are very happy to release K\xf9zu 0.0.7 today! This release comes with the following new main features and improvements: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#macro-and-udf"},"Macro and UDF"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-macro-statements"},"Create Macro Statements")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#c-udfs"},"C++ UDFs")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#data-update-and-return-clauses"},"Data Update and Return Clauses"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#merge-clause"},"Merge Clause")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#multi-label-setdelete"},"Multi-label Set/Delete")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#return-after-update"},"Return After Update")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#return-with-"},"Return with .","*")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#data-export"},"Data Export")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#new-data-types-and-apis"},"New Data Types and APIs"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#map"},"MAP")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#union"},"UNION")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#converting-query-results-to-arrow"},"Converting Query Results to Arrow")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#nodegroup-based-node-table-storage"},"NodeGroup Based Node Table Storage")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#unnesting-arbitrary-subqueries"},"Unnesting Arbitrary Subqueries"))),(0,r.kt)("p",null,"For installing the new version,\nplease visit the ",(0,r.kt)("a",{parentName:"p",href:"https://kuzudb.com/#download"},"download section of our website"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"https://kuzudb.com/docusaurus/getting-started/"},"getting started guide"),". The full\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/kuzu/releases"},"release notes are here"),". "),(0,r.kt)("h2",{id:"macro-and-udf"},"Macro and UDF"),(0,r.kt)("h3",{id:"create-macro-statements"},"Create Macro Statements"),(0,r.kt)("p",null,"In this release, we've added the support of ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE MACRO")," statement to define customized scalar functions, i.e., those that return only a single value, through Cypher."),(0,r.kt)("p",null,"Here is an example of defining a macro to add two input parameters.  The second parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"b:3")," is an example of how to provide a default value for a parameter in case the parameter is absent."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Cypher"},"// Create a macro which adds two parameters. If the second parameter b is not provided, the default value of 3 will be used instead.\ncreate macro addWithDefault(a,b:=3) as a + b;\n// Executes the macro without providing the default value.\nreturn addWithDefault(2);  // returns 5 (2 + 3)\n// Executes the macro by providing the default value (actual parameter value will be used).\nreturn addWithDefault(4, 7);  // returns 11 (4 + 7)\n")),(0,r.kt)("p",null,"See more details on supported macro expression types ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/macro"},"here"),"."),(0,r.kt)("h3",{id:"c-udfs"},"C++ UDFs"),(0,r.kt)("p",null,"We are also introducing two C++ interfaces, ",(0,r.kt)("inlineCode",{parentName:"p"},"createScalarFunction")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"createVectorizedFunction")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Connection")," class of the ",(0,r.kt)("a",{parentName:"p",href:"https://kuzudb.com/docusaurus/getting-started/cpp"},"C++ API")," to define both scalar and vectorized ",(0,r.kt)("a",{parentName:"p",href:"./../client-apis/cpp-api/udf"},"UDFs"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createScalarFunction")," provides a way for users to define scalar functions in C++ and use it in K\xf9zu as if they're built-in functions.\nHere is an example of a unary scalar function that increments the input value by 5:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'static int32_t addFiveScalar(int32_t x) {\n    return x + 5;\n}\n// Register the unary scalar function using the createScalarFunction API.\nconn->createScalarFunction("addFiveScalar", &addFiveScalar);\n// Issue a query using the UDF.\nconn->query("MATCH (p:person) return addFiveScalar(to_int32(p.age))");\n')),(0,r.kt)("p",null,"For users familiar with internals of our intermediate result representation, they can make use of ",(0,r.kt)("inlineCode",{parentName:"p"},"createVectorizedFunction")," to create vectorized function over our ValueVectors to achieve better performance.\nSee ",(0,r.kt)("a",{parentName:"p",href:"./../client-apis/cpp-api/udf"},"our doc here")," for more details."),(0,r.kt)("h2",{id:"data-update-and-return-clauses"},"Data Update and Return Clauses"),(0,r.kt)("h3",{id:"merge-clause"},"Merge Clause"),(0,r.kt)("p",null,"This release implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"MERGE")," clause, which is an updating clause that will first try to match the given pattern and, if not found, create the pattern. At a high level, ",(0,r.kt)("inlineCode",{parentName:"p"},"MERGE <pattern>")," can be interpreted as ",(0,r.kt)("inlineCode",{parentName:"p"},"If MATCH <pattern> then RETURN <pattern> ELSE CREATE <pattern>"),".Additionally, one can further specify the ",(0,r.kt)("inlineCode",{parentName:"p"},"SET")," operation based on whether the pattern is found or not through ",(0,r.kt)("inlineCode",{parentName:"p"},"ON CREATE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ON MATCH"),"."),(0,r.kt)("p",null,'For example, the following query tries to merge a user node with name "Adam". Suppose a node with name "Adam" exists in the database already. In this case, we update the same node\'s ',(0,r.kt)("inlineCode",{parentName:"p"},"age")," property and return the node (so no new node gets inserted)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MERGE (n:User {name : 'Adam'}) ON MATCH SET n.age = 35 RETURN n.*;\n------------------\n| n.name | n.age |\n------------------\n| Adam   | 35    |\n------------------\n")),(0,r.kt)("p",null,"Here is another example where we try to merge a ",(0,r.kt)("inlineCode",{parentName:"p"},"Follows")," edge with ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," property equal to 2022 between ",(0,r.kt)("inlineCode",{parentName:"p"},"Adam")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Karissa"),". Suppose no such edge exists in the database, then the statement create the edge and set the ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," property to 1999."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User), (b:User) \nWHERE a.name = 'Adam' AND b.name = 'Karissa' \nMERGE (a)-[e:Follows {since:2022}]->(b) \nON CREATE SET e.since = 1999\nRETURN e;\n---------------------------------------------------------\n| e                                                     |\n---------------------------------------------------------\n| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 1999}->(0:1) |\n---------------------------------------------------------\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/data-manipulation-clauses/merge"},"our doc here")," for more details."),(0,r.kt)("h3",{id:"multi-label-setdelete"},"Multi-label Set/Delete"),(0,r.kt)("p",null,"K\xf9zu now allows set/delete on nodes and relationship variables that can be binding to multiple labels. For example,\nto delete all nodes in database (assuming all edges have been deleted)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (n) DELETE n;\n")),(0,r.kt)("p",null,"Similarly, to set ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," property of all relationships in the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH ()-[f]->() SET f.since = 2023\n")),(0,r.kt)("p",null,"Note that when evaluating this query, tuples in tables that don't have ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," property will be ignored."),(0,r.kt)("p",null,"See our docs in ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/data-manipulation-clauses/set"},"Set")," and ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/data-manipulation-clauses/delete"},"Delete")," for more details."),(0,r.kt)("h3",{id:"return-after-update"},"Return After Update"),(0,r.kt)("p",null,"We are also enabling return after updating clause starting from this release. That is updated value will be returned in queries that update values. Here are some examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (u:User)\nWHERE u.name = 'Adam' SET u.age = NULL\nRETURN u.*;\n------------------\n| u.name | u.age |\n------------------\n| Adam   |       |\n------------------\n\nMATCH (u1:User), (u2:User)\nWHERE u1.name = 'Adam' AND u2.name = 'Noura' \nCREATE (u1)-[e:Follows {since: 2011}]->(u2)\nRETURN e;\n---------------------------------------------------------\n| e                                                     |\n---------------------------------------------------------\n| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 2011}->(0:3) |\n---------------------------------------------------------\n")),(0,r.kt)("p",null,"See our docs in ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/data-manipulation-clauses/set"},"Set")," and ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/data-manipulation-clauses/delete"},"Delete")," for more examples."),(0,r.kt)("h3",{id:"return-with-"},"Return with .*"),(0,r.kt)("p",null,"As a syntactic sugar, K\xf9zu now supports returning all properties of node or rel with *."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User) RETURN a.*;\n-------------------\n| a.name  | a.age |\n-------------------\n| Adam    | 30    |\n-------------------\n| Karissa | 40    |\n-------------------\n| Zhang   | 50    |\n-------------------\n| Noura   | 25    |\n-------------------\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"./../cypher/query-clauses/return#returning-node-and-relationship-properties"},"our doc here")," for more details."),(0,r.kt)("h2",{id:"data-export"},"Data Export"),(0,r.kt)("p",null,"K\xf9zu now supports exporting query results to CSV files using the ",(0,r.kt)("inlineCode",{parentName:"p"},"COPY TO")," command. For example the following\n",(0,r.kt)("inlineCode",{parentName:"p"},"COPY TO")," statement could return the below CSV file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"COPY (MATCH (u:User) RETURN u.*) TO 'user.csv';\n")),(0,r.kt)("p",null,"CSV file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'u.name,u.age\n"Adam",30\n"Karissa",40\n"Zhang",50\n"Noura",25\n')),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"../data-export/"},"Data Export")," for more information."),(0,r.kt)("h2",{id:"new-data-types-and-apis"},"New Data Types and APIs"),(0,r.kt)("h3",{id:"map"},"MAP"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP")," is a dictionary of key-value pairs where all keys have the same type and all values have the same type. Different from ",(0,r.kt)("inlineCode",{parentName:"p"},"STRUCT"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP")," doesn't require the same key to be present in each row. Therefore, ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP")," is more suitable when the schema is not determined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"RETURN map([1, 2], ['a', 'b']) AS m;\n--------------\n| m          |\n--------------\n| {1=a, 2=b} |\n--------------\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"../cypher/data-types/map"},"map")," for more information."),(0,r.kt)("h3",{id:"union"},"UNION"),(0,r.kt)("p",null,"K\xf9zu's ",(0,r.kt)("inlineCode",{parentName:"p"},"UNION")," is implemented by taking DuckDB's ",(0,r.kt)("inlineCode",{parentName:"p"},"UNION")," type as a reference. Similar to C++ ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UNION"),' is a nested data type that is capable of holding multiple alternative values with different types. The value under key "tag" is considered as the value being currently hold by the ',(0,r.kt)("inlineCode",{parentName:"p"},"UNION"),"."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"../cypher/data-types/union"},"union")," for more information."),(0,r.kt)("h3",{id:"converting-query-results-to-arrow"},"Converting Query Results to Arrow"),(0,r.kt)("p",null,"In previous releases, we supported converting query result to Arrow tables in our ",(0,r.kt)("a",{parentName:"p",href:"./../client-apis/python-api/query-result"},"Python API")," (See ",(0,r.kt)("inlineCode",{parentName:"p"},"get_as_arrow"),").\nIn this release, converting to Arrow arrays are now also available in Rust, ",(0,r.kt)("a",{parentName:"p",href:"./../client-apis/c-api/query_result"},"C")," (see ",(0,r.kt)("inlineCode",{parentName:"p"},"kuzu_query_result_get_arrow_schema")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"kuzu_query_result_get_next_arrow_chunk"),"), and ",(0,r.kt)("a",{parentName:"p",href:"./../client-apis/cpp-api/query-result"},"C++")," (see ",(0,r.kt)("inlineCode",{parentName:"p"},"getArrowSchema")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getNextArrowChunk"),") APIs."),(0,r.kt)("h2",{id:"nodegroup-based-node-table-storage"},"NodeGroup Based Node Table Storage"),(0,r.kt)("p",null,"This release introduces changes the storage layout of node tables.\nBefore this release, we used to store each column in a node table contiguously in separate files.\nEach column contains one data file (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"n-1.col"),") and one null file (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"n-1.null"),") if the column may contain null values.\nThis design posed two problems: 1) it requires maintaining many files in the database directory, which may lead to ",(0,r.kt)("inlineCode",{parentName:"p"},"too many open files")," error; 2) it is not suitable for data compression. Although we still don't implement compression yet (this will wait until the next few releases), this design would force us to adopt a single compression technique for the entire column. "),(0,r.kt)("p",null,"Instead, partitioning each column into multiple chunks can offer more flexibility as each column chunk can be compressed and decompressed independently.\nIn this release, we introduced the concept ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/kuzu/issues/1474"},"NodeGroup"),", which is equivalent to ",(0,r.kt)("a",{parentName:"p",href:"https://parquet.apache.org/docs/concepts/"},"RowGroup")," and represents a horizontal partition of a table.",(0,r.kt)("sup",{parentName:"p",id:"fnref-1-9f2652"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1-9f2652",className:"footnote-ref"},"1")),"\nWith node group-based storage design, we also store data of all columns in a single file ",(0,r.kt)("inlineCode",{parentName:"p"},"data.kz"),".",(0,r.kt)("sup",{parentName:"p",id:"fnref-2-9f2652"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2-9f2652",className:"footnote-ref"},"2")),"\nThis will enable more powerful compression schemes, e.g., constant compression, bit-packing, dictionary compression in the coming releases.\nFor details on our new design, please visit ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/kuzu/issues/1474"},"this issue"),"."),(0,r.kt)("h2",{id:"unnesting-arbitrary-subqueries"},"Unnesting Arbitrary Subqueries"),(0,r.kt)("p",null,"Consider the following query that finds the name of users ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," who have at least 1 user ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," who is younger than ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User) \nWHERE EXISTS { MATCH (a)-[:Follows]->(b:User) WHERE a.age > b.age} \nRETURN a.name;\n")),(0,r.kt)("p",null,"The query inside ",(0,r.kt)("inlineCode",{parentName:"p"},"EXISTS")," is a correlated subquery and very expensive to evaluate because the inner subquery needs to be evaluated for each ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," with a nested loop join operator (which is often an inefficient way to evaluate joins). In this release, we implemented an optimization that unnests correlated subqueries based on the techniques adopted from this paper ",(0,r.kt)("a",{parentName:"p",href:"https://cs.emis.de/LNI/Proceedings/Proceedings241/383.pdf"},"Unnesting Arbitrary Queries")," by Neumann and Kemper. This allows us to use hash joins instead of nested loop joins and execute these queries much faster. More details will come in a separate blog post on both this technique and how much gains we obtain."),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1-9f2652"},"We use the term NodeGroup mainly due to that we also partition rel tables based on their src/dst nodes, instead of number of rows.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1-9f2652",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2-9f2652"},"Primary key index files are still kept separately, but eventually they will also be merged into the ",(0,r.kt)("inlineCode",{parentName:"li"},"data.kz")," file.",(0,r.kt)("a",{parentName:"li",href:"#fnref-2-9f2652",className:"footnote-backref"},"\u21a9")))))}m.isMDXComponent=!0}}]);