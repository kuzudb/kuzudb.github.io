"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[6805],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),u=r,m=p["".concat(l,".").concat(u)]||p[u]||h[u]||s;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1298:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>h,default:()=>f,frontMatter:()=>p,metadata:()=>u,toc:()=>g});var a=n(7462),r=(n(7294),n(3905)),s=n(4123),i=n(817),o=n(1821),l=n(401),c=n(826),d=n(9349);const p={slug:"transforming-your-data-to-graphs-2",authors:["prashanth"],tags:["use-case"]},h="Transforming your data to graphs - Part 2",u={permalink:"/docusaurus/blog/transforming-your-data-to-graphs-2",source:"@site/blog/2024-02-23-transforming-your-data-2/index.md",title:"Transforming your data to graphs - Part 2",description:"In the previous post, we showed how to transform a",date:"2024-02-23T00:00:00.000Z",formattedDate:"February 23, 2024",tags:[{label:"use-case",permalink:"/docusaurus/blog/tags/use-case"}],readingTime:12.025,hasTruncateMarker:!0,authors:[{name:"Prashanth Rao",title:"AI Engineer at K\xf9zu Inc.",url:"https://github.com/prrao87",imageURL:"https://kuzudb.com/img/blog/prashanth.png",key:"prashanth"}],frontMatter:{slug:"transforming-your-data-to-graphs-2",authors:["prashanth"],tags:["use-case"]},nextItem:{title:"K\xf9zu 0.2.0 Release",permalink:"/docusaurus/blog/kuzu-0.2.0-release"}},m={authorsImageUrls:[void 0]},g=[{value:"Analyzing a transaction network",id:"analyzing-a-transaction-network",level:2},{value:"Relational schema",id:"relational-schema",level:3},{value:"Graph schema",id:"graph-schema",level:3},{value:"Inserting data into K\xf9zu",id:"inserting-data-into-k\xf9zu",level:2},{value:"Exploratory data analysis",id:"exploratory-data-analysis",level:2},{value:"Study disputed transactions",id:"study-disputed-transactions",level:2},{value:"Graph algorithms",id:"graph-algorithms",level:2},{value:"Weakly connected components",id:"weakly-connected-components",level:3},{value:"Closeness centrality",id:"closeness-centrality",level:3},{value:"Conclusions",id:"conclusions",level:2},{value:"Code",id:"code",level:2},{value:"Further reading",id:"further-reading",level:2}],k={toc:g},y="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(y,(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/blog/transforming-your-data-to-graphs-1"},"previous post"),", we showed how to transform a\ntypical relational data model to a graph data model and load it into a K\xf9zu database that could\nthen be queried via Cypher to answer path-related questions about the data. The aim of this post is\nto show how K\xf9zu offers numerous tools that allow users to\nflexibly model and analyze data. We will analyze a transaction network, and\nuse a combination of Cypher queries, graph visualization and network analysis to answer questions\nabout the data."),(0,r.kt)("admonition",{title:"Code",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The code to reproduce the workflow shown in this post can be found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/graphdb-demo/tree/main/src/python/transactions_with_disputes"},"graphdb-demo")," repository.\nIt uses K\xf9zu's Python API, but you are welcome to use the client API ",(0,r.kt)("a",{parentName:"p",href:"https://kuzudb.com/docusaurus/client-apis"},"of your choice"),".")),(0,r.kt)("h2",{id:"analyzing-a-transaction-network"},"Analyzing a transaction network"),(0,r.kt)("p",null,"The dataset used in this post extends from the one used in the previous post and is an example of a network\nof clients, merchants and their transactions. It's inspired by a similar dataset used in the book\n",(0,r.kt)("em",{parentName:"p"},"Graph Powered Machine Learning"),(0,r.kt)("sup",{parentName:"p",id:"fnref-1-4945b3"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1-4945b3",className:"footnote-ref"},"1")),"."),(0,r.kt)("p",null,"In the real world, especially when credit card transactions are involved, it's all\ntoo common to see cases of fraud. Certain transactions can be disputed\nby clients who have cause to believe that a transaction was unauthorized or fraudulent. In such cases,\nthe client marks a transaction as disputed."),(0,r.kt)("h3",{id:"relational-schema"},"Relational schema"),(0,r.kt)("p",null,"Imagine that you are an analyst tasked with investigating such a dataset. The most likely source of\nsuch a dataset would be a relational system, with a schema that looks something like this:"),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:s.Z})),(0,r.kt)("p",null,"The primary table of interest is the ",(0,r.kt)("inlineCode",{parentName:"p"},"transactions")," table, which contains records of all the\ntransactions made by a client with a particular merchant. A merchant is a store or a business that\nprovides goods or services. The ",(0,r.kt)("inlineCode",{parentName:"p"},"disputes")," table contains records of all the disputed transactions,\nmarked after the fact and stored in a separate table."),(0,r.kt)("p",null,"When considering questions about disputed transactions, aggregation queries are not enough. We need\nto study the paths between the clients, merchants and transactions. This is where a graph\ndatabase like K\xf9zu is very handy. The data model used by K\xf9zu is a ",(0,r.kt)("em",{parentName:"p"},"structured")," property graph model,\nallowing us to capture the relationships between entities in a more natural way, for specific query\nworkloads such as this one."),(0,r.kt)("h3",{id:"graph-schema"},"Graph schema"),(0,r.kt)("p",null,"The following graph schema makes sense for our dataset:"),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:i.Z})),(0,r.kt)("p",null,"The transactions are modelled as edges, with an ",(0,r.kt)("inlineCode",{parentName:"p"},"is_disputed")," property to indicate whether\na transaction is disputed or not. This simplifies the kinds of queries we need to write, and is\nsufficient for our initial analysis."),(0,r.kt)("h2",{id:"inserting-data-into-k\xf9zu"},"Inserting data into K\xf9zu"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/blog/transforming-your-data-to-graphs-1"},"previous post")," went into the data transformation\nand ETL aspects, so we won't go over that here. In a nutshell, the following input files exist in CSV\nformat that need to be inserted into K\xf9zu:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},".\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 node\n\u2502   \u2502   \u251c\u2500\u2500 client.csv\n\u2502   \u2502   \u251c\u2500\u2500 city.csv\n\u2502   \u2502   \u251c\u2500\u2500 company.csv\n\u2502   \u2502   \u251c\u2500\u2500 merchant.csv\n\u2502   \u2502   \u2514\u2500\u2500 disputed_transactions.csv\n\u2502   \u2514\u2500\u2500 rel\n\u2502       \u251c\u2500\u2500 belongs_to.csv\n\u2502       \u251c\u2500\u2500 located_in.csv\n\u2502       \u2514\u2500\u2500 transacted_with.csv\n\u2514\u2500\u2500 load_data.py\n")),(0,r.kt)("p",null,"The script ",(0,r.kt)("inlineCode",{parentName:"p"},"load_data.py")," reads the CSV files and inserts the data into K\xf9zu using the Python API.\nThe result of running this script is a graph whose schema matches that shown in the sketch\nabove."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:o.Z})),(0,r.kt)("h2",{id:"exploratory-data-analysis"},"Exploratory data analysis"),(0,r.kt)("p",null,"Once the data is loaded into K\xf9zu, it's very simple to begin exploring the data using Cypher queries\nin one of three ways: i) using a K\xf9zu CLI shell, ii) using a Jupyter notebook, and iii) using the\nK\xf9zu Explorer UI. Because the goal of this exercise is to perform exploratory data analysis on the\ngraph, we'll ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/explorer"},"K\xf9zu Explorer")," to visualize the graph and run Cypher queries."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (c:Client) RETURN COUNT(c) AS numClients\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"numClients"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (m:Merchant) RETURN COUNT(m) AS numMerchants\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"numMerchants"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (:Client)-[t:TransactedWith]->(:Merchant)\nRETURN COUNT(t) AS numTransactions\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"numTransactions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1100")))),(0,r.kt)("p",null,"The dataset contains 1,000 clients who made 1,100 transactions with 100 merchants. We can visualize\nthe transactions with a particular merchant at a particular city and belonging to a particular\ncompany using the following query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'MATCH (c:Client)-[t:TransactedWith]->(m:Merchant)-[b:BelongsTo]->(co:Company)\nMATCH (m)-[l:LocatedIn]->(ci:City {city: "Boston"})\nWHERE co.company = "Panera Bread"\nRETURN * LIMIT 25;\n')),(0,r.kt)("p",null,"The dataset contains two merchants belonging to Panera Bread in the city of Boston."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:l.Z})),(0,r.kt)("h2",{id:"study-disputed-transactions"},"Study disputed transactions"),(0,r.kt)("p",null,"The dataset becomes more interesting when we begin studying disputed\ntransactions. Not all disputed transactions are fraudulent, and so a simple aggregation query won't\nreveal many insights. We can begin by isolating only the vicinity of the disputed transactions of the\ngraph by specifying the boolean relationship property\n",(0,r.kt)("inlineCode",{parentName:"p"},"is_disputed")," and then adding a subsequent ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH")," statement to find the other merchants with whom\nclients reported disputed transactions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (c:Client)-[t:TransactedWith]->(m:Merchant)\nMATCH (c)-[t2:TransactedWith]->(m2:Merchant)\nWHERE t.is_disputed = true\nRETURN * LIMIT 25;\n")),(0,r.kt)("p",null,"When running this query in K\xf9zu Explorer, we can customize the edge properties displayed in the graph visualization. In\nthe following image, we mark the ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactedWith")," edges with the boolean value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"is_disputed"),"\nproperty from the data. Only a small fraction of these transactions have the ",(0,r.kt)("inlineCode",{parentName:"p"},"is_disputed")," property\nmarked as ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:c.Z})),(0,r.kt)("p",null,"It can be seen that certain clients interacted with multiple merchants, some of which form a cluster.\nIn other cases, nodes in the vicinity of a disputed transaction have no common paths with the larger graph,\nresulting in a disjoint subgraph. Fraud is less likely in the latter case, because a fraudster would\nlikely have interacted with multiple clients that are part of a cluster sharing common merchants."),(0,r.kt)("p",null,"The list of client names who reported disputed transactions can be listed as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (c:Client)-[t:TransactedWith]->(m:Merchant)\nWHERE t.is_disputed = true\nRETURN c.name AS name, t.timestamp AS transactionTime;\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"transactionTime"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Joshua T."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"2023-11-21T16:54:30Z"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Jennifer Y."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"2023-12-24T17:39:33Z"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Brandon T."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"2023-08-04T18:21:27Z"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cynthia J."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"2023-12-24T02:49:31Z"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Olivia C."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"2023-12-27T04:23:04Z"))))),(0,r.kt)("p",null,"Depending on the dataset, the time stamps of the disputed transactions in comparison to the timestamp\nof the transaction itself, could yield additional insights. The power of a graph structure is that\nit allows us to isolate substructures of interest based on the connected nature of the data. "),(0,r.kt)("p",null,"The aim of the next query is to find the city in which the most\ndisputed transactions occurred, and also to which companies the merchants processing these transactions\nbelonged to."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MATCH (c:Client)-[t:TransactedWith]->(:Merchant)\nWHERE t.is_disputed = true\nWITH c\nMATCH (c)-[t2:TransactedWith*..2]->(m:Merchant)-[:BelongsTo]->(co:Company)\nWITH c, m, co\nMATCH (m)-[:LocatedIn]->(ci:City)\nRETURN\n    m.merchant_id AS merchantID,\n    ci.city AS city,\n    co.company AS company,\n    COLLECT(c.name) AS clients,\n    COUNT(c) AS counts\nORDER BY counts DESC LIMIT 3;\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"merchantID"),(0,r.kt)("th",{parentName:"tr",align:null},"city"),(0,r.kt)("th",{parentName:"tr",align:null},"company"),(0,r.kt)("th",{parentName:"tr",align:null},"clients"),(0,r.kt)("th",{parentName:"tr",align:null},"counts"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"70"),(0,r.kt)("td",{parentName:"tr",align:null},"Boston"),(0,r.kt)("td",{parentName:"tr",align:null},"Walmart"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["Olivia C.","Jennifer Y.","Cynthia J."]')),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"76"),(0,r.kt)("td",{parentName:"tr",align:null},"San Francisco"),(0,r.kt)("td",{parentName:"tr",align:null},"Panera Bread"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["Joshua T.","Cynthia J."]')),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"51"),(0,r.kt)("td",{parentName:"tr",align:null},"Chicago"),(0,r.kt)("td",{parentName:"tr",align:null},"AT&T"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["Cynthia J.","Cynthia J."]')),(0,r.kt)("td",{parentName:"tr",align:null},"2")))),(0,r.kt)("p",null,"It can be seen that the clients Olivia, Cynthia and Jennifer all reported disputed transactions\nin a particular merchant location in Boston that belongs to the company Walmart. The query above\nreturned the names of the clients, but in a larger dataset it makes sense to return the\nnumber of clients instead."),(0,r.kt)("p",null,"When viewed visually, these results can be quite powerful. The following image shows result from\nabove, as seen in K\xf9zu Explorer."),(0,r.kt)("div",{class:"img-center"},(0,r.kt)("img",{src:d.Z})),(0,r.kt)("p",null,"If we simply look at aggregates based on the company and merchant, we see that the clients Olivia,\nJennifer and Cynthia from the previous query each reported disputed transactions in ",(0,r.kt)("em",{parentName:"p"},"different"),"\nmerchant locations. However, they all had a common merchant in Boston (ID 70) belonging to Walmart, that\nthey all made transactions within a plausible time window. This could indicate that this particular\nmerchant, located in Boston, could be a source of fraud."),(0,r.kt)("h2",{id:"graph-algorithms"},"Graph algorithms"),(0,r.kt)("p",null,"K\xf9zu is well-integrated with the PyData ecosystem, including PyTorch Geometric, Pandas, and\n",(0,r.kt)("a",{parentName:"p",href:"https://networkx.org/documentation/stable/reference/index.html"},"NetworkX"),", a popular Python library\nfor network analysis. Because K\xf9zu is an embedded graph database, it runs in-process with a Python\napplication, so it's simple to isolate a subgraph of interest via Cypher and convert it\nto a NetworkX directed graph (DiGraph) for further analysis."),(0,r.kt)("h3",{id:"weakly-connected-components"},"Weakly connected components"),(0,r.kt)("p",null,"A weakly connected component is a maximal subgraph in which there is a path between any two nodes,\nignoring the direction of the edges. In the context of our subgraph of clients, merchants and the\nvicinity of disputed transactions, we can use this algorithm to isolate the disjoint subgraphs that\nwe saw in the visualization earlier."),(0,r.kt)("p",null,"We first isolate the subgraph of clients, merchants and transactions in the vicinity of disputed\ntransactions as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'import kuzu\nimport networkx as nx\n\ndb = kuzu.Database("./transaction_db")\nconn = kuzu.Connection(db)\n\n# Isolate the subgraph of interest\ndisputed_vicinity = conn.execute(\n    """\n    MATCH (c1:Client)-[t1:TransactedWith]->(m:Merchant)<-[t2:TransactedWith]-(c2:Client)\n    WHERE t1.is_disputed = true\n    RETURN *;\n    """\n)\n\n# Convert to networkx DiGraph\nG1 = clients.get_as_networkx(directed=True)\n')),(0,r.kt)("p",null,"For every client that reported a disputed transaction, we isolate the subgraph of all the clients\nwho interacted with these same merchants, as well as others. Running the weakly connected components\nalgorithm will first inform us whether the vicinity of disputed transactions is a single connected\ncomponent or not."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"num_weakly_connected_components = nx.number_weakly_connected_components(G1)\nprint(num_weakly_connected_components)\n\n# Output\n2\n")),(0,r.kt)("p",null,"We obtain 2 weakly connected components, indicating that there are disjoint components in the\ndisputed transactions subgraph."),(0,r.kt)("p",null,"To see which clients/merchants are in each weakly connected component, we can run the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"weakly_connected_components = list(nx.weakly_connected_components(G2))\n\nprint(len(weakly_connected_components[0]))\nprint(len(weakly_connected_components[1]))\n\n# Output\n52\n9\n")),(0,r.kt)("p",null,"The first cluster of clients and merchants contains 52 nodes, while the second cluster contains 9\nnodes. This helps narrow down on a transaction subgraph that has a greater degree of connectivity."),(0,r.kt)("h3",{id:"closeness-centrality"},"Closeness centrality"),(0,r.kt)("p",null,'Centrality algorithms are among the most commonly used algorithms in graph data science.\nAt a high-level, centrality algorithms are used to identify "important" nodes - specifically, nodes\nthat serve the role of connecting many other nodes in the graph. Suppose the owner of our\ntransaction graph is an e-commerce company, and that the company wants to promote its\n"important merchants" to attract more customers to its network. Centrality metrics, similar to the\npopular PageRank metric, are concrete ways to order nodes in terms of "importance".'),(0,r.kt)("p",null,"Closeness centrality",(0,r.kt)("sup",{parentName:"p",id:"fnref-2-4945b3"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2-4945b3",className:"footnote-ref"},"2"))," measures how close a node ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is to all other nodes by calculating the\n",(0,r.kt)("em",{parentName:"p"},"average")," of the shortest path length from ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," to every other node in the graph. For this example,\nwe will first isolate the full subgraph of all clients, merchants and transactions, not\njust those in the vicinity of disputed transactions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'subgraph = conn.execute(\n    """\n    MATCH (c:Client)-[t:TransactedWith]->(m:Merchant)\n    RETURN *;\n    """\n)\n\n# Convert to networkx DiGraph\nG2 = subgraph.get_as_networkx(directed=True)\n\ncloseness_centrality_result = list(nx.closeness_centrality(G1).items())\ncloseness_centrality_result.sort(key=lambda x: x[1], reverse=True)\nprint(closeness_centrality_result[:5])\n')),(0,r.kt)("p",null,"The top 5 nodes with the highest closeness centrality are shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[('Merchant_35', 0.028),\n ('Merchant_56', 0.02666666666666667),\n ('Merchant_38', 0.025333333333333333),\n ('Merchant_66', 0.025333333333333333),\n ('Merchant_96', 0.024)]\n")),(0,r.kt)("p",null,"The scores indicate that the merchant with ID 35 is the most central node in the subgraph, i.e.,\nit's on average the closest to other nodes in the graph as a lot of paths go through it. Pandas\nmakes this process very convenient."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'import pandas as pd\n\ndf = pd.DataFrame(closeness_centrality_result, columns=["node_id", "closeness_centrality"])\ndf = df[df["node_id"].str.startswith("Merchant_")]\ndf["node_id"] = df["node_id"].str.replace("Merchant_", "").astype(int)\ndf = df.sort_values(by="closeness_centrality", ascending=False).reset_index(drop=True)\nprint(df.head(5))\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"node_id"),(0,r.kt)("th",{parentName:"tr",align:null},"closeness_centrality"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"35"),(0,r.kt)("td",{parentName:"tr",align:null},"0.028000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"56"),(0,r.kt)("td",{parentName:"tr",align:null},"0.026667")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"38"),(0,r.kt)("td",{parentName:"tr",align:null},"0.025333")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"66"),(0,r.kt)("td",{parentName:"tr",align:null},"0.025333")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"96"),(0,r.kt)("td",{parentName:"tr",align:null},"0.024000")))),(0,r.kt)("p",null,"Once we have the Pandas DataFrame, it's trivial to write a function that can modify the existing\n",(0,r.kt)("inlineCode",{parentName:"p"},"Merchant")," node table and add the closeness centrality scores back to the graph. K\xf9zu's Python\nAPI has a native scan feature that can directly read from Pandas DataFrames in a zero-copy manner."),(0,r.kt)("p",null,"Note that we first alter the original node table schema to add a new column for the closeness\ncentrality scores. We then use the ",(0,r.kt)("inlineCode",{parentName:"p"},"LOAD FROM")," command to read the Pandas DataFrame into the graph."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'try:\n    # Alter original node table schema to add degree centrality\n    conn.execute(\'ALTER TABLE Merchant ADD closeness_centrality DOUBLE DEFAULT 0.0\')\nexcept RuntimeError:\n    # If the column already exists, do nothing\n    pass\n# Read degree centrality to graph\nconn.execute(\n    """\n    LOAD FROM df\n    MERGE (m:Merchant {merchant_id: node_id})\n    ON MATCH SET m.closeness_centrality = closeness_centrality\n    RETURN *;\n    """\n)\n')),(0,r.kt)("p",null,"Applying a similar process to the client nodes (via other centrality algorithms like degree centrality)\ncan help us use these scores in downstream machine learning models, or to inform further decisions."),(0,r.kt)("h2",{id:"conclusions"},"Conclusions"),(0,r.kt)("p",null,"Hopefully, this post has given you a good idea of how to use K\xf9zu to effectively model and analyze\nyour data via a combination of Cypher and graph algorithms. It's worth keeping in mind that\nGraph data science, just like conventional data science, is an iterative\nprocess. The ability to think of structured data (in tables) as graphs helps us rapidly isolate interesting subsets of the data,\nrun graph algorithms and visualize substructures, making these powerful tools in the data scientist's toolkit."),(0,r.kt)("p",null,"K\xf9zu's in-process architecture makes it very friendly towards these sorts of workflows without the\ndata scientist having to worry about servers or managing infrastructure. Data can be conveniently read into K\xf9zu from a\nvariety of sources, including relational databases, CSV or parquet files, or DataFrames. Future\nversions of K\xf9zu will support more convenience features, such as the ability to natively scan\nPostgreSQL tables, as well as native support for Arrow tables."),(0,r.kt)("p",null,"In summary, the interoperability of an embedded graph database with popular Python libraries like\nNetworkX and Pandas makes K\xf9zu a powerful tool for graph data science. If you have data of a similar\nnature in the form of relational tables, we highly recommend you to\nthink about whether your use case can benefit from graph data models. If so, give K\xf9zu a try and\nreach out to us on ",(0,r.kt)("a",{parentName:"p",href:"https://discord.gg/VtX2gw9Rug"},"Discord")," with your experiences and feedback!"),(0,r.kt)("h2",{id:"code"},"Code"),(0,r.kt)("p",null,"All code for this post can be found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kuzudb/graphdb-demo/tree/main/src/python/transactions_with_disputes"},"graphdb-demo")," repository."),(0,r.kt)("h2",{id:"further-reading"},"Further reading"),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1-4945b3"},(0,r.kt)("em",{parentName:"li"},"Graph Powered Machine Learning"),",\n",(0,r.kt)("a",{parentName:"li",href:"https://livebook.manning.com/concept/graphs/transaction"},"Ch. 2"),", By Alessandro Negro, Manning\nPublications, 2021.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1-4945b3",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2-4945b3"},(0,r.kt)("em",{parentName:"li"},"When is the Closeness Centrality Algorithm best applied?")," ","[blog post]","\n(",(0,r.kt)("a",{parentName:"li",href:"https://www.graphable.ai/blog/closeness-centrality-algorithm/"},"https://www.graphable.ai/blog/closeness-centrality-algorithm/"),"),\nBy Fatima Rubio, Graphable",(0,r.kt)("a",{parentName:"li",href:"#fnref-2-4945b3",className:"footnote-backref"},"\u21a9")))))}f.isMDXComponent=!0},9349:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dispute_graph_viz-fc2207718372c706a9b1bf0989e492c1.png"},817:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/graph_schema_dispute-b8ff6b67dd6f0f6386d5803b91352d69.png"},1821:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/kuzu_explorer_schema-7ae969c8efe12880de51d54c723fb1ad.png"},401:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/query_boston_panera-79f4d57d2909c0a23abdcbdf0ae431b6.png"},826:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/query_disputed_transactions_vicinity-516b1741b2e64c1de67e4644adef753f.png"},4123:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/relational_schema_dispute-14bd72a5104aaa2cc7fdfdbc6f239e29.png"}}]);