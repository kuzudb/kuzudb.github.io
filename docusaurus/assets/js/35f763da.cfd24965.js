"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[5419],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>y});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,y=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(y,i(i({ref:t},s),{},{components:n})):r.createElement(y,i({ref:t},s))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[u]="string"==typeof e?e:a,i[1]=p;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8991:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={title:"Map",sidebar_position:13},i="MAP",p={unversionedId:"cypher/data-types/map",id:"cypher/data-types/map",title:"Map",description:"A MAP is a dictionary of key-value pairs where all keys have the same type and all values have the same type. Different from STRUCT, MAP doesn't require the same key to present in each row. Therefore, MAP is more suitable when the schema is not determined.",source:"@site/docs/cypher/data-types/map.md",sourceDirName:"cypher/data-types",slug:"/cypher/data-types/map",permalink:"/docusaurus/cypher/data-types/map",draft:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Map",sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"Timestamp",permalink:"/docusaurus/cypher/data-types/timestamp"},next:{title:"Union",permalink:"/docusaurus/cypher/data-types/union"}},l={},c=[{value:"<code>MAP</code> Creation",id:"map-creation",level:3},{value:"<code>Map</code> Extraction",id:"map-extraction",level:3}],s={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"map"},"MAP"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"MAP")," is a dictionary of key-value pairs where all keys have the same type and all values have the same type. Different from ",(0,a.kt)("inlineCode",{parentName:"p"},"STRUCT"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"MAP")," doesn't require the same key to present in each row. Therefore, ",(0,a.kt)("inlineCode",{parentName:"p"},"MAP")," is more suitable when the schema is not determined."),(0,a.kt)("p",null,"Internally, K\xf9zu process ",(0,a.kt)("inlineCode",{parentName:"p"},"MAP")," as a ",(0,a.kt)("inlineCode",{parentName:"p"},"STRUCT[LIST]"),", more sepcifically, a ",(0,a.kt)("inlineCode",{parentName:"p"},"STRUCT")," with two ",(0,a.kt)("inlineCode",{parentName:"p"},"LIST")," one for keys and the other for values."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Data Type"),(0,a.kt)("th",{parentName:"tr",align:null},"DDL definition"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"MAP"),(0,a.kt)("td",{parentName:"tr",align:null},"MAP(STRING, INT64)")))),(0,a.kt)("h3",{id:"map-creation"},(0,a.kt)("inlineCode",{parentName:"h3"},"MAP")," Creation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"RETURN map([1, 2], ['a', 'b']) AS m;\n--------------\n| m          |\n--------------\n| {1=a, 2=b} |\n--------------\n")),(0,a.kt)("h3",{id:"map-extraction"},(0,a.kt)("inlineCode",{parentName:"h3"},"Map")," Extraction"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"RETURN map_extract(map([1, 2], ['a', 'b']),2) AS m;\n-------\n| m   |\n-------\n| [b] |\n-------\n")),(0,a.kt)("p",null,"More map functions can be found at ",(0,a.kt)("a",{parentName:"p",href:"/docusaurus/cypher/expressions/map-functions"},"map-functions")))}m.isMDXComponent=!0}}]);