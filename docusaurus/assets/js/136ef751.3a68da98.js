"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[8705],{3905:(e,a,n)=>{n.d(a,{Zo:()=>h,kt:()=>c});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function l(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?l(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=t.createContext({}),p=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},h=function(e){var a=p(e.components);return t.createElement(o.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,c=u["".concat(o,".").concat(d)]||u[d]||m[d]||l;return n?t.createElement(c,i(i({ref:a},h),{},{components:n})):t.createElement(c,i({ref:a},h))}));function c(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=n[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7543:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var t=n(7462),r=(n(7294),n(3905)),l=n(5973);const i={title:"Match",sidebar_position:1,description:'MATCH is the clause where you define a graph pattern", i.e., a join of node or relationship records, to find in the database.'},s="Database",o={unversionedId:"cypher/query-clauses/match",id:"cypher/query-clauses/match",title:"Match",description:'MATCH is the clause where you define a graph pattern", i.e., a join of node or relationship records, to find in the database.',source:"@site/docs/cypher/query-clauses/match.md",sourceDirName:"cypher/query-clauses",slug:"/cypher/query-clauses/match",permalink:"/docusaurus/cypher/query-clauses/match",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Match",sidebar_position:1,description:'MATCH is the clause where you define a graph pattern", i.e., a join of node or relationship records, to find in the database.'},sidebar:"tutorialSidebar",previous:{title:"Example database",permalink:"/docusaurus/cypher/query-clauses/example-database"},next:{title:"Optional Match",permalink:"/docusaurus/cypher/query-clauses/optional-match"}},p={},h=[{value:"Important Notes:",id:"important-notes",level:2},{value:"Match Nodes",id:"match-nodes",level:2},{value:"Match Nodes With a Single Label",id:"match-nodes-with-a-single-label",level:3},{value:"Match Nodes With Multiple Labels",id:"match-nodes-with-multiple-labels",level:3},{value:"Match Nodes With Any Label",id:"match-nodes-with-any-label",level:3},{value:"Match Relationships",id:"match-relationships",level:2},{value:"Match Directed Relationships With a Label",id:"match-directed-relationships-with-a-label",level:3},{value:"Match Relationships With Multi Labels",id:"match-relationships-with-multi-labels",level:3},{value:"Match Relationships With Any Label",id:"match-relationships-with-any-label",level:3},{value:"Match Undirected Relationships",id:"match-undirected-relationships",level:3},{value:"Omit Binding Variables to Nodes or Relationships",id:"omit-binding-variables-to-nodes-or-relationships",level:3},{value:"Match Multiple Patterns",id:"match-multiple-patterns",level:3},{value:"Equality Predicates on Node/Rel Properties",id:"equality-predicates-on-noderel-properties",level:3},{value:"Match Variable Length Relationships",id:"match-variable-length-relationships",level:2},{value:"Returning Variable Length Relationships",id:"returning-variable-length-relationships",level:3},{value:"Single Shortest Path",id:"single-shortest-path",level:3},{value:"All Shortest Path",id:"all-shortest-path",level:3},{value:"Filter Variable Length Relationships",id:"filter-variable-length-relationships",level:3},{value:"Named Path",id:"named-path",level:2},{value:"Extracting Nodes, Rels From a Path",id:"extracting-nodes-rels-from-a-path",level:3}],u={toc:h},m="wrapper";function d(e){let{components:a,...n}=e;return(0,r.kt)(m,(0,t.Z)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"database"},"Database"),(0,r.kt)("p",null,"We will use the database, whose schema and data import commands are given ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/query-clauses/example-database"},"here"),":"),(0,r.kt)("img",{src:l.Z,style:{width:800}}),(0,r.kt)("p",null,"You can import this database by copy pasting the commands on that page. "),(0,r.kt)("h1",{id:"match"},"MATCH"),(0,r.kt)("p",null,'MATCH is the clause where you define a "graph pattern", i.e., a join of node or relationship records,\nto find in the database.',(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". There are several different ways to match patterns and we go through them\nbelow. MATCH is often accompanied by ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/query-clauses/where"},"WHERE")," (equivalent to SQL's WHERE clause) to define more predicates on the patterns that are matched."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-nodes"},"Match Nodes"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-nodes-with-a-single-label"},"Match Nodes With a Single Label")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-nodes-with-multiple-labels"},"Match Nodes With Multiple Labels")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-nodes-with-any-label"},"Match Nodes With Any Label")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-relationships"},"Match Relationships"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-directed-relationships-with-a-label"},"Match Directed Relationships With a Label")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-relationships-with-multi-labels"},"Match Relationships With Multi Labels")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-relationships-with-any-label"},"Match Relationships With Any Label")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-undirected-relationships"},"Match Undirected Relationships")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#omit-binding-variables-to-nodes-or-relationships"},"Omit Binding Variables to Nodes or Relationships")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-multiple-patterns"},"Match Multiple Patterns")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#equality-predicates-on-noderel-properties"},"Equality Predicates on Node/Rel Properties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#match-variable-length-relationships"},"Match Variable Length Relationships")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#returning-variable-length-relationships"},"Returning Variable Length Relationships")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#single-shortest-path"},"Single Shortest Path"))))),(0,r.kt)("h2",{id:"important-notes"},"Important Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Similar to other high-level database query languages, nodes and relationships in the patterns\nare bound to variables, which can be referenced in other clauses (e.g., WHERE or RETURN) of the query.\nopenCypher allows you to omit these variables, if you do not need to reference them."),(0,r.kt)("li",{parentName:"ul"},"Node/Rel table names in K\xf9zu are case sensitive. So you need to specify the labels of nodes/rels\nusing the same letter cases you used in your node/rel table schema definitions. ")),(0,r.kt)("h2",{id:"match-nodes"},"Match Nodes"),(0,r.kt)("h3",{id:"match-nodes-with-a-single-label"},"Match Nodes With a Single Label"),(0,r.kt)("p",null,'The query below matches variable "a" to nodes with label User and returns "a", which\nis a shortcut in openCypher to return all properties of the node together with label and internal ID that variable "a" matches.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)\nRETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------\n| a                                                |\n----------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30}    |\n----------------------------------------------------\n| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40} |\n----------------------------------------------------\n| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50}   |\n----------------------------------------------------\n| {_ID: 0:3, _LABEL: User, name: Noura, age: 25}   |\n----------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=xjiF39SzeCb7"},"Colab"),"."),(0,r.kt)("h3",{id:"match-nodes-with-multiple-labels"},"Match Nodes With Multiple Labels"),(0,r.kt)("p",null,'The query below matches variable "a" to nodes with label User or label City. "Return a" will return all properties of the node together with label and internal ID. Properties not exist in a label will be returned as NULL value (e.g. "population" not exists in "User"). Properties exists in multiple labels are expected to have the same data type (e.g. "name" has STRING data type in "User" and "City" ).'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User:City)\nRETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------\n| a                                                             |\n-----------------------------------------------------------------\n| {_ID: 1:0, _LABEL: City, name: Waterloo, population: 150000}  |\n-----------------------------------------------------------------\n| {_ID: 1:1, _LABEL: City, name: Kitchener, population: 200000} |\n-----------------------------------------------------------------\n| {_ID: 1:2, _LABEL: City, name: Guelph, population: 75000}     |\n-----------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30, }               |\n-----------------------------------------------------------------\n| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40, }            |\n-----------------------------------------------------------------\n| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50, }              |\n-----------------------------------------------------------------\n| {_ID: 0:3, _LABEL: User, name: Noura, age: 25, }              |\n-----------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=3yO3HHwNeBy3"},"Colab"),"."),(0,r.kt)("h3",{id:"match-nodes-with-any-label"},"Match Nodes With Any Label"),(0,r.kt)("p",null,'Below query matches variable "a" to nodes with any label. In example database, it is equivalent to ',(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:User:City) RETURN a;"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a)\nRETURN a;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------\n| a                                                             |\n-----------------------------------------------------------------\n| {_ID: 1:0, _LABEL: City, name: Waterloo, population: 150000}  |\n-----------------------------------------------------------------\n| {_ID: 1:1, _LABEL: City, name: Kitchener, population: 200000} |\n-----------------------------------------------------------------\n| {_ID: 1:2, _LABEL: City, name: Guelph, population: 75000}     |\n-----------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30, }               |\n-----------------------------------------------------------------\n| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40, }            |\n-----------------------------------------------------------------\n| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50, }              |\n-----------------------------------------------------------------\n| {_ID: 0:3, _LABEL: User, name: Noura, age: 25, }              |\n-----------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=4NBsUUP_evvh"},"Colab"),"."),(0,r.kt)("h2",{id:"match-relationships"},"Match Relationships"),(0,r.kt)("h3",{id:"match-directed-relationships-with-a-label"},"Match Directed Relationships With a Label"),(0,r.kt)("p",null,"Similar to binding variables to node records, you can bind variables to relationship records and return them. You can specificy the direction of relationship by ",(0,r.kt)("inlineCode",{parentName:"p"},"<-")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"->"),'. The following query finds all "a" Users that follow a "b" User through an outgoing relationship from "a", and returns name of "a", relationship "e", and name of "b", where "e" will match the relationship from "a" to "b".'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows]->(b:User)\nRETURN a.name, e, b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------------------\n| a.name  | e                                                     | b.name  |\n-----------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) | Karissa |\n-----------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) | Zhang   |\n-----------------------------------------------------------------------------\n| Karissa | (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) | Zhang   |\n-----------------------------------------------------------------------------\n| Zhang   | (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) | Noura   |\n-----------------------------------------------------------------------------\n")),(0,r.kt)("p",null,'The following query matches all the relationships through an incoming relationship from "a" (so "a" and "b" are swapped in output):'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)<-[e:Follows]-(b:User)\nRETURN a.name, e, b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------------------\n| a.name  | e                                                     | b.name  |\n-----------------------------------------------------------------------------\n| Karissa | (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) | Adam    |\n-----------------------------------------------------------------------------\n| Zhang   | (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) | Adam    |\n-----------------------------------------------------------------------------\n| Zhang   | (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) | Karissa |\n-----------------------------------------------------------------------------\n| Noura   | (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) | Zhang   |\n-----------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=Djpu4aDafG5U"},"Colab"),"."),(0,r.kt)("h3",{id:"match-relationships-with-multi-labels"},"Match Relationships With Multi Labels"),(0,r.kt)("p",null,'Similar to matching nodes with multiple labels, you can bind variables to relationships with multiple labels. Below query finds all "a" User that Follows "b" User or LivesIn "b" City.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows|:LivesIn]->(b:User:City)\nRETURN a.name, e, b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-------------------------------------------------------------------------------\n| a.name  | e                                                     | b.name    |\n-------------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) | Karissa   |\n-------------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) | Zhang     |\n-------------------------------------------------------------------------------\n| Adam    | (0:0)-{_LABEL: LivesIn, _ID: 3:0, }->(1:0)            | Waterloo  |\n-------------------------------------------------------------------------------\n| Karissa | (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) | Zhang     |\n-------------------------------------------------------------------------------\n| Karissa | (0:1)-{_LABEL: LivesIn, _ID: 3:1, }->(1:0)            | Waterloo  |\n-------------------------------------------------------------------------------\n| Zhang   | (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) | Noura     |\n-------------------------------------------------------------------------------\n| Zhang   | (0:2)-{_LABEL: LivesIn, _ID: 3:2, }->(1:1)            | Kitchener |\n-------------------------------------------------------------------------------\n| Noura   | (0:3)-{_LABEL: LivesIn, _ID: 3:3, }->(1:2)            | Guelph    |\n-------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=ylYHrLeQfLao"},"Colab"),"."),(0,r.kt)("h3",{id:"match-relationships-with-any-label"},"Match Relationships With Any Label"),(0,r.kt)("p",null,"Similar to matching nodes with any label, you can bind variables to relationships with any label by not specifying a label. Below query finds all relationships in the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH ()-[e]->()\nRETURN e;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"---------------------------------------------------------\n| e                                                     |\n---------------------------------------------------------\n| (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) |\n---------------------------------------------------------\n| (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) |\n---------------------------------------------------------\n| (0:0)-{_LABEL: LivesIn, _ID: 3:0, }->(1:0)            |\n---------------------------------------------------------\n| (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) |\n---------------------------------------------------------\n| (0:1)-{_LABEL: LivesIn, _ID: 3:1, }->(1:0)            |\n---------------------------------------------------------\n| (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) |\n---------------------------------------------------------\n| (0:2)-{_LABEL: LivesIn, _ID: 3:2, }->(1:1)            |\n---------------------------------------------------------\n| (0:3)-{_LABEL: LivesIn, _ID: 3:3, }->(1:2)            |\n---------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=lEZAboFLfLku"},"Colab"),"."),(0,r.kt)("h3",{id:"match-undirected-relationships"},"Match Undirected Relationships"),(0,r.kt)("p",null,"User can match a relationship in both directions by not specifiying a relationship direction (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"-"),'). The following query finds all "b" users who either follows or being followed by "Karissa". '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows]-(b:User) Where a.name = 'Karissa' RETURN b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------\n| b.name |\n----------\n| Adam   |\n----------\n| Zhang  |\n----------\n")),(0,r.kt)("h3",{id:"omit-binding-variables-to-nodes-or-relationships"},"Omit Binding Variables to Nodes or Relationships"),(0,r.kt)("p",null,'You can also omit binding a variable to a node or relationship in your graph patterns if\nyou will not use them in somewhere else in your query (e.g., WHERE or RETURN). For example, below, we query for 2-hop paths searching for "the cities that Users that "a" Users follows".\nBecause we do not need to return the Users that "a" Users follows or the properties\nof the Follows and LivesIn edges that form these 2-paths, we can omit giving variable names to them.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MATCH (a:User)-[:Follows]->(:User)-[:LivesIn]->(c:City)\nWHERE a.name = "Adam"\nRETURN a, c.name, c.population;\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------------\n| a                                             | c.name    | c.population |\n----------------------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30} | Waterloo  | 150000       |\n----------------------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30} | Kitchener | 200000       |\n----------------------------------------------------------------------------\n")),(0,r.kt)("h3",{id:"match-multiple-patterns"},"Match Multiple Patterns"),(0,r.kt)("p",null,"Although paths can be matched in a single pattern, some patterns, in particular\ncyclic patterns, require specifying multiple patterns/paths that form the pattern.\nThese multiple paths are separated by a comma. The following is a (directed) triangle\nquery and returns the only triangle in the database between Adam, Karissa, and Zhang."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[:Follows]->(b:User)-[:Follows]->(c:User), (a)-[:Follows]->(c)\nRETURN a.name, b.name, c.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------\n| a.name | b.name  | c.name |\n-----------------------------\n| Adam   | Karissa | Zhang  |\n-----------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=NQIITQTloYO_"},"Colab"),"."),(0,r.kt)("p",null,"Note that in the query node variables a and c appear twice, once on each of the 2 paths\nin the query. In such cases, their labels need to be specified ",(0,r.kt)("em",{parentName:"p"},"only the first time they appear\nin the pattern"),". In the above query a and c's labels are defined on the first/left path,\nso you don't have to specify them on the right path (though you still can)."),(0,r.kt)("h3",{id:"equality-predicates-on-noderel-properties"},"Equality Predicates on Node/Rel Properties"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/query-clauses/where"},"WHERE clause"),' is the main clause to specify arbitary predicates on the nodes and relationships in your patters (e.g., a.age < b.age in where "a" and "b" bind to User nodes).\nAs a syntactic sugar openCypher allows ',(0,r.kt)("em",{parentName:"p"},"equality predicates")," to be matched on\nnodes and edges using the ",(0,r.kt)("inlineCode",{parentName:"p"},"{prop1 : value1, prop2 : value2, ...}")," syntax. For example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MATCH (a:User)-[e:Follows {since: 2020}]->(b:User {name: "Zhang"})\nRETURN a, e.since, b.name;\n')),(0,r.kt)("p",null,"is a syntactic sugar for:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MATCH (a:User)-[e:Follows]->(b:User)\nWHERE e.since = 2020 AND b.name = "Zhang"\nRETURN a, e.since, b.name;\n')),(0,r.kt)("p",null,"and both queries output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------------------------------------------------------\n| a                                             | e.since | b.name |\n--------------------------------------------------------------------\n| {_ID: 0:0, _LABEL: User, name: Adam, age: 30} | 2020    | Zhang  |\n--------------------------------------------------------------------\n")),(0,r.kt)("p",null,"View example in ",(0,r.kt)("a",{parentName:"p",href:"https://colab.research.google.com/drive/1NcR-xL4Rb7nprgbvk6N2dIP30oqyUucm#scrollTo=1frFFis4onqw"},"Colab"),"."),(0,r.kt)("h2",{id:"match-variable-length-relationships"},"Match Variable Length Relationships"),(0,r.kt)("p",null,"You can also find paths that are variable-length between node records. Specifically, you can find variable-hop connections between nodes by specifying in the relationship patterns,\ne.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"-[:Label*min..max]->"),", where min and max specify the minimum and the maximum number of hops",(0,r.kt)("sup",{parentName:"p",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),'.\nThe following query finds all Users that "Adam" follows within 1 to 2 hops and returns their names as well as length of the path.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows*1..2]->(b:User) \nWHERE a.name = 'Adam'\nRETURN b.name, length(e) AS length;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------\n| b.name  | length |\n--------------------\n| Karissa | 1      |\n--------------------\n| Zhang   | 2      |\n--------------------\n| Zhang   | 1      |\n--------------------\n| Noura   | 2      |\n--------------------\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Karissa is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Karissa")),(0,r.kt)("li",{parentName:"ul"},"Zhang is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Zhang")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Karissa -> Zhang")),(0,r.kt)("li",{parentName:"ul"},"Noura is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Adam -> Zhang -> Noura"))),(0,r.kt)("p",null,'Similar to matching relationships, you can match undirected relationships or relationship with multiple labels.\nThe following query finds all Nodes excluding "Noura" that connects to "Noura" in both directions through any relationship with 2 hops.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e*2..2]-(b) \nWHERE a.name = 'Noura' AND b.name <> 'Noura'\nRETURN b.name, length(e) AS length;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------\n| b.name    | length |\n----------------------\n| Adam      | 2      |\n----------------------\n| Karissa   | 2      |\n----------------------\n| Kitchener | 2      |\n----------------------\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Adam is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Noura <- User -> Adam")),(0,r.kt)("li",{parentName:"ul"},"Karissa is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Noura <- User -> Karissa")),(0,r.kt)("li",{parentName:"ul"},"Kitchener is found through ",(0,r.kt)("inlineCode",{parentName:"li"},"Noura <- User -> Kitchener"))),(0,r.kt)("h3",{id:"returning-variable-length-relationships"},"Returning Variable Length Relationships"),(0,r.kt)("p",null,"Current implmentation binds variable length relationships as a ",(0,r.kt)("inlineCode",{parentName:"p"},"LIST")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"INTERNAL_ID")," where entries 0,2,4,... represent node IDs and entries 1,3,5,... represent relationship IDs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e:Follows*1..2]->(b:User) \nWHERE a.name = 'Adam'\nRETURN b.name, e;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------------------------------\n| b.name  | e                                                                                |\n----------------------------------------------------------------------------------------------\n| Karissa | {_NODES: [], _RELS: [(0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1)]}     |\n----------------------------------------------------------------------------------------------\n| Zhang   | {_NODES: [{_ID: 0:1, _LABEL: User, name: Karissa, age: 40}], _RELS: [(0:0)-{_... |\n----------------------------------------------------------------------------------------------\n| Zhang   | {_NODES: [], _RELS: [(0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2)]}     |\n----------------------------------------------------------------------------------------------\n| Noura   | {_NODES: [{_ID: 0:2, _LABEL: User, name: Zhang, age: 50}], _RELS: [(0:0)-{_LA... |\n----------------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fruther notes on variable length relationships")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Returning properties of variable length relationships is not yet supported."),(0,r.kt)("li",{parentName:"ul"},"The maximum length of variable length relationships is capped at 30. ")),(0,r.kt)("h3",{id:"single-shortest-path"},"Single Shortest Path"),(0,r.kt)("p",null,"On top of variable length relationships, user can search for single shortest path by specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"SHORTEST")," key word in relationship, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"-[:Label* SHORTEST 1..max]"),".\nThe following query finds a shortest path between ",(0,r.kt)("inlineCode",{parentName:"p"},"Adam")," and any city and returns city name as well as length of the path."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[e* SHORTEST 1..4]->(b:City) \nWHERE a.name = 'Adam'\nRETURN b.name, length(e) AS length;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------\n| b.name    | length |\n----------------------\n| Waterloo  | 1      |\n----------------------\n| Kitchener | 2      |\n----------------------\n| Guelph    | 3      |\n----------------------\n")),(0,r.kt)("h3",{id:"all-shortest-path"},"All Shortest Path"),(0,r.kt)("p",null,"You can also search for all shortest path with ",(0,r.kt)("inlineCode",{parentName:"p"},"ALL SHORTEST")," key word, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"-[:Label* ALL SHORTEST 1..max]")),(0,r.kt)("p",null,"The following query finds all shortest path between ",(0,r.kt)("inlineCode",{parentName:"p"},"Zhang")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Waterloo"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a)-[* ALL SHORTEST 1..3 ]-(b) \nWHERE a.name = 'Zhang' AND b.name = 'Waterloo' \nRETURN COUNT(*) AS num_shortest_path;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"---------------------\n| num_shortest_path |\n---------------------\n| 2                 |\n---------------------\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fruther notes on shortest path"),"\nWe force the lower bound of shortest path to be 1 to avoid ambiguity. There are two interpretations when the lower bound is greater than 1, "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Compute shortest path and then return path whose length is greater than lower bound."),(0,r.kt)("li",{parentName:"ul"},"Compute path with length greater than lower bound and then return shoetest path.")),(0,r.kt)("h3",{id:"filter-variable-length-relationships"},"Filter Variable Length Relationships"),(0,r.kt)("p",null,"We also support running predicate on recursive pattern to constaint the relationship being travered."),(0,r.kt)("p",null,"The following query finds name of users that are followed between 1 - 2 hops by Adam before 2022."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows*1..2 (r, _ | WHERE r.since < 2022) ]->(b:User)\nWHERE a.name = 'Adam' \nRETURN DISTINCT b.name;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------\n| b.name  |\n-----------\n| Karissa |\n-----------\n| Zhang   |\n-----------\n")),(0,r.kt)("p",null,"Note that our filter grammar follows ",(0,r.kt)("a",{parentName:"p",href:"https://memgraph.com/docs/memgraph/reference-guide/built-in-graph-algorithms"},"Memgraph")," using list comprehension. The first variable represents recursive relationship. Since we currently don't allow filter on recursive node, the second variable must be ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"."),(0,r.kt)("h2",{id:"named-path"},"Named Path"),(0,r.kt)("p",null,"K\xf9zu treats path a first-class citizen so user can assign a named variable to a path (i.e. connected graph ) and use it later on."),(0,r.kt)("p",null,"The following query returns all path between ",(0,r.kt)("inlineCode",{parentName:"p"},"Adam")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Karissa"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows]->(b:User) \nWHERE a.name = 'Adam' AND b.name = 'Karissa' \nRETURN p;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"------------------------------------------------------------------------------------\n| p                                                                                |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: Us... |\n------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"Named path can also be assigned to recursive graph pattern."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows*1..2]->(:User)-[:LivesIn]->(:City) \nWHERE a.name = 'Adam' \nRETURN p;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"------------------------------------------------------------------------------------\n| p                                                                                |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:1, _LABEL: ... |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:2, _LABEL: ... |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:1, _LABEL: ... |\n------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30, },{_ID: 0:2, _LABEL: ... |\n------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"Multiple named path can appear in a single ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH")," clause."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p1 = (a:User)-[:Follows]->(b:User), p2 = (b)-[:LivesIn]->(:City) \nWHERE a.name = 'Adam' \nRETURN p1, p2;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| p1                                                                               | p2                                                                               |\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: Us... | {_NODES: [{_ID: 0:1, _LABEL: User, name: Karissa, age: 40, },{_ID: 1:0, _LABE... |\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| {_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:2, _LABEL: Us... | {_NODES: [{_ID: 0:2, _LABEL: User, name: Zhang, age: 50, },{_ID: 1:1, _LABEL:... |\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n")),(0,r.kt)("h3",{id:"extracting-nodes-rels-from-a-path"},"Extracting Nodes, Rels From a Path"),(0,r.kt)("p",null,"Interanally ",(0,r.kt)("inlineCode",{parentName:"p"},"PATH")," is processed as a ",(0,r.kt)("inlineCode",{parentName:"p"},"STRUCT{LIST[NODE], LIST[REL]}")," see ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/data-types/path"},(0,r.kt)("inlineCode",{parentName:"a"},"PATH data type"))," for details. Users can access nodes and rels within a path through ",(0,r.kt)("inlineCode",{parentName:"p"},"nodes(p)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"rels(p)")," function calls."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH p = (a:User)-[:Follows*1..2]->(:User) \nWHERE a.name = 'Adam' \nRETURN nodes(p), (rels(p)[1]).since AS since;\n")),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--------------------------------------------------------------------------------------------\n| NODES(p)                                                                         | since |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:2, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n| [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:2, _LABEL: User, name:... | 2020  |\n--------------------------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"More path functions can be found ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/expressions/path_functions"},"here"),"."),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"MATCH is similar to the FROM clause of SQL, where the list of tables that need to be joined are specified. ",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},"openCypher also supports variable-length patterns where either or both of min and max bounds can be missing. K\xf9zu does not yet support this and users need to explicitly indicate both bounds.",(0,r.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0},5973:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/images/running-example-db76aa393fd70d29c831f1527455440a.png"}}]);