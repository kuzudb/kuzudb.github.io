"use strict";(self.webpackChunkkuzu_docs=self.webpackChunkkuzu_docs||[]).push([[2293],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(a),h=r,m=c["".concat(s,".").concat(h)]||c[h]||u[h]||i;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8540:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={title:"Create",sidebar_position:0,description:"Create tables"},o="CREATE",l={unversionedId:"cypher/data-definition/create-table",id:"cypher/data-definition/create-table",title:"Create",description:"Create tables",source:"@site/docs/cypher/data-definition/create-table.md",sourceDirName:"cypher/data-definition",slug:"/cypher/data-definition/create-table",permalink:"/docusaurus/cypher/data-definition/create-table",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Create",sidebar_position:0,description:"Create tables"},sidebar:"tutorialSidebar",previous:{title:"Data Definition",permalink:"/docusaurus/cypher/data-definition/"},next:{title:"Alter",permalink:"/docusaurus/cypher/data-definition/alter"}},s={},p=[{value:"CREATE NODE TABLE",id:"create-node-table",level:2},{value:"CREATE REL TABLE",id:"create-rel-table",level:2},{value:"Relationship Multiplicities",id:"relationship-multiplicities",level:3},{value:"CREATE REL TABLE GROUP",id:"create-rel-table-group",level:2},{value:"Notes",id:"notes",level:4}],d={toc:p},c="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"create"},"CREATE"),(0,r.kt)("p",null,"As a first step to creating your database, you need to define your node and directed relationships. In the property graph model, nodes and relationships have labels. In K\xf9zu, every node or relationship can have 1 label. The node and relationships and the predefined properties on them are defined through ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE NODE TABLE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE REL TABLE"),' commands. The choice of using the term "table" over "label" is intentional and explained below',(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"."),(0,r.kt)("h2",{id:"create-node-table"},"CREATE NODE TABLE"),(0,r.kt)("p",null,"The following statement defines a table of User nodes. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE NODE TABLE User(name STRING, age INT64, reg_date DATE, PRIMARY KEY (name))\n")),(0,r.kt)("p",null,"This adds a User table to the catalog of the system with 3 predefined properties. During querying, the name of the table will serve as the label of the nodes, e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (a:User) RETURN sum(a.age)")," returns the sum of the ages of all User nodes in the system. "),(0,r.kt)("p",null,"K\xf9zu requires a primary key column for node table which can be either a ",(0,r.kt)("inlineCode",{parentName:"p"},"STRING")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"INT64")," property of the node. K\xf9zu will generate an index to do quick lookups on the primary key (e.g., name in the above example). Alternativly, you can use ",(0,r.kt)("a",{parentName:"p",href:"/docusaurus/cypher/data-types/serial"},(0,r.kt)("inlineCode",{parentName:"a"},"SERIAL")," data type")," to generate an auto-increment column as primary key."),(0,r.kt)("h2",{id:"create-rel-table"},"CREATE REL TABLE"),(0,r.kt)("p",null,"The following statement adds to the catalog a Follows relationship table between User and User with one date property. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE REL TABLE Follows(FROM User TO User, since DATE)\n")),(0,r.kt)("p",null,"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"There is no comma between the FROM and TO clauses. "),(0,r.kt)("li",{parentName:"ul"},"Relationship directions: Each relationship has a direction following the property graph model. So when Follows relationship records are added, each one has a specific source/from node and a specific destination/to node",(0,r.kt)("sup",{parentName:"li",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"."),(0,r.kt)("li",{parentName:"ul"},'Relationship primary keys: You cannot define a primary key for relationship records. Each relationship gets a unique system-level edge ID, which are internally generated. You can check if two edges are the same, i.e., have the same edge ID, using the "=" and "!=" operator between "ID()" function on two variables that bind to relationships. For example, you can query ',(0,r.kt)("inlineCode",{parentName:"li"},"MATCH (n1:User)-[r1:Follows]->(n2:User)<-[r2:Follows]-(n3:User) WHERE ID(r1) != ID(r2) RETURN *")," to ensure that the same relationship does not bind to both r1 and r2."),(0,r.kt)("li",{parentName:"ul"},"Relationship can only be defined as being from one node table/label to one node table/label.")),(0,r.kt)("h3",{id:"relationship-multiplicities"},"Relationship Multiplicities"),(0,r.kt)("p",null,"For any relationship label E, e.g., , by default there can be multiple relationships from any node v both in the forward and backward direction. In database terminology, relationships are by default many-to-many. For example in the first Follows example above: (i) any User node v can follow multiple User nodes; and (ii) be followed by multiple User nodes. You can also constrain the multiplicity to ",(0,r.kt)("em",{parentName:"p"},"at most 1")," (we don't yet support exactly 1 semantics as in foreign key constraints in relational systems)  in either direction. You can restrict the multiplicities for two reasons: "),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Constraint: Multiplicities can serve as constraints you would like to enforce (e..g, you want K\xf9zu to error if an application tries to add a second relationship of a particular label to some node)"),(0,r.kt)("li",{parentName:"ol"},"Performance: K\xf9zu can store 1-to-1, many-to-1, or 1-to-many relationships (explained momentarily) in more efficient/compressed format, which is also faster to scan. ")),(0,r.kt)("p",null,"You can optionally declare the multiplicity of relationships by adding MANY_MANY, ONE_MANY, MANY_ONE, or ONE_ONE clauses to the end of the CREATE REL TABLE command.\nHere are a few  example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE REL TABLE LivesIn(FROM User TO City, MANY_ONE)\n")),(0,r.kt)("p",null,'The above ddl indicates that LivesIn has n-1 multiplicity. This command puts an additional constraint that each User node v might LiveIn at most 1 City node (assuming our database has City nodes). It does not put any constraint in the "backward" direction, i.e., there can be multiple Users living in the same City. As another example to explain the semantics of multiplicity constraints in the presence of multiple node labels, consider this: '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE REL TABLE Likes(FROM Pet TO User, ONE_MANY)\n")),(0,r.kt)("p",null,"The above ddl indicates that Likes has 1-to-n multiplicity. This ddl command puts the constraint: that each User node v might be Liked by one Pet node. It does not put any constraint in the forward direction, i.e., each Pet node might know multiple Users."),(0,r.kt)("p",null,'In general in a relationship E\'s multiplicity, if the "source side" is "ONE", then for each node v that can be the destination of E relationships, v can have at most 1 backward edge. If the "destination side" is ONE, then each node v that can be the source of E relationships, v can have at most 1 forward edge. '),(0,r.kt)("h2",{id:"create-rel-table-group"},"CREATE REL TABLE GROUP",(0,r.kt)("sup",{parentName:"h2",id:"fnref-3"},(0,r.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,r.kt)("p",null,"K\xf9zu limits relationship tables to be defined over a pair of node tables for a simple storage design. This, however, limits the flexiblity of data modelling. To define a relationship table with multiple node table pairs, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE REL TABLE GROUP")," statement in a similar syntax as ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE REL TABLE")," but with multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM ... TO ..."),". This statement will create a relationship table for each ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM ... TO ...")," internally. User can query with rel table group as the union of all rel tables in the group."),(0,r.kt)("h4",{id:"notes"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Currently, K\xf9zu does not allow ",(0,r.kt)("inlineCode",{parentName:"li"},"COPY FROM")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"CREATE")," using rel table group. You need explicitly specify a rel table.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE REL TABLE GROUP Knows (FROM User To User, FROM User to City, year INT64);\n")),(0,r.kt)("p",null,"The statement above creates a Knows_User_User rel table and a Knows_User_City rel table. And a Knows rel table group refering these two rel tables. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CALL SHOW_TABLES() RETURN *;\n----------------------------------------------\n| TableName       | TableType | TableComment |\n----------------------------------------------\n| Knows           | REL_GROUP |              |\n----------------------------------------------\n| Knows_User_City | REL       |              |\n----------------------------------------------\n| Knows_User_User | REL       |              |\n----------------------------------------------\n| User            | NODE      |              |\n----------------------------------------------\n| City            | NODE      |              |\n----------------------------------------------\n")),(0,r.kt)("p",null,"Rel table group can be used as a regular rel table when querying. K\xf9zu will compile rel table group as the union of all rel tables under the group."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[:Knows]->(b) RETURN *;\n")),(0,r.kt)("p",null,"The query above is equivalent to "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"MATCH (a:User)-[:Knows_User_User|:Knows_User_city]->(b) RETURN *;\n")),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},'We prefer the term "table" instead of "label" because K\xf9zu, as well as other GDBMSs are ultimately relational systems in the sense that they store and process sets of tuples, i.e., tables or relations. A good way to understand the property graph model is as tagging your tables as "node" and "relationship tables" depending on their roles in your application data. Nodes are generally suitable to represent entities in your applications, while relationships represent the relationships/connections. Relationships are the primary means to join nodes with each other to find paths and patterns in your graph database. So when you define a node label and a set of nodes/relationships, this is equivalent to defining a table or records as nodes or relationships. During querying you can bind node records in syntax like (a:Person), while relationships in syntax like (..)-',"[e:Knows]","->(...). Similar to table definitions in SQL, node and relationship tables have primary keys, a term that is defined in the context of tables: node tables explicitly define primary keys as one of their properties, while the primary keys of relationship tables are implicitly defined by the primary keys of their FROM and TO node records. Further observe that similar to relational systems, properties can be thought equivalently as columns of a table, justifying our choice of using the term table in these definitions.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},"We have currently not decided if K\xf9zu will support undirected edges or support it in a way similar to Neo4j, which always forces directed edges but allow querying in an undirected way. See ",(0,r.kt)("a",{parentName:"li",href:"https://neo4j.com/docs/cypher-manual/current/introduction/uniqueness/"},"examples here"),' for the details how Neo4j supports "undirected querying", which matches edges from both directions.',(0,r.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-3"},"This is an experimental feature and might be changed in the future.",(0,r.kt)("a",{parentName:"li",href:"#fnref-3",className:"footnote-backref"},"\u21a9")))))}u.isMDXComponent=!0}}]);