<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://your-docusaurus-test-site.com/docusaurus/blog</id>
    <title>Kùzu Documentations Blog</title>
    <updated>2023-07-10T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://your-docusaurus-test-site.com/docusaurus/blog"/>
    <subtitle>Kùzu Documentations Blog</subtitle>
    <icon>https://your-docusaurus-test-site.com/docusaurus/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Kùzu 0.0.5 Release]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.5-release</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.5-release"/>
        <updated>2023-07-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release Kùzu 0.0.5 today! This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release Kùzu 0.0.5 today! This release comes with the following new main features and improvements: </p><ul><li><a href="/docusaurus/blog/kuzu-0.0.5-release#cypher-features">Cypher Features</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.5-release#named-path">Named Path</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#filters-of-relationships-in-recursive-patterns">Filters of Relationships in Recursive Patterns</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#all-shortest-paths">All Shortest Paths</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#call-clause"><code>Call</code> Clause</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#modifying-database-configurations">Modifying Database Configuration</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#data-types">Data Types</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.5-release#blob"><code>BLOB</code></a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#client-apis-rust-and-java">Client APIs: Rust and Java</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#development-testing-framework">Development:Testing Framework</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cypher-features">Cypher Features<a href="#cypher-features" class="hash-link" aria-label="Direct link to Cypher Features" title="Direct link to Cypher Features">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="named-paths">Named Paths<a href="#named-paths" class="hash-link" aria-label="Direct link to Named Paths" title="Direct link to Named Paths">​</a></h3><p>This releases introduces named paths. Users can now assign a named variable to a connected graph pattern. For example, the following query returns all path between <code>Adam</code> and <code>Karissa</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows]-&gt;(b:User) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' AND b.name = 'Karissa' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Named paths can also be assigned to recursive graph patterns as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2]-&gt;(:User)-[:LivesIn]-&gt;(:City) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>One can also assign multiple named paths in a <code>MATCH</code> clause</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p1 = (a:User)-[:Follows]-&gt;(b:User), p2 = (b)-[:LivesIn]-&gt;(:City) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p1, p2;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Internally, a path is processed as a <code>STRUCT</code> with two fields, a nodes field with key <code>_NODES</code> and type <code>LIST[NODE]</code> and a rels field with key <code>_RELS</code> and type <code>LIST[REL]</code>. See <a href="https://kuzudb.com/docusaurus/cypher/data-types/path" target="_blank" rel="noopener noreferrer"><code>PATH</code></a> for details. Users can access nodes and rels field with <code>nodes(p)</code> and <code>rels(p)</code> function calls as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2]-&gt;(:User) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN nodes(p), (rels(p)[1]).since;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="filters-of-relationships-in-recursive-patterns">Filters of Relationships in Recursive Patterns<a href="#filters-of-relationships-in-recursive-patterns" class="hash-link" aria-label="Direct link to Filters of Relationships in Recursive Patterns" title="Direct link to Filters of Relationships in Recursive Patterns">​</a></h3><p>Users can now put predicates on the relationships that will be "traversed/joined" in recursive patterns.
For example, the following query finds the name of users that are followed by Adam directly or indirectly through 2 hops where <em>the following started before 2022 (r.since &lt; 2022 predicate)</em>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2 (r, _ | WHERE r.since &lt; 2022)]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN DISTINCT b.name;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Our filter grammar follows <a href="https://memgraph.com/docs/memgraph/reference-guide/built-in-graph-algorithms" target="_blank" rel="noopener noreferrer">Memgraph's syntax</a>. The first variable <code>r</code> in the <code>(r, _ | WHERE r.since &lt; 2022)</code> predicate binds to the relationships in the recursive pattern and the <code>_</code> binds to the nodes. Since we currently don't allow filters on recursive nodes, the second variable must be <code>_</code> for now.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="all-shortest-paths">All Shortest Paths<a href="#all-shortest-paths" class="hash-link" aria-label="Direct link to All Shortest Paths" title="Direct link to All Shortest Paths">​</a></h3><p>Kùzu now supports all shortest paths semantic with key word <code>ALL SHORTEST</code>. The following query finds all shortest paths of up to length 3 between <code>Zhang</code> and <code>Waterloo</code> considering relationships of all labels (i.e., this is an unlabeled query and you can restrict the labels by adding them as <code>[:Follows* ALL SHORTEST 1..3]</code>).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a)-[* ALL SHORTEST 1..3]-(b) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Zhang' AND b.name = 'Waterloo' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="https://kuzudb.com/docusaurus/cypher/query-clauses/match#all-shortest-path" target="_blank" rel="noopener noreferrer">All Shortest Paths</a> on our documentation for more information.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="call-clause"><code>Call</code> Clause<a href="#call-clause" class="hash-link" aria-label="Direct link to call-clause" title="Direct link to call-clause">​</a></h3><p>This release introduces <code>Call</code> as a reading clause. Similar to <a href="https://neo4j.com/docs/cypher-manual/current/clauses/call/" target="_blank" rel="noopener noreferrer">Neo4j</a>, <code>Call</code> clause is used to execute procedures. The release also contains a set of predefined procedures that can be used to query the database schemas. For example, the following query returns all metadata of <code>User</code> table:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL table_info('User') RETURN *;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| property id | name | type   | primary key |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| 0           | name | STRING | True        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| 1           | age  | INT64  | False       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>Call</code> can be used together with other clauses in the same way as a reading clause:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL table_info('User') WITH * WHERE name STARTS WITH 'a' RETURN name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| name |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| age  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>More built in procedures can be found <a href="https://kuzudb.com/docusaurus/cypher/query-clauses/call" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="modifying-database-configurations">Modifying Database Configurations<a href="#modifying-database-configurations" class="hash-link" aria-label="Direct link to Modifying Database Configurations" title="Direct link to Modifying Database Configurations">​</a></h2><p><code>CALL</code> has another usage: you can now modify database configurations through a <code>Call param=x</code> pattern. For example, the following sets the maximum number of threads for query execution to 5:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL THREADS=5;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>More configuration options can be found <a href="https://kuzudb.com/docusaurus/cypher/configuration" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-types">Data Types<a href="#data-types" class="hash-link" aria-label="Direct link to Data Types" title="Direct link to Data Types">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="blob"><code>BLOB</code><a href="#blob" class="hash-link" aria-label="Direct link to blob" title="Direct link to blob">​</a></h3><p>We have also added the <code>BLOB</code> type to store arbitrary binary objects. Here is an example query returning a blob:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">RETURN BLOB('\\xBC\\xBD\\xBA\\xAA') as result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| result                                    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| \xBC\xBD\xBA\xAA                          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>More information on the blob data type can be found <a href="https://kuzudb.com/docusaurus/cypher/data-types/blob" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="client-apis-rust-and-java">Client APIs: Rust and Java<a href="#client-apis-rust-and-java" class="hash-link" aria-label="Direct link to Client APIs: Rust and Java" title="Direct link to Client APIs: Rust and Java">​</a></h2><p>In this release, we're expanding the accessibility of Kùzu, bridging the gap with some of the most popular programming languages in the developer community. Specifically, we now have <a href="https://kuzudb.com/docusaurus/client-apis/rust" target="_blank" rel="noopener noreferrer">Rust</a> and <a href="https://kuzudb.com/docusaurus/client-apis/java" target="_blank" rel="noopener noreferrer">Java</a> APIs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="development-testing-framework">Development: Testing Framework<a href="#development-testing-framework" class="hash-link" aria-label="Direct link to Development: Testing Framework" title="Direct link to Development: Testing Framework">​</a></h2><p>Starting with this release, we're adding some development guidelines to encourage and facilitate outside contributions from the broader open source community.</p><p>Testing is a crucial part of Kùzu to ensure the correct functioning of the system.
In this release, we've implemented significant changes to our testing framework. Our approach to testing is rooted in the principle of end-to-end tests rather than individual unit tests.
Whenever possible, we route all tests in the end-to-end way through Cypher statements.
To this end, we've designed a custom testing framework that enables thorough end-to-end testing via Cypher statements.</p><p>Our testing framework draws inspiration from <a href="https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki" target="_blank" rel="noopener noreferrer">SQLLogicTest</a>, albeit with customized syntax tailored to our needs.
For a more detailed overview of our testing framework, please visit <a href="https://kuzudb.com/docusaurus/development/testing-framework" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>Kùzu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kùzu 0.0.4 Release]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.4-release</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.4-release"/>
        <updated>2023-06-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release Kùzu 0.0.4 today! This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release Kùzu 0.0.4 today! This release comes with the following new main features and improvements: </p><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#data-ingestion-improvements">Data Ingestion Improvements</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#new-cypher-features">New Cypher Features</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#undirected-relationships-in-queries">Undirected Relationships in Queries</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#recursive-queries-shortest-path-queries-and-improved-variable-length-queries">Recursive Queries: Shortest Path Queries and Improved Variable-length Queries</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#new-data-types">New Data Types</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#serial"><code>SERIAL</code></a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#struct"><code>STRUCT</code></a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#client-apis">Client APIs</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#windows-compatibility">Windows compatibility</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#c">C</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#nodejs">Node.js</a></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-ingestion-improvements">Data Ingestion Improvements<a href="#data-ingestion-improvements" class="hash-link" aria-label="Direct link to Data Ingestion Improvements" title="Direct link to Data Ingestion Improvements">​</a></h2><p>We continue to improve our data ingestion in this release.
We still rely on Apache Arrow to parse parquet and csv files.
Several bottlenecks in our earlier implementation are identified and optimized now, including copying from arrow arrays and construction of hash indexes.
We now also store null bits separately, which simplifies our loading logic and makes it faster.</p><p>Here are some benchmark numbers for loading two node and two rel tables that only contain primitive types or strings from the LDBC benchmark:</p><ul><li>CPU: MAC M1 MAX</li><li>Disk: 2TB SSD</li><li>System Memory: 32GB</li><li>Dataset: LDBC-100</li><li>Number of thread: 10</li></ul><table><thead><tr><th>Files</th><th># lines</th><th>file size</th><th>v0.0.3</th><th>v0.0.4</th></tr></thead><tbody><tr><td>comment.csv</td><td>220M</td><td>22.49 GB</td><td>890s</td><td><strong>108s (8.2x)</strong></td></tr><tr><td>post.csv</td><td>58M</td><td>7.68 GB</td><td>304s</td><td><strong>32s (9.5x)</strong></td></tr><tr><td>likesComment.csv</td><td>242M</td><td>13 GB</td><td>772s</td><td><strong>142s (5.4x)</strong></td></tr><tr><td>knows.csv</td><td>20M</td><td>1.1 GB</td><td>80s</td><td><strong>21s (3.8x)</strong></td></tr></tbody></table><p>Besides performance improvement, we now also allow interrupting <code>COPY</code> statements in the shell.
You can interrupt long running <code>COPY</code> statements without crashing the shell.</p><p>We will continue to improve our data ingestion to make it more efficient and robust as we're moving to the <a href="https://github.com/kuzudb/kuzu/issues/1474" target="_blank" rel="noopener noreferrer">new storage design</a> in the coming releases. Please stay tuned!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-cypher-features">New Cypher Features<a href="#new-cypher-features" class="hash-link" aria-label="Direct link to New Cypher Features" title="Direct link to New Cypher Features">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="undirected-relationships-in-queries">Undirected Relationships in Queries<a href="#undirected-relationships-in-queries" class="hash-link" aria-label="Direct link to Undirected Relationships in Queries" title="Direct link to Undirected Relationships in Queries">​</a></h3><p>Kùzu now supports undirected relationships in Cypher queries. An undirected relationship is the union of both in-coming and out-going relationships. This feature is mostly useful in the following two cases. </p><p><strong>Case 1: Relationship is undirected by nature</strong>
Relationships between nodes in Kùzu are currently directed (though we are internally debating to add a native undirected relationship type). A relationship file must contain <code>FROM</code> and <code>TO</code> columns each of which refers to a primary key column of a node table. However, sometimes the nature of the relationships are undirected, e.g., an <code>isFriendOf</code> relationships in a social network. </p><p>Currently, you have two options: (1) you can either store each friendship twice, e.g., <code>Alice isFriendOf Bob</code> and <code>Bob isFriendOf Alice</code>. This is a bad choice because internally Kùzu will index each edge twice (in the forward and backward) edges, so this one fact ends up getting stored 4 times. Or (2) you can store it once, say <code>Alice isFriendOf Bob</code>. </p><p>The advantage of option (1) was that in Kùzu v 0.0.3, if you want to find all friends of <code>Alice</code>, you could simply ask this query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[:isFriendOf]-&gt;(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice' RETURN b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Instead, if you chose option (2), you would have to ask two queries, one to <code>MATCH (a:Person)-[:isFriendOf]-&gt;(b:Person)</code> and the other to <code>MATCH (a:Person)&lt;-[:isFriendOf]-(b:Person)</code>, and <code>UNION</code> them, which gets messy if you want to do more with those neighbors (e.g., find their neighbors etc.). </p><p>With undirected edge support, you can now choose option (2) and find <code>Alice</code>'s friends with:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[:isFriendOf]-(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>So if you do not specify a direction in your relationships, Kùzu will automatically query both the forward and backward relationships for you.</p><p><em>Note from Kùzu developers: As noted above, we are debating a native undirected relationship type. That seems to solve the problem of, in which fake direction should an undirected relationship be saved at? Should be a <code>Alice-[isFriendOf]-&gt;Bob</code> or vice versa. Happy to hear your thoughts on this.</em></p><p><strong>Case 2: Relationship direction is not of interest</strong>
Although relationship is stored in a directed way, its direction may not be of interest in the query. The following query tries to find all comments that have interacted with comment <code>Kùzu</code>. These comments could be either replying to or replied by <code>Kùzu</code>. The query can be asked naturally in an undirected way.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (c:Comment)-[:replyOf]-(other:Comment)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE c.author = 'Kùzu'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN other;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-queries-shortest-path-queries-and-improved-variable-length-queries">Recursive Queries: Shortest Path Queries and Improved Variable-length Queries<a href="#recursive-queries-shortest-path-queries-and-improved-variable-length-queries" class="hash-link" aria-label="Direct link to Recursive Queries: Shortest Path Queries and Improved Variable-length Queries" title="Direct link to Recursive Queries: Shortest Path Queries and Improved Variable-length Queries">​</a></h3><p>This release brings in the beginnings of a series of major improvements we will do to recursive joins.
The two major changes in this release are: </p><p><strong>Multilabeled and undirected Variable-length Join Queries</strong>
Prior to this release we supported variable-length join queries only in the restricted case when the variable-length relationship could have a single relationship label and was directed. For example you could write this query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[:knows*1..2]-&gt;(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>But you couldn't ask for arbitrary labeled variable-length relationships between Persons <code>a</code> and <code>b</code> (though you
could write the non-recursive version of that query: <code>MATCH (a:Person)-[:knows]-&gt;(b:Person) ...</code>.
Similarly we did not support undirected version of the query: <code>MATCH (a:Person)-[:knows*1..2]-(b:Person)</code>.
Kùzu now supports multi-label as well as undirected variable-length relationships.
For example, the following query finds all nodes that are reachable within 1 to 3 hops from <code>Alice</code>, irrespective
of the labels on the connections or destination <code>b</code> nodes:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[e:*1..3]-(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Shortest path</strong></p><p>Finally, we got to implementing an initial version of shortest path queries. You can find (one of the) shortest paths between nodes by adding the <code>SHORTEST</code> keyword to a varible-length relationship. The following query asks for a shortest path between <code>Alice</code> and all active users that <code>Alice</code> follows within 10 hops and return these users, and the length of the shortest path.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[p:Follows* SHORTEST 1..10]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice' AND b.state = 'Active'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b, p, length(p)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>p</code> in the query binds to the sequences of relationship, node, relationship, node, etc. Currently we only return the internal IDs of the relationships and nodes (soon, we will return all their properties).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-data-types">New Data Types<a href="#new-data-types" class="hash-link" aria-label="Direct link to New Data Types" title="Direct link to New Data Types">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="serial"><code>SERIAL</code><a href="#serial" class="hash-link" aria-label="Direct link to serial" title="Direct link to serial">​</a></h3><p>This release introduces <code>SERIAL</code> data type. Similar to <code>AUTO_INCREMENT</code> supported by many other databases, <code>SERIAL</code> is mainly used to create
an incremental sequence of unique identifier column which can serve as a primary key column.</p><p>Example:</p><p><code>person.csv</code></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Alice</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bob</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Carol</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE NODE TABLE Person(ID SERIAL, name STRING, PRIMARY KEY(ID));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">COPY Person FROM `person.csv`;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person) RETURN a;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Output:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| a                                       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (label:Person, 3:0, {ID:0, name:Alice}) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (label:Person, 3:1, {ID:1, name:Bob})   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (label:Person, 3:2, {ID:2, name:Carol}) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When the primary key of your node tables are already consecutive integers starting from 0, you should omit the primary key column in the input file and make primary key a SERIAL type. This will improve loading time significantly. Similarly, queries that need to scan primary key will also get faster. That's because internally we will not store a HashIndex or primary key column so any scan over primary key will not trigger a disk I/O.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="struct"><code>STRUCT</code><a href="#struct" class="hash-link" aria-label="Direct link to struct" title="Direct link to struct">​</a></h3><p>Kùzu now supports <code>STRUCT</code> data type similar to <a href="https://www.postgresql.org/docs/current/rowtypes.html" target="_blank" rel="noopener noreferrer">composite type</a> in Postgres. Here is an example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">WITH {name:'University of Waterloo', province:'ON'} AS institution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN institution.name AS name;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Output:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| name                   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| University of Waterloo |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We support storing structs as node properties for now. For example you can create: <code>CREATE NODE TABLE Foo(name STRING, exStruct STRUCT(x INT16, y STRUCT(z INT64, w STRING)), PRIMARY KEY (name))</code>. We will support storing structs on relationships soon. As shown in the <code>CREATE NODE</code> example above, you can store arbitrarily
nested structs, e.g., structs that contain structs as a field, on nodes. One missing feature we have for now is storing and processing a <code>LIST&lt;STRUCT&gt;</code> composite type. </p><p><strong>Note</strong>: Updating <code>STRUCT</code> column with update statement is not supported in this release but will come soon.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="client-apis">Client APIs<a href="#client-apis" class="hash-link" aria-label="Direct link to Client APIs" title="Direct link to Client APIs">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="windows-compatibility">Windows compatibility<a href="#windows-compatibility" class="hash-link" aria-label="Direct link to Windows compatibility" title="Direct link to Windows compatibility">​</a></h3><p>Developers can now build Kùzu from scratch on Windows platform! Together with this release we also provide pre-built libraries and python wheels on Windows.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="c">C<a href="#c" class="hash-link" aria-label="Direct link to C" title="Direct link to C">​</a></h3><p>We provide official C language binding in this release. Developers can now embed Kùzu with native C interfaces.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nodejs">Node.js<a href="#nodejs" class="hash-link" aria-label="Direct link to Node.js" title="Direct link to Node.js">​</a></h3><p>We provide official Node.js language binding. With Node.js API, developer can leverage Kùzu analytical capability in their Node.js projects. We will
soon follow this blog post with one (or a few) blog posts on developing some applications with Node.js.</p>]]></content>
        <author>
            <name>Kùzu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scaling Pytorch Geometric GNNs With Kùzu]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-pyg-remote-backend</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-pyg-remote-backend"/>
        <updated>2023-05-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, we'll walk through how to use Kùzu as a Pytorch Geometric (PyG) Remote Backend to train a GNN model on very large graphs that do not fit on your machine's RAM.]]></summary>
        <content type="html"><![CDATA[<p>In this post, we'll walk through how to use Kùzu as a <a href="https://pytorch-geometric.readthedocs.io/en/latest/advanced/remote.html" target="_blank" rel="noopener noreferrer">Pytorch Geometric (PyG) <em>Remote Backend</em></a> to train a GNN model on very large graphs that do not fit on your machine's RAM. </p><p>Let's start with a quick overview of PyG Remote Backends: PyG Remote Backends are plug-in replacements for PyG's in-memory graph and feature stores, so they can be used seamlessly with the rest of the PyG interfaces to develop your GNN models. If a PyG Remote Backend is a disk-based storage system, such as Kùzu, PyG will fetch subgraphs from Kùzu, which stores and scans its data from disk, allowing you to train models on very large graphs for which PyG's in-memory storage would run out of memory and fail.</p><p>As you'll see, if you already have PyG models you have developed in Python, replacing PyG's default storage with Kùzu is extremely simple. <strong><em>It
consists of loading your graph into Kùzu and then changing 1 line of code in your PyG model</em></strong>. To demonstrate how simple this is and how it performs,
se will follow this <a href="https://github.com/pyg-team/pytorch_geometric/tree/master/examples/kuzu/papers_100M" target="_blank" rel="noopener noreferrer">Sample Code</a> to demonstrate how to do this.
So let's get to it!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="dataset-predictive-task-and-gnn-model">Dataset, Predictive Task, and GNN Model<a href="#dataset-predictive-task-and-gnn-model" class="hash-link" aria-label="Direct link to Dataset, Predictive Task, and GNN Model" title="Direct link to Dataset, Predictive Task, and GNN Model">​</a></h2><p>Let's start by describing our graph dataset, our predictive task, and the GNN model we will use for the predictive task.</p><p><strong>Dataset</strong>: We will use the <code>ogbn-papers100M</code> dataset of ~100M nodes and ~2.5B edges from the <a href="https://ogb.stanford.edu/" target="_blank" rel="noopener noreferrer">Open Graph Benchmark</a> (OGB). To find the dataset,
you can search for "ogbn-papers100M" <a href="https://ogb.stanford.edu/docs/nodeprop/" target="_blank" rel="noopener noreferrer">here</a>. The dataset takes about 128GB of RAM when using PyG's default in-memory storage. The graph's nodes and edges model the following:</p><p><em>Nodes</em> are papers that have these properties:</p><ul><li><code>ID</code>: an int64 node identifier</li><li><code>year</code>: the publication date of the paper (you can ignore this as it will not be used in our example but this property is part of the dataset)</li><li><code>x</code>: 128-dimensional node features (so 128-size float tensors)</li><li><code>y</code>: a numeric label indicating the category/field of the paper. These numbers indicate different <a href="https://arxiv.org/category_taxonomy" target="_blank" rel="noopener noreferrer">arXiv categories</a> for
papers. Although the exact mapping is not important, you can think of these for example as 0 indicating "physics", 2 indicating "geometry" etc.</li></ul><p><em>Edges/Relationships</em> are citations between papers and do not contain any properties.</p><p><strong>Predictive task:</strong> Predict the <code>y</code> labels of nodes using the node features stored in the <code>x</code> properties.</p><p><strong>GNN Model</strong>: We will train a 3-layer GraphSage model that contains 5.6 million parameters to perform this predictive task. Our model is based on the implementation <a href="https://github.com/mengyangniu/ogbn-papers100m-sage/tree/main" target="_blank" rel="noopener noreferrer">here</a>. We picked this model because it was one of the better-performing models in the <a href="https://ogb.stanford.edu/docs/leader_nodeprop/" target="_blank" rel="noopener noreferrer">PyG Leaderboard for the ogbn-papers100M dataset</a> (search "GraphSAGE_res_incep" under "Leaderboard for ogbn-papers100M") that we could develop using pre-existing layers in the PyG library (so we do not have to write any custom layers).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step-1-preliminaries-and-loading-ogbn-papers100m-into-kùzu">Step 1: Preliminaries and Loading ogbn-papers100M into Kùzu<a href="#step-1-preliminaries-and-loading-ogbn-papers100m-into-kùzu" class="hash-link" aria-label="Direct link to Step 1: Preliminaries and Loading ogbn-papers100M into Kùzu" title="Direct link to Step 1: Preliminaries and Loading ogbn-papers100M into Kùzu">​</a></h2><p>As a preliminary, the <a href="https://github.com/pyg-team/pytorch_geometric/blob/master/examples/kuzu/papers_100M/prepare_data.py" target="_blank" rel="noopener noreferrer"><code>prepare_data.py</code></a> script in <a href="https://github.com/pyg-team/pytorch_geometric/tree/master/examples/kuzu/papers_100M" target="_blank" rel="noopener noreferrer">Sample Code</a> generates four numpy files for each property of the papers: (i) <code>./ids.npy</code>; (ii) <code>./node_feat.npy</code> (storing <code>x</code> properties); (iii) <code>./node_year.npy</code>; and (iv) <code>./node_label.npy</code> (storing <code>y</code> labels). In addition, it will generate an <code>./edge_index.csv</code> file that stores the citation relationships. In the below code snippets, we will assume you have gone through those steps.</p><p>Let's start with how you load the <code>ogbn-papers100M</code> dataset into Kùzu. You will first need to define a <code>paper</code> NODE TABLE and a <code>cite</code> REL TABLE, whose schemas will follow exactly the structure of the dataset and then use <code>COPY FROM</code> statements in Kùzu's version of Cypher to ingest those numpy and csv files into your <code>paper</code> and <code>cite</code> tables:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import kuzu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Creating an empty Kùzu database under the papers100M directory...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db = kuzu.Database('papers100M')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn = kuzu.Connection(db, num_threads=cpu_count())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Creating Kùzu tables...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "CREATE NODE TABLE paper(id INT64, x FLOAT[128], year INT64, y FLOAT, "</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "PRIMARY KEY (id));")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute("CREATE REL TABLE cites (FROM paper TO paper, MANY_MANY);")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Copying nodes to Kùzu tables...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute('COPY paper FROM ("%s",  "%s",  "%s", "%s") BY COLUMN;' %</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ('./ids.npy', './node_feat.npy', './node_year.npy', './node_label.npy'))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Copying edges to Kùzu tables...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute('COPY cites FROM "%s";' % ('./edge_index.csv'))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("All done!")</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The one important note here is that you should store your node features using <a href="https://kuzudb.com/docs/cypher/data-types/list.html" target="_blank" rel="noopener noreferrer">Kùzu's FIXED-LIST data type</a> using <code>FLOAT[128]</code> syntax (instead of the less efficient VAR-LIST data type, which uses <code>FLOAT[]</code> syntax for lists that can have different lengths). FIXED-LIST is a data type that we specifically added to Kùzu to efficiently store node features and embeddings in graph ML applications.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step-2-get-kùzu-remote-backend-by-calling-dbget_torch_geometric_remote_backend">Step 2: Get Kùzu Remote Backend by Calling <code>db.get_torch_geometric_remote_backend()</code><a href="#step-2-get-kùzu-remote-backend-by-calling-dbget_torch_geometric_remote_backend" class="hash-link" aria-label="Direct link to step-2-get-kùzu-remote-backend-by-calling-dbget_torch_geometric_remote_backend" title="Direct link to step-2-get-kùzu-remote-backend-by-calling-dbget_torch_geometric_remote_backend">​</a></h2><p>After loading your data to Kùzu, the only thing you have to do is to call the <code>get_torch_geometric_remote_backend()</code> function on your Database object <code>db</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">feature_store, graph_store = db.get_torch_geometric_remote_backend(multiprocessing.cpu_count())</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This function returns two objects that implement PyG's Remote Backend interfaces: (i) <code>feature_store</code> is an instance of <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.FeatureStore.html#torch_geometric.data.FeatureStore" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data.FeatureStore</code></a>; and (ii) <code>graph_store</code> is an instance of <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.GraphStore.html#torch_geometric.data.GraphStore" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data.GraphStore</code></a>. These two handles are your Kùzu Remote Backends that you can pass to your PyG models/subgraph samplers and they will make your existing PyG models work seamllessly with Kùzu! That's all
you really have to know about how to use Kùzu as a Remote Backend. <strong><em>There is no more Kùzu functions you have to call in the rest of the demonstration. You only have
to do 1 line of code change in your regular PyG code.</em></strong>
The rest of the example contains standard code you normally write to develop your PyG models.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step-3-define--pass-kùzus-feature_store-and-graph_store-to-your-gnn-model">Step 3: Define &amp; Pass Kùzu's <code>feature_store</code> and <code>graph_store</code> to your GNN Model<a href="#step-3-define--pass-kùzus-feature_store-and-graph_store-to-your-gnn-model" class="hash-link" aria-label="Direct link to step-3-define--pass-kùzus-feature_store-and-graph_store-to-your-gnn-model" title="Direct link to step-3-define--pass-kùzus-feature_store-and-graph_store-to-your-gnn-model">​</a></h2><p>First, we'll define the GraphSage model in PyG. We'll put <code>...</code>'s here and there to shorten the example because, as we said above, this is your regular PyG code:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Define the model for training. The model is ported from</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># https://github.com/mengyangniu/ogbn-papers100m-sage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class SAGE(nn.Module):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, in_feats, n_hidden, n_classes, n_layers, activation,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 dropout):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super().__init__()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.n_layers = n_layers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def forward(self, edge_list, x):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for layer_index, layer in enumerate(self.layers):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return self.mlp(collect)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Next, we will enable PyG to use Kùzu's Remote Backend when training. We create a <a href="https://pytorch-geometric.readthedocs.io/en/latest/_modules/torch_geometric/loader/neighbor_loader.html" target="_blank" rel="noopener noreferrer"><code>torch_geometric.loader.NeighborLoader</code></a>, which is the subgraph sampler we will use, and pass the <code>feature_store</code> and <code>graph_store</code> we obtained from Kùzu to it. <strong><em>This is the 1 line change you have to do!</em></strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Plug the graph store and feature store into the NeighborLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu_sampler = NeighborLoader(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data=(feature_store, graph_store),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num_neighbors={('paper', 'cites', 'paper'): [12, 12, 12]},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    batch_size=LOADER_BATCH_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_nodes=('paper', input_nodes),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num_workers=4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filter_per_worker=False,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong><code>data=(feature_store, graph_store)</code></strong> is the important line. When you use this sampler in training to construct mini-batches, it will perform subgraph sampling and load the required node features from Kùzu automatically and return a <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.HeteroData.html" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data.HeteroData</code></a> object, which can be directly plugged into a GNN model. That training code looks like this (again abbreviated because this is all PyG code):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">model = SAGE(128, 1024, 172, 3, torch.nn.functional.relu, 0.2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">criterion = torch.nn.CrossEntropyLoss()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for epoch in range(NUM_EPOCHS):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    start_time = time.time()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // **The below for loop line is where we ask the sampler to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sample a mini batch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for b in kuzu_sampler:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x = b['paper']['x']</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y = b['paper']['y']</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        edge_index = b['paper', 'cites', 'paper'].edge_index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        model.train()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        optimizer.zero_grad()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out = model(edge_index, x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loss = criterion(out, y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loss.backward()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        optimizer.step()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>for b in kuzu_sampler:</code> is the exact line where the sampler will end up calling on Kùzu to sample a subgraph and scan the features of the nodes in that subgraph. This all ends up using Kùzu's disk-based storage, allowing you to train GNNs on graphs that don't fit on your RAM. One distinct advantage of Kùzu is that, because it is an embeddable DBMS,
we can do the conversion of scanned node features from Kùzu into PyG's tensors as a zero-copy operation. We simply write the scanned node features into a buffer array allocated in Python without any additional data transfer between the systems.</p><p>Currently, only the <code>feature_store</code> scans data from Kùzu's disk-based storage. For <code>graph_store</code>, our current implementation stores the entire graph topology in COO format in memory. This does limit how much you can scale, but in many models trained on large graphs, features take up more space than the graph topology, so scaling node features out of memory should still allow you to scale to very lage graphs that won't fit in your RAM.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="adjusting-kùzus-buffer-pool-size">Adjusting Kùzu's Buffer Pool Size<a href="#adjusting-kùzus-buffer-pool-size" class="hash-link" aria-label="Direct link to Adjusting Kùzu's Buffer Pool Size" title="Direct link to Adjusting Kùzu's Buffer Pool Size">​</a></h3><p>As with most DBMSs, Kùzu has a Buffer Manager that maintains a buffer pool to keep parts of the database in memory. When you use Kùzu, you decide how much memory to allocate to it. The more memory you give to Kùzu, the less I/O it will perform on scans. So, in the context of this post, the larger the buffer manager size you set, the faster your training time will be when training large graphs out of memory. You set Kùzu's buffer pool size when you construct your <code>Database</code> object, before you call the <code>get_torch_geometric_remote_backend()</code> function. For example, the code below sets the BM size to <code>40 * 1024**3</code> bytes, which is equal to 40GB. You should set it as high as possible without running out of memory for performance reasons.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">KUZU_BM_SIZE = 40 * 1024**3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Create kuzu database</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db = kuzu.Database("papers100M", KUZU_BM_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">feature_store, graph_store = db.get_torch_geometric_remote_backend(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mp.cpu_count())</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="an-experiment-demonstrating-throughput-numbers-with-different-buffer-pool-sizes">An Experiment Demonstrating Throughput Numbers With Different Buffer Pool Sizes<a href="#an-experiment-demonstrating-throughput-numbers-with-different-buffer-pool-sizes" class="hash-link" aria-label="Direct link to An Experiment Demonstrating Throughput Numbers With Different Buffer Pool Sizes" title="Direct link to An Experiment Demonstrating Throughput Numbers With Different Buffer Pool Sizes">​</a></h2><p>Let's demonstrate what troughput numbers you can expect under different memory settings.
As a baseline we will first measure the throughput of training
as time/batch using PyG's default in-memory
storage. This seting uses ~106GB of memory.
We will then simulate limited memory settings by training the same
model using Kùzu Remote Backend and limiting Kùzu's buffer pool size to
different levels.
Here are the important configurations for the experiment:</p><ul><li>Available RAM in the machine: 384GB RAM</li><li>CPU: Two Xeon Platinum 8175M (48 cores/96 threads)</li><li>GPU: RTX 4090 with 24GB GPU memory</li><li>SSD in the system for disk storage: 2TB Kingston KC3000 NVMe SSD</li><li>Mini-batch size: 1152. Recall the <code>kuzu_sampler = NeighborLoader(...)</code> that we defined above. There we gave this argument
<code>num_neighbors={('paper', 'cites', 'paper'): [12, 12, 12]}</code> to the <code>NeighborLoader</code>, which means that the sampler will sample 3-degree neighbors of these 1152 nodes,
sampling 12 neighbors at each degree.
We picked 1152 as our mini-batch size because this is the size at which we generate batches that take a peak of 23GB of memory, so beyond this we would run out of GPU memory. <sup id="fnref-1-5f0073"><a href="#fn-1-5f0073" class="footnote-ref">1</a></sup></li><li>#<!-- --> PyG Workers: 16 (we did a parameter sweep and setting this to 4, 8, 16 perform very similarly)</li><li>#<!-- --> Kùzu Query Processor Threads: 24 (48 and 96 also perform similarly)</li></ul><p>We will run Kùzu with 60GB, 40GB, 20GB, and 10GB buffer pool size.
The lower Kùzu's buffer pool size, the more
disk I/Os Kùzu will perform. Note however that in this experiment Kùzu will use more memory than
these sizes for two reasons: (i) Kùzu stores some parts of the database always in memory
though this is not very important in this setting; (ii) As we said, currently
Kùzu Remote Backend uses in-memory storage for the graph topology (but not node features!),
which takes ~48GB of RAM. So you can roughly think of Kùzu using 48 + BM size in these experiments.</p><p>We will do 500 batches of training and report the throughput number as average end-to-end time/batch.
We also report the time that's spent on GPU for Training as <code>Training Time (s)</code> and
time spent on copying data from CPU to GPU as <code>CPU-to-GPU Copying Time (s)</code>. For
Kùzu configurations, you can roughly
interpret <code>Per Batch Time (s) -  Training Time (s) -  CPU-to-GPU Copying Time (s)</code>
as the time spent for scanning data from Kùzu into CPU's memory. We expect that to increase
as we lower the BM size.</p><table><thead><tr><th>Configuration</th><th>Per Batch Time (s)</th><th>Training Time (s)</th><th>CPU-to-GPU Copying Time</th><th>Time Scanning Data from Kùzu</th><th>Memory Usage</th></tr></thead><tbody><tr><td>PyG In-memory</td><td>0.281</td><td>0.240</td><td>0.024</td><td>---</td><td>~110 GB</td></tr><tr><td>Kùzu Remote Backend (bm=60GB)</td><td>0.380 (1.35x)</td><td>0.239</td><td>0.018</td><td>0.123</td><td>~110 GB</td></tr><tr><td>Kùzu Remote Backend (bm=40GB)</td><td>0.513 (1.82x)</td><td>0.239</td><td>0.022</td><td>0.251</td><td>~90 GB</td></tr><tr><td>Kùzu Remote Backend (bm=20GB)</td><td>1.162 (4.88x)</td><td>0.238</td><td>0.022</td><td>0.901</td><td>~70 GB</td></tr><tr><td>Kùzu Remote Backend (bm=10GB)</td><td>1.190 (4.23x)</td><td>0.238</td><td>0.022</td><td>0.930</td><td>~60 GB</td></tr></tbody></table><p>So, when have enough memory, there is about 1.35x slow down (from 0.281s to 0.380s per batch)
compared to using PyG's default storage. This
is the case when Kùzu has enough buffer memory (60GB) to store the features but we still incur the cost of
scanning them through Kùzu's buffer manager. So no disk I/O happens (except the first time
the features are scanned to the buffer manager). When we use 40GB of buffer pool and below, we start doing some I/O,
and the average time per batch degrade to 0.513, 1.162, amd 1.190 respectively when using 40GB, 20GB, and 10GB.
We seem to stabilize around 4x degradation at 10GB or 20GB level, where most of the feature scans
are now happening from disk. These numbers hopefully look good for many settings!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="next-steps">Next Steps<a href="#next-steps" class="hash-link" aria-label="Direct link to Next Steps" title="Direct link to Next Steps">​</a></h2><p>We will be doing 2 immediate optimizations in the next few releases
related to Kùzu's PyG integration.
First, we will change our <code>graph_store</code> to use an in DBMS subgraph sampler, so we can virtually work at any limited memory level.
Second, in an even earlier release, we had a more basic PyG integration feature, the
<a href="https://kuzudb.com/docs/client-apis/python-api/query-result.html#query_result.QueryResult.get_as_torch_geometric" target="_blank" rel="noopener noreferrer"><code>QueryResult.get_as_torch_geometric()</code></a> function.
This feature is more of an ETL feature. It is designed for cases where you want to filter
a subset of your nodes and edges and convert them directly into PyG <code>HeteroData</code> objects (i.e., use PyG's default in-memory storage)
as you build PyG pipelines using graph databases you store in Kùzu.
If you are converting a large graph this can be quite slow, and we will be improving this so that such ETL pipelines
are much faster!</p><p>We are excited to hear about your feedback on Kùzu's PyG integration features and get more ideas about
how else we can help users who are building GNN pipelines. Please reach out to us over <a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" target="_blank" rel="noopener noreferrer">Kùzu Slack</a>
for your questions and ideas!.</p><div class="footnotes"><hr><ol><li id="fn-1-5f0073">If you read our <a href="https://kuzudb.com/blog/kuzu-0.0.3-release.html#k%C3%B9zu-as-a-pyg-remote-backend" target="_blank" rel="noopener noreferrer">v0.0.3 blog post</a>,
which had a shorter section about PyG interface, you will notice that we used a much larger batch size there (48000),
which was the size that saturated GPU memory. Although the example there was also on the <code>ogbn-papers100M</code> dataset, we used a much smaller model with ~200K parameters
and sampled subgraphs from 2 degree neighbors of these batches. Now we use a much larger model with 5.6 million parameters and samples from 3-degree neighbors.<a href="#fnref-1-5f0073" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Chang Liu</name>
            <uri>https://www.linkedin.com/in/mewim/</uri>
        </author>
        <author>
            <name>Semih Salihoğlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="use-case" term="use-case"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kùzu 0.0.3 Release]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.3-release</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.3-release"/>
        <updated>2023-04-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are happy to release Kùzu 0.0.3 today. This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are happy to release Kùzu 0.0.3 today. This release comes with the following new main features and improvements:</p><ul><li><a href="/docusaurus/blog/kuzu-0.0.3-release#k%C3%B9zu-as-a-pyg-remote-backend">Kùzu as a Pytorch Geometric (PyG) Remote Backend</a>: You can now train PyG GNNs and other models directly using graphs (and node features) stored on Kùzu.  See this <a href="https://colab.research.google.com/drive/12fOSqPm1HQTz_m9caRW7E_92vaeD9xq6" target="_blank" rel="noopener noreferrer">Colab notebook</a>
for a demonstrative example. </li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#data-ingestion-improvements">Data ingestion from multiple files and numpy files</a>: See below for details</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#query-optimizer-improvements">Query optimizer improvements</a>: See below for details</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#new-buffer-manager">New buffer manager</a>: A new state-of-art buffer manager based on <a href="https://www.cs.cit.tum.de/fileadmin/w00cfj/dis/_my_direct_uploads/vmcache.pdf" target="_blank" rel="noopener noreferrer">VMCache</a>.</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#new-data-types">INT32, INT16, FLOAT, and FIXED LIST data types</a> (the latter is particularly suitable to store node features in graph ML applications)</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#other-system-functionalities">Query timeout mechanism and interrupting queries from CLI</a>.</li></ul><p>For installing the new version,
please visit the <a href="https://kuzudb.com/#download" target="_blank" rel="noopener noreferrer">download section of our website</a>
and <a href="https://kuzudb.com/docs/getting-started.html" target="_blank" rel="noopener noreferrer">getting started guide</a> and the full
<a href="https://github.com/kuzudb/kuzu/releases" target="_blank" rel="noopener noreferrer">release notes are here</a>. Please visit
the <a href="https://kuzudb.com/docs/getting-started/colab-notebooks" target="_blank" rel="noopener noreferrer">Colab Notebooks</a> section of our
documentation website to play with our <a href="https://kuzudb.com/docs/getting-started/colab-notebooks" target="_blank" rel="noopener noreferrer">Colab notebooks</a>.</p><p>Enjoy! Please give us a try, <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">a Github ⭐</a> and your feedback and feature requests! Also follow
us on <a href="https://twitter.com/kuzudb" target="_blank" rel="noopener noreferrer">Twitter</a>!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="kùzu-as-a-pyg-remote-backend">Kùzu as a PyG Remote Backend<a href="#kùzu-as-a-pyg-remote-backend" class="hash-link" aria-label="Direct link to Kùzu as a PyG Remote Backend" title="Direct link to Kùzu as a PyG Remote Backend">​</a></h2><p>Kùzu now implements PyG's Remote Backend interface. So you can directly
train GNNs using Kùzu as your backend storage. Quoting <a href="https://pytorch-geometric.readthedocs.io/en/latest/advanced/remote.html" target="_blank" rel="noopener noreferrer">PyG documentation's</a> description
of the Remote Backend feature:</p><blockquote><p>...<!-- -->[this feature enables]<!-- --> users to train GNNs on graphs far larger than the size of their
machine’s available memory. It does so by introducing simple, easy-to-use, and extensible abstractions of a <code>torch_geometric.data.FeatureStore</code> and a   <code>torch_geometric.data.GraphStore</code> that plug directly into existing familiar PyG interfaces.</p></blockquote><p>With our current release, once you store your graph and features in Kùzu,
PyG's samplers work seamlessly using Kùzu's implementation of <code>FeatureStore</code> and <code>GraphStore</code> interfaces. For example,
this enables your existing GNN models to work seamlessly by fetching both subgraph samples and node features
from Kùzu instead of PyG's in-memory storage.
Therefore you can train graphs that do not
fit into your memory since Kùzu, as a DBMS, stores its data on disk. Try this demonstrative <a href="https://colab.research.google.com/drive/12fOSqPm1HQTz_m9caRW7E_92vaeD9xq6" target="_blank" rel="noopener noreferrer">Colab notebook</a> to
see an example of how to do this. The current release comes with a limitation that we only truly implement the <code>FeatureStore</code> interface.
Inside <code>GraphStore</code> we still store the graph topology in memory.
So in reality only the features are stored and scanned from disk. We plan to address this limitation later on.</p><p>Here is also a demonstrative experiment (but certainly not comprehensive study) for the type of training performance
vs memory usage tradeoff you can expect.
We trained a simple 3-layers Graph Convolutional Network (GCN) model on <a href="https://ogb.stanford.edu/docs/nodeprop/#ogbn-papers100M" target="_blank" rel="noopener noreferrer">ogbn-papers100M</a> dataset, which contains about 111 million nodes
with 128 dimensional node features and about 1.6 billion edges.
Storing the graph topology takes around 48GB<sup id="fnref-1-3b764c"><a href="#fn-1-3b764c" class="footnote-ref">1</a></sup> and the features takes 53 GBs. Given our current limitation,
we can reduce 53 GB to something much smaller (we will limit it to as low as 10GB).
We used a machine with one RTX 4090 GPU with 24 GB of memory, two Xeon Platinum 8175M CPUs, and 384 GB RAM, which
is enough for PyG's in-memory store to store the entire graph and all features in memory.</p><p>During training, we use the <code>NeighborLoader</code> of PyG with batch size of 48000 and sets the <code>num_neighbors</code> to <code>[30] * 2</code>, which means at each batch roughly 60 neighbor nodes of 48000 nodes will be sampled from the <code>GraphStore</code> and the features of those nodes will be scanned
from Kùzu's storage. We picked this sample size because this gives us a peak GPU memory usage of approximately 22 GB, i.e.,
we can saturate the GPU memory. We used 16 cores<sup id="fnref-2-3b764c"><a href="#fn-2-3b764c" class="footnote-ref">2</a></sup> during the sampling process. We run each experiment in a Docker instance
and limit the memory systematically from 110GB, which is enough for PyG to run completely in memory, down to 90, 70, and 60GB.
At each memory level we run the same experiment by using Kùzu as a Remote Backend, where we
have to use about 48GB to store the topology and give the remaining memory to Kùzu's buffer manager.
For example when the memory is 60GB, we can only give ~10GB to Kùzu.</p><table><thead><tr><th>Configuration</th><th>End to End Time (s)</th><th>Per Batch Time (s)</th><th>Time Spent on Training (s)</th><th>Time Spent on Copying to GPU (s)</th><th>Docker Memory</th></tr></thead><tbody><tr><td>PyG In-memory</td><td>140.17</td><td>1.4</td><td>6.62</td><td>31.25</td><td>110 GB</td></tr><tr><td>Kùzu Remote Backend (bm=60GB)</td><td>392.6</td><td>3.93</td><td>6.29</td><td>34.18</td><td>110 GB</td></tr><tr><td>Kùzu Remote Backend (bm=40GB)</td><td>589.0</td><td>5.89</td><td>6.8</td><td>32.6</td><td>90 GB</td></tr><tr><td>Kùzu Remote Backend (bm=20GB)</td><td>1156.1</td><td>11.5</td><td>6.0</td><td>36</td><td>70 GB</td></tr><tr><td>Kùzu Remote Backend (bm=10GB)</td><td>1121.92</td><td>11.21</td><td>6.88</td><td>35.03</td><td>60 GB</td></tr></tbody></table><p>So, when have enough memory, there is about 2.8x slow down (from 1.4s to 3.93s per batch). This
is the case when Kùzu has enough buffer memory (60GB) to store the 53GB of features but we still incur the cost of
scanning them through Kùzu's buffer manager. So no or very little disk I/O happens (except the first time
the features are scanned to the buffer manager). Then as we lower the memory, Kùzu can hold only part
of the of node features in its buffer manager, so
we force Kùzu to do more and more I/O. The per batch time increase to 5.89s at 40GB of buffer manager size,
then seems to stabilize around 11s (so around 8.2x slowdown). </p><p>The slow down is better if you use smaller batch sizes but for the end to end training time, you
should probably still prefer to use larger batch sizes. This is a place where we would need to
do more research to see how much performance is on the table with further optimizations.</p><p>But in summary, if you have
large datasets that don't fit on your current systems' memories and would like to easily train your PyG models
off of disk (plus get all the usability features of a GDBMS as you prepare your datasets for training),
this feature can be very useful for you!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-ingestion-improvements">Data Ingestion Improvements<a href="#data-ingestion-improvements" class="hash-link" aria-label="Direct link to Data Ingestion Improvements" title="Direct link to Data Ingestion Improvements">​</a></h2><p><strong>Ingest from multiple files</strong>: You can now load data from multiple files of the same type into a node/rel table in two ways:</p><ul><li><strong>file list</strong>: <code>["vPerson0.csv", "vPerson1.csv", "vPerson2.csv"]</code></li><li><strong>glob pattern matching</strong>: Similar to Linux <a href="https://man7.org/linux/man-pages/man7/glob.7.html" target="_blank" rel="noopener noreferrer">Glob</a>, this will load files that matches the glob pattern.</li></ul><p><strong>Ingest from npy files</strong>: We start exploring how to enable data ingesting in column by column fashion. Consider a <code>Paper</code> table defined in the following DDL.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE NODE TABLE Paper(id INT64, feat FLOAT[768], year INT64, label DOUBLE, PRIMARY KEY(id));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Suppose your raw data is stored in npy formats where each column is represented as a numpy array on disk:
"node_id.npy", "node_feat_f32.npy", "node_year.npy", "node_label.npy".
You can now directly copy from npy files where each file is loaded to a column in <code>Paper</code> table as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COPY Paper FROM ("node_id.npy", "node_feat_f32.npy", "node_year.npy", "node_label.npy") BY COLUMN;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Reduce memory consumption when ingesting data into node tables:</strong>
This release further optimizes the memory consumption during data ingestion of node tables.
We no longer keep the whole node table in memory before flushing it to disk as a whole. Instead, we process a chunk of a file
and flush its corresponding pages, so incur only the memory cost of ingesting a chunk (or as many chunks as there are threads running).
This greatly reduces memory usage when the node table is very large.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="query-optimizer-improvements">Query Optimizer Improvements<a href="#query-optimizer-improvements" class="hash-link" aria-label="Direct link to Query Optimizer Improvements" title="Direct link to Query Optimizer Improvements">​</a></h2><p><strong>Projection push down for sink operator</strong>:
We now push down projections down to the first sink operator
above the last point in a query plan they are needed.
Consider the following query</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:person) WHERE a.age &gt; 35 RETURN a.salary AS s ORDER BY s;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This query's (simplified) plan is:  <code>Scan-&gt;Filter-&gt;OrderBY-&gt;ResultCollector</code>, where both
<code>ORDER BY</code> and the final <code>ResultCollector</code> are sink operators.
<code>ResultCollector</code> is where we accumulate the expressions in the <code>RETURN</code> clause.
This is simplified because <code>ORDER BY</code> actually consists of several physical operators.
Both column <code>age</code> and <code>salary</code> are scanned initially but only <code>salary</code> is needed in <code>ResultCollector</code>.
<code>age</code>, which is needed by <code>Filter</code> is projected out in the <code>ResultCollector</code>. We now push the projection of <code>age</code>
to <code>ORDER BY</code>, so <code>ORDER BY</code> does not have to materialize it.</p><p><strong>Other optimizations:</strong> We implemented several other optimizations, such as we reorder the filter expressions so equality conditions
are evaluated first, several improvements to cardinality estimator, and improved sideway information passing for joins. For the latter,
in our core join operator, which we called  ASP-Joins in our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>, we would blindly
perform sideways information passing (sip) from build to probe (or vice versa;
see <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">our paper</a> for details). Sometimes if there is no
filters on the probe and build sides, this is just an overhead as it won't decrease the amount of scans on either side.
In cases where we think sip won't help reduce scans, we do vanilla Hash Joins now.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-buffer-manager">New Buffer Manager<a href="#new-buffer-manager" class="hash-link" aria-label="Direct link to New Buffer Manager" title="Direct link to New Buffer Manager">​</a></h2><p>Before this release, we had two internal buffer pools with 2 different frame sizes of 4KB and 256KB,
so operators could only grab buffers of these two sizes. Plus when you loaded your DB and wanted to allocate
say 10GB buffer pool, we manually gave a fixed percentage to 4KB pool and the rest to 256KB pool.
This didn't give any flexibility for storing large objects and complicated code to manage
buffers when operators needed them.  Terrible design;
just don't do this!</p><p>We bit the bullet and decided to read the literature and pick a state-of-art buffer manager design that is
also practical. We switched to the mmap-based approach described in VMCache design from <a href="https://www.cs.cit.tum.de/fileadmin/w00cfj/dis/_my_direct_uploads/vmcache.pdf" target="_blank" rel="noopener noreferrer">this recent paper</a> by Leis et al..
This is a very nice design
and makes it very easy to support multiple buffer sizes very easily and only uses hardware locks (we used
software locks in our previous buffer manager). It also supports using optimistic reading,
which we verified improves our query performance a lot.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-data-types">New Data Types<a href="#new-data-types" class="hash-link" aria-label="Direct link to New Data Types" title="Direct link to New Data Types">​</a></h2><p>We now support several additional data types that were missing.</p><p><strong><a href="https://kuzudb.com/docs/cypher/data-types/list.html" target="_blank" rel="noopener noreferrer">FIXED-LIST</a> data type:</strong> This is important if you're doing graph ML and storing node features
in Kùzu. It is the efficient way to store fixed-length vectors. Here's the summary of how
to declare a node or rel property in your schemas to use the fixed-list data type.</p><table><thead><tr><th>Data Type</th><th>Description</th><th>DDL definition</th></tr></thead><tbody><tr><td>FIXED-LIST</td><td>a list of fixed number of values of the same numerical type</td><td>INT64<!-- -->[8]</td></tr></tbody></table><p>When possible use FIXED LIST instead of regular <a href="https://kuzudb.com/docs/cypher/data-types/list.html" target="_blank" rel="noopener noreferrer">VAR-LIST</a> data type
for cases when you know the size of your lists/vectors. It's much more efficient.</p><p>Note that FIXED-LIST is an experimental feature. Currently only bulk loading (e.g. <code>COPY</code> statement) and reading is supported.</p><p><strong>INT32, INT16, FLOAT data types:</strong> The release also comes with support for the following data types:</p><table><thead><tr><th>Data Type</th><th>Size</th><th>Description</th></tr></thead><tbody><tr><td>INT32</td><td>4 bytes</td><td>signed four-byte integer</td></tr><tr><td>INT16</td><td>2 bytes</td><td>signed two-byte integer</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>single precision floating-point number</td></tr></tbody></table><p>For our next release, our focus on data types will be on complex ones, STRUCT and MAP. So stay tuned for those!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="other-system-functionalities">Other System Functionalities<a href="#other-system-functionalities" class="hash-link" aria-label="Direct link to Other System Functionalities" title="Direct link to Other System Functionalities">​</a></h2><p><strong>Query timeout</strong>: We will now automatically stop any query that exceeds a specified timeout value (if one exists).
The default query timeout value is set to -1, which signifies that the query timeout feature is initially disabled.
You can activate the query timeout by configuring a positive timeout value through:</p><ul><li><ol><li>C++ API: <code>Connection::setQueryTimeOut(uint64_t timeoutInMS)</code></li></ol></li><li><ol start="2"><li>CLI: <code>:timeout [timeoutValue]</code></li></ol></li></ul><p><strong>Interrupt:</strong> You can also interrupt your queries and can stop your long running queries manually. There
are two ways to do this:</p><ul><li>C++ API: <code>Connection::interrupt()</code>: interrupt all running queries within the current connection.</li><li>CLI: interrupt through <code>CTRL + C</code></li></ul><p>Note: The Interruption and Query Timeout features are not applicable to <code>COPY</code> commands in this release.</p><div class="footnotes"><hr><ol><li id="fn-1-3b764c">Internally, PyG coverts the edge list to CSC format for sampling, which duplicates the graph structures in memory. When you download the graph topology it actually takes about 24GB.<a href="#fnref-1-3b764c" class="footnote-backref">↩</a></li><li id="fn-2-3b764c">We set <code>num_workers</code> to 16 when running the PyG in-memory setup. Since Kùzu does not currently work with multiple workers in Python, we limit <code>num_workers</code> to 1 when sampling from Kùzu but internally Kùzu scans in parallel with 16 threads.<a href="#fnref-2-3b764c" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Kùzu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/wcoj</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/wcoj"/>
        <updated>2023-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Joins of a sets of records is objectively the most expensive operation in DBMSs.]]></summary>
        <content type="html"><![CDATA[<p>Joins of a sets of records is objectively the most expensive operation in DBMSs.
In my previous post on <a href="/docusaurus/blog/factorization">factorization</a>, I said that in the field of databases, once
in a while you run into a very simple idea that deviates from the norm that gets you very excited.
Today, I will discuss another such idea, worst-case optimal join (wcoj) algorithms.
Wcoj algorithms and the theory around it in one sentence says this:</p><ul><li>Queries involving complex "cyclic joins" over many-to-many relationships should be
evaluated column at a time instead of table at a time, which is the norm. </li></ul><p>Wcoj algorithms find their best applications when finding cyclic patterns on graphs,
such as cliques or cycles, which is common in the workloads of fraud detection and
recommendation applications. As such, they should be integrated into every graph DBMS
(and possibly to RDBMSs) and I am convinced that they eventually will.</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>History of Wcoj Algorithms:</strong> Research on wcoj algorithms started with a solution to open question
about the maximum sizes of join queries. This result made researchers realize this: the traditional
"binary join plans" paradigm of generating query plans that join 2 tables a time
until all of the tables in the query are joined is provably
suboptimal for some queries. Specifically, when join queries are
cyclic, which in graph terms means when the searched graph pattern has cycles
in it, and the relationships between records are many-to-many, then this
paradigm can generate unnecessarily large amounts of intermediate results.</li><li><strong>Core Algorithmic Step of Wcoj Algorithms:</strong>  Wcoj algorithms fix this sub-optimality by
performing the joins one column at a time (instead of 2 tables at a time) using multiway intersections.</li><li><strong>How Kùzu Integrates Wcoj Algorithms:</strong> Kùzu generates plans that seamlessly mix binary joins
and wcoj-style multiway intersections. Multiway intersections are performed by an operator called
"multiway HashJoin", which has one or more build phases that creates one or more hash tables that stores
sorted adjacency lists; and a probe phase that performs multi-way intersections using the sorted lists.</li><li><strong>Yes, the Term "Worst-case Optimal" Is Confusing Even to Don Knuth:</strong> I know, Don Knuth also found the term
"worst-case optimal" a bit confusing. See my <a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">anecdote on this</a>.
It basically means that the worst-case runtimes of these algorithms are asymptotically optimal.</li></ul></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="joins-running-example--traditional-table-at-a-time-joins">Joins, Running Example &amp; Traditional Table-at-a-time Joins<a href="#joins-running-example--traditional-table-at-a-time-joins" class="hash-link" aria-label="Direct link to Joins, Running Example &amp; Traditional Table-at-a-time Joins" title="Direct link to Joins, Running Example &amp; Traditional Table-at-a-time Joins">​</a></h2><p>Joins are objectively the most expensive and powerful operation in DBMSs.
In SQL, you indicate them in the FROM clause by listing
a set of table names, in Cypher in the MATCH clause, where you draw a graph pattern
to describe how to join node records with each other.
As a running example, consider a simple social network of users and followers,
whose node-link diagram is shown below. I am also showing the table that contains these records
in a <code>User</code> (ignore the <code>name</code> property for now) and <code>Follows</code> tables.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-running-ex-data-5b2942d477cbc661b3983f8dff8b8fde.png" class="img_ev3q"></div><p>Consider finding triangles, which is one of the simplest
forms of cycles and cliques, in this network. The SQL and Cypher
versions of this query are shown below. </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SQL:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM  Follows f1, Follows f2, Follows f3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE f1.dst=f2.src AND f2.dst=f3.src AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      f3.dst = f1.src</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Cypher:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[f1:Follows]-&gt;(b:User)-[f2:Follows]-&gt;(c:User)-[f3:Follows]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN  *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That long MATCH clause "draws" a triangle and for our case here, this is equivalent
to joining three copies of the Follows table. </p><p>Now ever since the System R days and <a href="https://courses.cs.duke.edu/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf" target="_blank" rel="noopener noreferrer">Patricia Selinger's 1979 seminal paper</a> that
described how System R compiled and optimized SQL queries, there has been an
unchallenged dogma in DBMSs that the joins specified in the query would be
evaluated pairwise, table at a time.
Here's a blurb from Selinger's paper, where one can see this
assumption:
"<em>In System R a user need not know how the
tuples are physically stored ... Nor does a user
specify in what order joins are to be performed. The System
R optimizer chooses both join order and ...</em>"
To this day, this is the norm. DBMSs pick a "join order" which is the order in
which the tables should be joined iteratively 2 at a time.
In the above example, for example
there are three possible join orders. One way to represent these orders is by
writing different parenthesization of the joins: </p><ul><li>(i) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F2) \bowtie F3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>; (ii) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mo stretchy="false">(</mo><mi>F</mi><mn>2</mn><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F1 \bowtie (F2 \bowtie F3))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">))</span></span></span></span></span>;
and (iii) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F3) \bowtie F2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span>. </li></ul><p>The optimization problem for a system is of course more complex than just
ordering tables because the system also has to choose which
binary join algorithm to use when joining each pair of tables, e.g., hash joins vs merge joins.
But take any system you want, and they will all follow the same paradigm of
joining 2 base or intermediate tables iteratively, until all tables are joined:
hence the term <em>binary joins</em> to describe the plans of existing systems.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-math-puzzle-that-started-it-all">A Math Puzzle That Started it All<a href="#a-math-puzzle-that-started-it-all" class="hash-link" aria-label="Direct link to A Math Puzzle That Started it All" title="Direct link to A Math Puzzle That Started it All">​</a></h2><p>So, what's the problem with binary join plans? When join queries are cyclic
and the relationships are many-to-many, they can generate provably large amounts
of (so unnecessary in a formal sense) intermediate results. First, cyclicity for
join queries has formal (and a bit intimidating) definitions but if you think of
graph patterns, it simply means that the searched pattern's undirected version has
cycles. Why do binary joins generate unnecessarily large intermediate results? I'll
get to this below but first a bit of history on the origins of this insight.
The whole topic of "worst-case optimal joins" started with 2 papers, a <a href="https://arxiv.org/abs/1711.04506" target="_blank" rel="noopener noreferrer">2007 SODA</a>
and a <a href="https://arxiv.org/abs/1711.03860" target="_blank" rel="noopener noreferrer">2008 FOCS</a>
paper, which are top venues in algorithms and theory. In these papers,
several theoreticians solved a fundamental open question
about join queries. Suppose I give you:</p><ol><li>An arbitrary natural join query, say of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span> relations. In DBMS literature we denote such
queries as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>R</mi><mn>1</mn><mo stretchy="false">(</mo><msub><mi>a</mi><mn>11</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>r</mi><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>⋈</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⋈</mo><mi>R</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>r</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q=R1(a_{11}, ..., a_{r1}) \bowtie ... \bowtie Rm(a_{m1}, ..., a_{rm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.</li><li>Sizes of R1, ..., Rm, e.g., for simplicity assume they all have <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many tuples. </li></ol><p>"Natural" here means that the join predicates are equality predicates on identical column
names. You, as the second person in this puzzle, are allowed to set the values inside these relations.
<strong>The open question was: how large can you make the final output?</strong> So for example, if I told you that there are
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many tuples in the <code>Follows</code> tables, what is the maximum number of triangle outputs there can  be?<sup id="fnref-1-627daf"><a href="#fn-1-627daf" class="footnote-ref">1</a></sup>
Even more concretely for the triangle query, the question is: out of all possible graphs with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many edges,
what is the maximum number of triangles they contain?</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-edge-covers-8eef238afae2ef19f6f3b7722108ddf8.png" class="img_ev3q"></div><p>It still surprises me that the answer to this question was not known until 2008.
It just looks like a fundamental question someone in databases must have answered before.
Now excuse me for bombarding your brains with some necessary math definitions.
These two papers showed that the answer is: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><msup><mi>ρ</mi><mstyle mathcolor="#cc0000"><mtext>\*</mtext></mstyle></msup></msup></mrow><annotation encoding="application/x-tex">IN^{\rho^\*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0397em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0397em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em"><span style="top:-2.9667em;margin-right:0.0714em"><span class="pstrut" style="height:2.5357em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord text mtight" style="color:#cc0000"><span class="mord mtight" style="color:#cc0000">\*</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ρ</mi><mstyle mathcolor="#cc0000"><mtext>\*</mtext></mstyle></msup></mrow><annotation encoding="application/x-tex">\rho^\*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight" style="color:#cc0000"><span class="mord mtight" style="color:#cc0000">\*</span></span></span></span></span></span></span></span></span></span></span></span></span> is a property
of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span></span></span></span></span> called the <em>fractional edge cover number</em> of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span></span></span></span></span>.
This is the solution to
an optimization problem and best explained by thinking about the "join query graph",
which, for our purposes, is the triangle graph pattern (ignoring the edge directions), shown
in Fig 2a and 2b.</p><p>The optimization problem is this:
put a weight between <!-- -->[0, 1]<!-- --> to
each "query edge" such that each "query node" is "covered", i.e., the sum of
the query edges touching each query node is &gt; 1. Each such solution is called an
edge cover. The problem is to find the edge cover whose total weight is the minimum. That is
called the fractional edge cover number of the query. For the triangle query,
one edge cover, shown in Fig 2a, is <!-- -->[1, 1, 0]<!-- -->, which has
a total weight of 1 + 1 + 0 = 2.
The minimum weight edge cover is <!-- -->[1/2, 1/2, 1/2]<!-- -->, shown in Fig 2b,
with a total weight  of 1.5. Therefore, the fractional edge cover number <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ρ</mi><mstyle mathcolor="#cc0000"><mtext>\*</mtext></mstyle></msup></mrow><annotation encoding="application/x-tex">\rho^\*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight" style="color:#cc0000"><span class="mord mtight" style="color:#cc0000">\*</span></span></span></span></span></span></span></span></span></span></span></span></span>
of the triangle query is 1.5.
In general, each edge cover is an upper bound but the FOCS paper showed
that the fractional edge cover number is the tight upper bound.
So the maximum number of triangles there can be on a graph with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> edges is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(IN^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
and this is tight, i.e., there are such graphs. Nice scientific progress!
Nowadays, the quantity <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><msup><mi>ρ</mi><mstyle mathcolor="#cc0000"><mtext>\*</mtext></mstyle></msup></msup></mrow><annotation encoding="application/x-tex">IN^{\rho^\*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0397em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0397em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em"><span style="top:-2.9667em;margin-right:0.0714em"><span class="pstrut" style="height:2.5357em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord text mtight" style="color:#cc0000"><span class="mord mtight" style="color:#cc0000">\*</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> is known as the <code>AGM bound</code> of a query,
after the first letters of the last names of the authors of the FOCS paper.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="problem-with-table-at-a-timebinary-joins">Problem With Table-at-a-time/Binary Joins<a href="#problem-with-table-at-a-timebinary-joins" class="hash-link" aria-label="Direct link to Problem With Table-at-a-time/Binary Joins" title="Direct link to Problem With Table-at-a-time/Binary Joins">​</a></h2><p>Now this immediately made the same researchers realize that binary join plans are
provably sub-optimal because they can generate polynomially more intermediate results
than the AGM bound of the query. This happens because on cyclic queries,
the strategy of joining tables
2 at a time may lead to unnecessarily computing some acyclic sub-joins.
For example, in the triangle query, the plan
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F2) \bowtie F3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> first computes <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F1 \bowtie F2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> sub-join,
which in graph terms computes the 2-paths in the graph.
This is a problem because often there can be many more of these acyclic sub-joins
than there can be outputs for the cyclic join.
For this plan, there can
be <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">IN^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> many 2-paths (which is the AGM bound of 2-paths),
which is polynomially larger than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup></mrow><annotation encoding="application/x-tex">IN^{1.5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span></span></span></span></span>.
For example in our running example, there are 1000<!-- -->*<!-- -->1000 = 1M many 2 paths,
but on a graph with 2001 edges there can be at most 89.5K triangles (well ours
has only 3 triangles (because the triangle query we are using is symmetric
the sole triangle would generate 3 outputs for 3 rotations of it)).</p><p>Any other plan in this case would have generated <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">IN^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> many 2-paths,
so there is no good binary join plan here. I want to emphasize that this sub-optimality does not occur
when the queries are acyclic or when the dataset does not have
many-to-many relationships. If the joins were primary-foreign key non-growing joins,
then binary join plans will work just fine. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solution-column-at-a-time-worst-case-optimal-join-algorithms">Solution: Column-at-a-time "Worst-case Optimal" Join Algorithms<a href="#solution-column-at-a-time-worst-case-optimal-join-algorithms" class="hash-link" aria-label="Direct link to Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms" title="Direct link to Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms">​</a></h2><p>So the immediate
next question is: are there algorithms whose runtimes can be bounded by
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(IN^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>? If so, how are they different? The answer to this question
is a bit anti-climactic. The core idea existed in the 2007 SODA and 2008 FOCS papers,
though it was refined more ~4 years later in some theoretical papers
by <a href="https://hung-q-ngo.github.io/" target="_blank" rel="noopener noreferrer">Hung Ngo</a>, <a href="https://u.cs.biu.ac.il/~porat/" target="_blank" rel="noopener noreferrer">Ely Porat</a>,
<a href="https://cs.stanford.edu/~chrismre/" target="_blank" rel="noopener noreferrer">Chris Ré</a>, and <a href="https://cse.buffalo.edu/faculty/atri/" target="_blank" rel="noopener noreferrer">Atri Rudra</a>
in the database fields <a href="https://dl.acm.org/doi/10.1145/2213556.2213565" target="_blank" rel="noopener noreferrer">PODS</a> and
<a href="https://dl.acm.org/doi/10.1145/2590989.2590991" target="_blank" rel="noopener noreferrer">SIGMOD Record</a>. The answer is simply
to perform the join column at a time, using multiway
intersections. "Intersections of what?" you should be asking.
For joins over arbtrary relations, we need special indices but I want to
skip this detail.
In the context of GDBMSs, GDBMSs already
have join indices (aka adjacency list indices) and for the common joins
they perform, this will be enough for our purposes.</p><p>I will next demonstrate a wcoj
algorithm known as "Generic Join" from the <a href="https://dl.acm.org/doi/10.1145/2590989.2590991" target="_blank" rel="noopener noreferrer">SIGMOD Record paper</a>.
It can be seen as the simplest of all wcoj algorithms.
As "join order", we will pick a "column order"
instead of Selinger-style table order. So in our triangle query,
the order could be a,b,c. Then we will build indices over each relation
that is consistent with this order. In our case there are conceptually three (identical)
relations: <code>Follows1(a, b)</code>, <code>Follows2(b, c)</code>, <code>Follows3(c, a)</code>. For <code>Follows1</code>,
we need to be able to read all <code>b</code> values for a given <code>a</code> value (e.g., <code>a=5</code>).
In graph terms, this just means that we need "forward join index".
For <code>Follows3</code>, because <code>a</code> comes earlier than <code>c</code>, we will want an index
that gives us <code>c</code> values for a given <code>a</code> value. This is equivalent to a
"backward join index". In graphs, because joins happen through the
relationship records, which can, for the purpose of the joins,
be taught of as a binary relation (src, dst), 2 indices is enough
for our purposes. On general relations, one may need many more indices.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-gj-simulation-387785701f792ef3615e17ec7c9ff65b.png" style="width:600px" class="img_ev3q"></div><p>We will iteratively find: (i) all <code>a</code> values
that can be in the final triangles; (ii) all <code>ab</code>'s that be in the final
triangles; and (iii) all <code>abc</code>'s, which are the triangles. Let's simulate the computation:</p><ul><li>Step 1: Find all <code>a</code>'s. Here we will just take
all nodes as possible a values. This is shown under "Step 1" in the above figure.</li><li>Step 2: For each a value, e.g., a=1, we extend it to find all <code>ab</code>'s that
can be part of triangles: Here we use the forward index to look up all
<code>b</code> values for node with ID 1. So on and so forth. This will generate the
second intermediate relation.</li><li>Step 3: For each <code>ab</code> value, e.g., the tuple (a=1 b=0), we will
intersect all <code>c</code>'s with <code>a</code>=1, and all <code>c</code>'s with <code>b</code>=0. That is, we will intersect
the backward adjacency list of the node with ID 1, and forward adjacency list of
the node with ID 0. If the intersection is non-empty, we produce some triangles.
In this case, we will produce the triangle (<code>a</code>=1, <code>b</code>=0, <code>c</code>=1001)
The result of this computation will produce the third and final
output table in the figure.</li></ul><img loading="lazy" align="right" style="width:200px;padding-left:3px" src="/docusaurus/assets/images/wcoj-4-clique-01bedf7f6afa337d495b4ecb29162619.png" class="img_ev3q">Note that this process did not produce the 2-paths as an intermediate step, which is how wcoj algorithms fix for the sub-optimality of binary join algorithms. If your query was more complex then a wcoj algorithm can do k-way intersections where k &gt; 2. For example on the 4-clique query shown on the right, suppose the column order is abcd, then given abc triangles, we would do a 3-way intersection of forward index of a's, backward index of b's, and forward index of c's, to complete the triangles to joins. This type of multiway intersections is the necessary algorithmic step to be efficient on cyclic queries.<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-kùzu-performs-worst-case-optimal-join-algorithms">How Kùzu Performs Worst-case Optimal Join Algorithms:<a href="#how-kùzu-performs-worst-case-optimal-join-algorithms" class="hash-link" aria-label="Direct link to How Kùzu Performs Worst-case Optimal Join Algorithms:" title="Direct link to How Kùzu Performs Worst-case Optimal Join Algorithms:">​</a></h2><p>Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a> describes this in detail, so I will be brief here.
First, Kùzu mixes binary joins and wcoj-like multiway intersections
following some principles that my PhD student <a href="http://amine.io/" target="_blank" rel="noopener noreferrer">Amine Mhedhbi</a>
had worked quite hard on early in his PhD. I recommend these two papers,
one by <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">Amine and me</a>
and one by the <a href="https://db.in.tum.de/~freitag/papers/p1891-freitag.pdf" target="_blank" rel="noopener noreferrer">Umbra group</a>
on several different ways people have proposed for mixing binary and wcoj algorithms in query plans.
Overall message of these studies is that, wcoj are critical when the query has a very cyclic component
and multiway intersections can help. If the query does not have this property,
systems should just use binary joins.
So wcoj-like computations should be seen as complementing binary join plans.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-kuzu-multiway-hash-join-69ad405ae1e8d274b5369c7cf1bb8a0a.png" style="width:600px" class="img_ev3q"></div><p>Second, Kùzu performs multiway intersections in a <em>Multiway HashJoin</em> operator.
In our CIDR paper we call this operator Multiway ASPJoin. It can&nbsp;be thought
of a modified hash-join operator where we use multiple hash tables and do
an intersection to produce outputs as I will simulate.
Let me change the query a little and add a filter on <code>a.name = Noura</code>,
where <code>name</code> is the primary key of <code>User</code> records. You can see from Fig 1a
that Noura is the primary key of node with ID 1. In my simulation,
the Multiway HashJoin operator will take <code>ab</code> tuples and extend them
to <code>abc</code> tuples through a 2-way intersection. In general multiway HashJoin
has 3 phases: 1 accumulate phase, build phases to build k-2 hash tables,
and a probe phase. Here are the steps.</p><ul><li>Step 1 - Accumulate Phase: The operator receives the <code>ab</code> tuples which will be extended
to triangles. This allows the system to see exactly
the forward/backward lists of which nodes will be intersected. Then, the operator passes
this information sideways to only scan those lists. In this case,
because there is a primary key filter on Noura, the only <code>ab</code> tuple that will be read
is (a=1,b=0). This is stored in a temporary buffer that we call "Factorized Table" in the system.</li><li>Step 2 - Build Phase 1: In the first build step, Multway HashJoin will pass a nodeID filter
to the <code>Scan Follows (a)&lt;-(c)</code> operator with only 1=true for node ID 1, and 0 for every other node ID.
The operator can do this because at this stage the operator knows exactly which backward
adjacency lists will be needed when we extend the tuple (in this case only node with ID 1's
backward list is needed). The Scan operator uses this node ID filter to scan only this backward list,
{1001}, and avoids
scanning the rest of the file that stores the backwards Follows edges. This list is first sorted
based on the IDs of the neighbor IDs and stored in a hash table, denoted as "Hash Table (a)&lt;-(c)"
in the figure.</li><li>Step 3 - Build Phase 2: This is similar to Build phase 1. Using a semijoin filter
with node 0's ID, we scan only node 2's forward <code>Follows</code> list {1001, 1002, ..., 2000},
sort it, and then store in a hash table "Hash Table (b)-&gt;(c)".</li><li>Step 4 - Probe: We re-scan the accumulated <code>ab</code> tuples from the factorized table.
For each tuple, we first probe "Hash Table (a)&lt;-(c)"
and then "Hash Table (b)-&gt;(c)" to fetch two lists, intersect them, and produce outputs.
In this case there is only one tuple (a=1, b=0), so we will fetch a=1's backward list and b=0's forward list,
intersect these lists, and produce the triangle (a=1, b=0, c=1001).</li></ul><p>This performs quite well. Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a> has some performance numbers
comparing against other types of WCO joins implementations (see the experiments in Table 3). Since I did not cover other ways to implement
wco join algorithms inside DBMSs, these experiments would be difficult to explain here.
Instead, let me just demonstrate some simple comparisons between using binary joins and wco joins
in Kùzu on a simple triangle query. On larger cyclic queries, e.g., 4- or 5- cliques,
the differences are much larger and often binary join plans do not finish on time.
You can try this experiment too. </p><p>Here is the configuration. The dataset I'm using
is a popular web graph that is used in academic papers called <a href="https://snap.stanford.edu/data/web-BerkStan.html" target="_blank" rel="noopener noreferrer">web-BerkStan</a>.
It has 685K nodes and 7.6M edges.
I modeled these as a simple <code>Page</code> nodes and <code>Links</code> edges.</p><p>I start Kùzu on my own laptop, which is a Macbook Air 2020 with Apple M1 chip, 16G memory,
and 512GB SSD, and run the following two queries (by default, Kùzu uses all thread available, which is 8 in this case):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Q1: Kùzu-WCO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Page)-[e1:Links]-&gt;(b:Page)-[e2:Links]-&gt;(c:Page)-[e3:Links]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This will compile plan that uses a wco Multiway HashJoin operator. I will refer to this
plan as Kùzu-WCO below. I am also running the following query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Q2: Kùzu-BJ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Page)-[e1:Links]-&gt;(b:Page)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WITH *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (b:Page)-[e2:Links]-&gt;(c:Page)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WIH *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (c)-[e3:Links]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Currently Kùzu compiles each MATCH/WITH block separately so this is hack to force the system
to use binary join plan. The plan will join <code>e1</code> <code>Links</code> with <code>e2</code> <code>Links</code> and then
join the result of that with <code>e3</code> <code>Links</code>, all using binary HashJoin operator. I will
refer to this as Kùzu-BJ. Here are the results:</p><table><thead><tr><th>Configuration</th><th align="center">Time</th></tr></thead><tbody><tr><td>Kùzu-WCO</td><td align="center">1.62s</td></tr><tr><td>Kùzu-BJ</td><td align="center">51.17s</td></tr></tbody></table><p>There are ~41M triangles in the output. We see <strong>31.6x</strong> performance improvement in this simple query.
In larger densely cyclic queries, binary join plans just don't work.</p><p>To try this locally, you can download our prepared CSV files from <a href="https://github.com/kuzudb/kuzudb.github.io/tree/main/data/web-berkstan" target="_blank" rel="noopener noreferrer">here</a>, and compile from our <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">latest master</a><sup id="fnref-2-627daf"><a href="#fn-2-627daf" class="footnote-ref">2</a></sup> (<code>make clean &amp;&amp; make release NUM_THREADS=8</code>).
Then start Kùzu's shell, and load data into Kùzu:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./build/release/tools/shell/kuzu_shell -i web.db</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; CREATE NODE TABLE Page (id INT64, PRIMARY KEY(INT64));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; CREATE REL TABLE Links (FROM Page TO Page, MANY_MANY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; COPY Page FROM 'web-node.csv';</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; COPY Links FROM 'web-edge.csv';</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, run those two queries (Kùzu-WCO and Kùzu-BJ) to see the difference!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">A Thank You &amp; an Anecdote About Knuth's Reaction to the Term "Worst-case Optimal"<a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal" class="hash-link" aria-label="Direct link to A Thank You &amp; an Anecdote About Knuth's Reaction to the Term &quot;Worst-case Optimal&quot;" title="Direct link to A Thank You &amp; an Anecdote About Knuth's Reaction to the Term &quot;Worst-case Optimal&quot;">​</a></h2><p>Before wrapping up, I want to say thank you to <a href="https://cs.stanford.edu/~chrismre/" target="_blank" rel="noopener noreferrer">Chris Ré</a>, who is a
co-inventor of earliest wcoj algorithms.
In the 5th year of my PhD, Chris had introduced me to this area and
we had written a paper together on the topic in the context of evaluating
joins in distributed systems, such as MapReduce and Spark. I ended up working on
these algorithms and trying to make them performant in actual systems
for many more years than I initially predicted.
I also want to say thank you to <a href="https://hung-q-ngo.github.io/" target="_blank" rel="noopener noreferrer">Hung Ngo</a> and <a href="https://cse.buffalo.edu/faculty/atri/" target="_blank" rel="noopener noreferrer">Atri Rudra</a>,
with whom I have had several conversations during those years on these algorithms.</p><p>Finally, let me end with a fun story about the term "worst-case optimal":
Several years ago <a href="https://uwaterloo.ca/computer-science/events/dls-donald-knuth-all-questions-answered" target="_blank" rel="noopener noreferrer">Don Knuth</a> was visiting UWaterloo
to give a Distinguished Lecture Seminar, which is our department's most prestigious
lecture series. A colleague of mine and I had a 1-1 meeting with him.
Knuth must be known to anyone with a CS degree but importantly he is
credited for founding the field of algorithm analysis (e.g., for popularizing
the big-oh notation for analyzing algorithms' performances).
In our meeting, he asked me what I was working on
and I told him about these new algorithms called "worst-case optimal join algorithms".
The term was so confusing to him and his immediate interpretation
was: "Are they so good that they are optimal even in their worst-case performances?" </p><p>The term actually means that the worst-case runtime of these algorithms
meets a known lower bound for the worst-case runtime of any join algorithm,
which is  <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><msup><mi>ρ</mi><mstyle mathcolor="#cc0000"><mtext>\*</mtext></mstyle></msup></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(IN^{\rho^\*})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2897em;vertical-align:-0.25em"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0397em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em"><span style="top:-2.9667em;margin-right:0.0714em"><span class="pstrut" style="height:2.5357em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord text mtight" style="color:#cc0000"><span class="mord mtight" style="color:#cc0000">\*</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.
Probably a more standard term would be to call them
"asymptotically optimal", just like people call sort merge an asymptotically optimal
sorting algorithm under the comparison model.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-words">Final Words<a href="#final-words" class="hash-link" aria-label="Direct link to Final Words" title="Direct link to Final Words">​</a></h2><p>What other fundamental algorithmic developments have
been made in the field on join processing? It is surprising but there are still main gaps
in the field's understanding of how fast joins can be processed.
There has been some very interesting
work in an area called <em>beyond worst-case optimal join algorithms</em>. These papers
ask very fundamental questions about joins, such as how can we prove that a join algorithm
is correct, i.e., it produces the correct output given its input?
The high-level answer is that each join algorithm must be producing a proof that its output is correct,
through the comparison operations it makes.
The goal of this line of research is to design practical algorithms whose implicit proofs are optimal,
i.e., as small as possible. This is
probably the most ambitious level of optimality one can go for in algorithm design.
There are already some algorithms, e.g., an algorithm called <a href="https://dl.acm.org/doi/pdf/10.1145/2967101" target="_blank" rel="noopener noreferrer">Tetris</a>. The area
is fascinating and has deep connections to computational geometry. I
advised a <a href="https://arxiv.org/abs/1909.12102" target="_blank" rel="noopener noreferrer">Master's thesis</a> on the topic once and learned quite a bit about
computational geometry that I never thought could be relevant to my work. The current
beyond worst-case optimal join algorithms however are currently not practical.
Some brave souls need to get into the space and think hard about whether
practical versions of these algorithms can be developed. That would be very exciting.</p><p>This completes my 3-part blog on the contents of our CIDR paper and 2 core techniques:
<a href="/docusaurus/blog/factorization">factorization</a> and worst-case optimal join algorithms that we have integrated into
Kùzu to optimize for many-to-many joins. My goal in these blog
posts was to explain these ideas to a general CS/software engineering audience and
I hope these posts have made this material more approachable. My other goal
was to show the role of theory in advancing systems. Both of these ideas emerged from
pen-and-paper theory papers that theoreticians wrote but gave clear advice to DBMS developers.
As I said many times, I'm convinced that among many other techniques, these two
techniques need to be integral to any GDBMS that wants to be competitive in performance,
because queries with many-to-many joins are first-class-citizens in the workloads of these systems.</p><p>We will keep writing more blog posts in the later months about our new releases,
and other technical topics. If there are things you'd like us to write about,
please reach out to us! Also please give Kùzu a try, prototype applications with it,
break it, let us know of your performance or other bugs, so we can continue improving
it. Give us a <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">GitHub star</a> too and take care until the next posts!</p><div class="footnotes"><hr><ol><li id="fn-1-627daf">The question is interesting in the set semantics when you cannot pick every column value of every tuple the same value, which forces a Cartesian product of all the relations.<a href="#fnref-1-627daf" class="footnote-backref">↩</a></li><li id="fn-2-627daf">We found a minor bug in the latest release 0.0.2 when a node has a very large number of edges, which is fixed in the master branch, that's why we suggest using the master branch.<a href="#fnref-2-627daf" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Semih Salihoğlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="internals" term="internals"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kùzu 0.0.2 Release]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.2-release</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/kuzu-0.0.2-release"/>
        <updated>2023-02-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This post is about the second release of Kùzu. However, we want to start with something much more important:]]></summary>
        <content type="html"><![CDATA[<p>This post is about the second release of Kùzu. However, we want to start with something much more important:</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="donate-to-the-victims-of-türkiye-syria-earthquake">Donate to the Victims of <a href="https://www.bbc.com/news/world-middle-east-64590946" target="_blank" rel="noopener noreferrer">Türkiye-Syria Earthquake</a>:<a href="#donate-to-the-victims-of-türkiye-syria-earthquake" class="hash-link" aria-label="Direct link to donate-to-the-victims-of-türkiye-syria-earthquake" title="Direct link to donate-to-the-victims-of-türkiye-syria-earthquake">​</a></h3><p>Our hearts, thoughts, and prayers go to all the victims, those who survived and those who passed,
in Syria and Türkiye.
There will be a very difficult winter for all those who survived so everyone needs to help.
Here are two pointers for trustworthy organizations we know of that are trying to help
victims on the ground. For Türkiye (where Semih is from), you can donate to <a href="https://ahbap.org/bagis-kategorisi/5" target="_blank" rel="noopener noreferrer">Ahbap</a>
(Please be aware that <strong>the donation currency is in TL</strong> and 14 TL = 1 CAD; 19TL = 1 USD); and for Syria
you can donate to the <a href="https://www.whitehelmets.org/en/" target="_blank" rel="noopener noreferrer">White Helmets</a>. Be generous! We'll leave pointers to several
other organizations below in this footnote<sup id="fnref-1-4af10a"><a href="#fn-1-4af10a" class="footnote-ref">1</a></sup>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview-of-kùzu-002">Overview of Kùzu 0.0.2<a href="#overview-of-kùzu-002" class="hash-link" aria-label="Direct link to Overview of Kùzu 0.0.2" title="Direct link to Overview of Kùzu 0.0.2">​</a></h2><p>Back to our release. Kùzu codebase is changing fast but this release still has a focus: we
have worked quite hard since the last release to integrate Kùzu to import data from
different formats and export data to different formats. There are also several important
features in the new Cypher clauses and queries we support,  additional string
processing capabilities, and new DDL statement support. We will give a summary of each
of these below.</p><p>For installing the new version, please visit the <a href="https://kuzudb.com/docs/getting-started.html" target="_blank" rel="noopener noreferrer">installation guide</a> and
the full
<a href="https://github.com/kuzudb/kuzu/releases" target="_blank" rel="noopener noreferrer">release notes are here</a>. If you are eager to play with
a few Colab notebooks, here are several links: </p><ul><li><a href="https://colab.research.google.com/drive/15OLPggnRSBmR_K9yzq6iAGE5MDzNwqoN" target="_blank" rel="noopener noreferrer">General Kùzu Demo</a></li><li><a href="https://colab.research.google.com/drive/1fzcwBwTY-M19p7OOTIaynfgHFcAQo9NK" target="_blank" rel="noopener noreferrer">Export Query Results to Pytorch Geometric: Node Property Prediction Example</a></li><li><a href="https://colab.research.google.com/drive/1QdX7CDdajIAb04lqaO5PfJlpKG-ljG28" target="_blank" rel="noopener noreferrer">Export Query Results to Pytorch Geometric: Link Prediction Example</a></li><li><a href="https://colab.research.google.com/drive/1NDsnFDWcSGoaOl-mOgG0zrPG2VAr8Q6H" target="_blank" rel="noopener noreferrer">Export Query Results to NetworkX</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="exporting-query-results-to-pytorch-geometric-and-networkx">Exporting Query Results to Pytorch Geometric and NetworkX<a href="#exporting-query-results-to-pytorch-geometric-and-networkx" class="hash-link" aria-label="Direct link to Exporting Query Results to Pytorch Geometric and NetworkX" title="Direct link to Exporting Query Results to Pytorch Geometric and NetworkX">​</a></h2><p>Perhaps most excitingly, we have added the first capabilities to integrate with 2 popular
graph data science
libraries: (i) <a href="https://github.com/pyg-team/pytorch_geometric" target="_blank" rel="noopener noreferrer">Pytorch Geometric</a> (PyG) for performing
graph machine learning; and (ii) <a href="https://networkx.org/" target="_blank" rel="noopener noreferrer">NetworkX</a> for a variety of
graph analytics, including visualization. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pytorch-geometric-queryresultget_as_torch_geometric-function">Pytorch Geometric: <code>QueryResult.get_as_torch_geometric()</code> function<a href="#pytorch-geometric-queryresultget_as_torch_geometric-function" class="hash-link" aria-label="Direct link to pytorch-geometric-queryresultget_as_torch_geometric-function" title="Direct link to pytorch-geometric-queryresultget_as_torch_geometric-function">​</a></h3><p>Our <a href="/docusaurus/client-apis/python-api/">Python API</a> now has a
new <a href="/docusaurus/client-apis/python-api/query-result#query_result.QueryResult.get_as_torch_geometric"><code>QueryResult.get_as_torch_geometric()</code></a> function that
converts results of queries to PyG's in-memory graph representation
<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data</code></a>.
If your query results contains nodes and relationship objects, then the function uses
those nodes and relationships to construct either <code>torch_geometric.data.Data</code> or
<code>torch_geometric.data.HeteroData</code> objects. The function also auto-converts any numeric or boolean property
on the nodes into tensors on the nodes that can be used as features in the <code>Data/HeteroData</code> objects.
Any property that cannot be auto-converted and the edge properties are also returned in case you need
want to manually put them into the <code>Data/HeteroData</code> objects.</p><p><strong>Colab Demonstrations:</strong>
Here are 2 Colab notebooks that you can play around with to see how you can develop graph learning
pipelines using Kùzu as your GDBMSs:</p><ol><li><a href="https://colab.research.google.com/drive/1fzcwBwTY-M19p7OOTIaynfgHFcAQo9NK" target="_blank" rel="noopener noreferrer">Node property prediction</a></li><li><a href="https://colab.research.google.com/drive/1QdX7CDdajIAb04lqaO5PfJlpKG-ljG28" target="_blank" rel="noopener noreferrer">Link prediction</a></li></ol><p>The examples demonstrate how to extract a subgraph,
train graph convolutional or neural networks (GCNs or GNNs), make some node property
or link predictions and save them back in Kùzu so you can query these predictions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="networkx-queryresultget_as_networkx-function">NetworkX: <code>QueryResult.get_as_networkx()</code> function<a href="#networkx-queryresultget_as_networkx-function" class="hash-link" aria-label="Direct link to networkx-queryresultget_as_networkx-function" title="Direct link to networkx-queryresultget_as_networkx-function">​</a></h3><p>Our <a href="https://kuzudb.com/docs/client-apis/python-api/overview.html" target="_blank" rel="noopener noreferrer">Python API</a> now has a
new <a href="/docusaurus/client-apis/python-api/query-result#query_result.QueryResult.get_as_networkx"><code>QueryResult.get_as_networkx()</code></a> function that can convert query results
that contain nodes and relationships into NetworkX directed or undirected graphs. Using this function, you can build pipelines
that benefits from Kùzu's DBMS functionalities (e.g., querying, data extraction and transformations,
using a high-level query language with very fast performance), and NetworkX's rich library of
graph analytics algorithms.</p><p><strong>Colab Demonstration:</strong>
Here is a <a href="https://colab.research.google.com/drive/1NDsnFDWcSGoaOl-mOgG0zrPG2VAr8Q6H?usp=sharing#scrollTo=AkpBul7ZpUM5" target="_blank" rel="noopener noreferrer">Colab notebook</a>
that you can play around with that shows how to do basic graph visualization of query results
and build a pipeline that computes PageRanks of a subgraph and store those PageRank
values back as new node properties in Kùzu and query them.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-import-from-and-export-to-parquet-and-arrow">Data Import from and Export to Parquet and Arrow<a href="#data-import-from-and-export-to-parquet-and-arrow" class="hash-link" aria-label="Direct link to Data Import from and Export to Parquet and Arrow" title="Direct link to Data Import from and Export to Parquet and Arrow">​</a></h2><p>We have removed our own CSV reader and instead now use <a href="https://arrow.apache.org/" target="_blank" rel="noopener noreferrer">Arrow</a>
as our default library when bulk importing data through <a href="https://kuzudb.com/docs/data-import/csv-import.html" target="_blank" rel="noopener noreferrer"><code>COPY FROM</code> statements</a>.
Using Arrow, we can not only bulk import
from CSV files but also from arrow IPC and parquet files. We detect the file type
from the suffix of the file; so if the query says <code>COPY user FROM ./user.parquet</code>,
we infer that this is a parquet file and parse it so. See the details <a href="/docusaurus/data-import/parquet-import">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="multi-labeled-or-unlabeled-queries">Multi-labeled or Unlabeled Queries<a href="#multi-labeled-or-unlabeled-queries" class="hash-link" aria-label="Direct link to Multi-labeled or Unlabeled Queries" title="Direct link to Multi-labeled or Unlabeled Queries">​</a></h2><p>A very useful feature of the query languages of GDBMSs is their
ability to elegantly express unions of join queries.
We had written about this feature of GDBMSs in this blog post about
<a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">What Every Competent GDBMS Should Do</a>
(see the last paragraph of Section <code>Feature 4: Schema Querying</code>).
In Cypher, a good example
of this is to not bind the node and relationship variables to a specific node/relationship
labels/tables. Consider this query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[e]-&gt;(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Karissa'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a, e, b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This query asks for all types of relationships that Karissa can have to any possible other
node (not necessarily of label <code>User</code>) in the query. So if the database contains
<code>Likes</code> relationships from <code>Users</code> to <code>Comments</code>, <code>Follows</code> relationships
from <code>Users</code> to <code>Users</code>, and <code>LivesIn</code> relationships from <code>Users</code> and <code>Cities</code>,
variables e and b can bind to records from all of these
relationship and node labels, respectively. </p><p>You can also restrict the labels of nodes/rels to a fixed set that contains
more than one label using the <code>|</code> syntax.
For example you can do:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[e:Likes|Follows]-&gt;(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Karissa'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a, e, b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This forces e to match to only Likes relationship or Follows relationship records (so
excludes the <code>LivesIn</code> records we mentioned above). The <code>|</code> is a syntax adapted from
regexes originally and is also used in query languages that support <code>regular path queries</code>. </p><p>Kùzu now supports such queries. Our query execution
is based on performing scans of each possible node/rel table and index
and when a variable <code>x</code> can bind to multiple node/rel tables, <code>L1, L2, ..., Lk</code>,
we reserve one vector for each possible property of each node/rel table.<br>
<!-- -->If anyone has any optimizations to do something smarter, it would be very interesting
to hear!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="other-important-changes">Other Important Changes<a href="#other-important-changes" class="hash-link" aria-label="Direct link to Other Important Changes" title="Direct link to Other Important Changes">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="enhanced-string-features">Enhanced String Features<a href="#enhanced-string-features" class="hash-link" aria-label="Direct link to Enhanced String Features" title="Direct link to Enhanced String Features">​</a></h3><p>We've added two important features to enhance Kùzu's ability to store and process strings:</p><p>1) Support of UTF-8 characters. With the help of <a href="https://github.com/JuliaStrings/utf8proc" target="_blank" rel="noopener noreferrer">utf8proc</a>, you can now store string node/relationship
properties in Kùzu that has UTF-8 characters;
2) Support of <a href="/docusaurus/cypher/expressions/pattern-matching">regex pattern matching</a> with strings. Kùzu now supports Cypher's <code>=~</code> operator for regex searches, which will return true if its pattern mathces the entire input string. For example: <code>RETURN 'abc' =~ '.*(b|d).*';</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="case-expression">CASE Expression<a href="#case-expression" class="hash-link" aria-label="Direct link to CASE Expression" title="Direct link to CASE Expression">​</a></h3><p>We've added <a href="/docusaurus/cypher/expressions/case-expression">CASE</a> for conditional expressions.
Two forms (<a href="/docusaurus/cypher/expressions/case-expression#simple-form">Simple Form</a> and <a href="/docusaurus/cypher/expressions/case-expression#general-form">General Form</a>) of CASE expression are supported.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="alterdropsetdelete">ALTER/DROP/SET/DELETE<a href="#alterdropsetdelete" class="hash-link" aria-label="Direct link to ALTER/DROP/SET/DELETE" title="Direct link to ALTER/DROP/SET/DELETE">​</a></h3><p>We added <a href="/docusaurus/cypher/ddl#alter-table">ALTER TABLE</a> and <a href="/docusaurus/cypher/ddl#drop-table">DROP TABLE</a> DDL statements.
After creating a new node or relationship table, you can now drop it, rename it, and alter it by adding new columns/properties,
renaming or dropping existing columns/properties.</p><p>Besides schema level changes, you can change properties of existing nodes/rels with <a href="/docusaurus/cypher/data-manipulation-clauses/set">SET</a> statements, and remove existing nodes/rels with <a href="/docusaurus/cypher/data-manipulation-clauses/delete">DELETE</a> statements.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="disable-relationships-with-multiple-source-or-destination-labels">Disable Relationships with Multiple Source or Destination Labels<a href="#disable-relationships-with-multiple-source-or-destination-labels" class="hash-link" aria-label="Direct link to Disable Relationships with Multiple Source or Destination Labels" title="Direct link to Disable Relationships with Multiple Source or Destination Labels">​</a></h3><p>We now no longer support defining a relationship between multiple source or destination labels.
This is to simplify our storage. But please let us know if you have strong use cases on this.</p><p>Enjoy our new release and don't forget to donate to the earthquake victims.</p><div class="footnotes"><hr><ol><li id="fn-1-4af10a">For Türkiye two other organizations are <a href="https://en.afad.gov.tr/earthquake-campaign" target="_blank" rel="noopener noreferrer">AFAD</a>, which is the public institute for coordinating natural disaster response and <a href="https://www.akut.org.tr/en/donation" target="_blank" rel="noopener noreferrer">Akut</a>, a volunteer-based and highly organized search and rescue group. For Syria, another campaign I can recommend is <a href="https://molhamteam.com/en/campaigns/439?fbclid=IwAR3_t443XME9Gh0r75KM4VpQ58WLNPd8w8tyMV2JprdObwecPwhWAdX2FOQ" target="_blank" rel="noopener noreferrer">Molham Team</a>, which is an organization founded by Syrian refugee students.<a href="#fnref-1-4af10a" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Kùzu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Factorization & Great Ideas from Database Theory]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/factorization</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/factorization"/>
        <updated>2023-01-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Many of the core principles of how to develop DBMSs are well understood.]]></summary>
        <content type="html"><![CDATA[<p>Many of the core principles of how to develop DBMSs are well understood.
For example, a very good query compilation paradigm is to
map high-level queries to a logical plan of relational operators, then optimize this plan,
and then further map it to an executable code often in the form of a physical query plan.
Similarly, if you want updates to a DBMS to be atomic and durable,
a good paradigm is to use a write-ahead log that serves as a source of truth
and can be used to undo or redo operations. Many systems adopt such common wisdom paradigms.
As core DBMS researcher, once in a while however, you run into a very simple idea
that deviates from the norm that gets you very excited.
Today, I want to write about one such idea called <a href="https://www.cs.ox.ac.uk/dan.olteanu/papers/os-sigrec16.pdf" target="_blank" rel="noopener noreferrer">factorization</a>. </p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>Overview of Factorization &amp; Why Every GDBMS Must Adopt It</strong>: Factorization
is a compression technique to compress the intermediate results
that query processors generate when evaluating many-to-many (m-n) joins.
Factorization can compress an intermediate result size exponentially
in the number m-n joins in the query.</li><li><strong>Example Benefits of Factorization</strong>: Benefits of keeping intermediate
results smaller reduces the computation processors perform
on many queries. Examples include reducing copies by keeping the output
data size small, reducing filter and expression evaluation computations exponentially,
and performing very fast aggregations.</li><li><strong>How Kùzu Implements Factorization:</strong> Kùzu's query processor
is designed to achieve 3 design goals: (i) factorize intermediate results;
(ii) always perform sequential scans of database files; and (iii) avoid
scanning large chunks of database files when possible. In addition, the processor is
vectorized as in modern columnar DBMSs. These design goals are achieved by passing
multiple <em>factorized vectors</em> between each other and using modified HashJoin operators
that do <em>sideways information passing</em> to avoid scans of entire files.</li></ul></div></div><p>This is a quite technical and long blog post and will appeal more to people who are interested
in internals of DBMSs. It's about a technique that's quite dear to my heart called factorization,
which is a very
simple data compression technique. Probably all
compression techniques you know are designed to compress database files that
are stored on disk. Think of run-length encoding, dictionary compression, or bitpacking.
In contrast, you can't use factorization to compress your raw database files.
Factorization has a very unique property:
it is designed to compress the intermediate
data that are generated when query processors of DBMSs evaluate
many-to-many (m-n) growing joins. If you have read <a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">my previous blog</a>,
efficiently handling m-n joins was one of the items on my list of properties
that competent GDBMSs should excel in. This is because
the workloads of GDBMSs commonly contain m-n joins
across node records. Each user in a social network or an account in a financial transaction network
or will have thousands of connections and if you want
a GDBMS to find patterns on your graphs, you are
asking queries with m-n joins. Factorization is directly designed
for these workloads and because of that every competent GDBMS must develop
a factorized query processor. In fact, if I were to try to write a new analytical RDBMS,
I would probably also integrate factorization into it.</p><p>This post forms the 2nd part of my 3-part posts on the contents of our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>
where we introduced Kùzu. The 3rd piece will be on another technique called worst-case
optimal join algorithms, which is also designed for a specific class of m-n joins.
Both in this post and the next, I have two goals. First is to try to articulate these techniques
using a language that is accessible to general software engineers.
Second, is to make people appreciate the role of
pen-and-paper theory in advancing the field of DBMSs. Both of these techniques were first
articulated in a series of purely theoretical papers which gave excellent
practical advice on how to improve DBMS performance.
Credit goes to the great theoreticians who pioneered these techniques whom I will cite
in these posts. Their work should be highly appreciated.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-quick-background-traditional-query-processing-using-flat-tuples">A Quick Background: Traditional Query Processing Using Flat Tuples<a href="#a-quick-background-traditional-query-processing-using-flat-tuples" class="hash-link" aria-label="Direct link to A Quick Background: Traditional Query Processing Using Flat Tuples" title="Direct link to A Quick Background: Traditional Query Processing Using Flat Tuples">​</a></h2><p>Here is a short background on the basics of
query processors before I explain factorization. If you know about
query plans and how to interpret them,
you can skip to <a href="#factorization-in-a-nutshell">here</a> after reading
my running example.
Consider a database of Account node and Transfer edge records below.
The two Accounts with <code>accID</code> fields L1 and L2 are owned by Liz and
each have 100 incoming and 100 outgoing Transfer edges.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/2-hop-data-f6b23b452caf27325fa61decfcd9caf5.png" width="600" class="img_ev3q"></div><p>Now consider a 2-hop path query in Cypher returning the accID's of source
and destinations of money flows Liz's accounts are facilitating:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[t1:Transfer]-&gt;(b:Account)-[t2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = 'Liz' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.accID, c.accID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here's the SQL version of the query if you modeled your records as relations.
Same query different syntax:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT a.accID, c.accID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM Account a, Transfer t1, Account b, Transfer t2, Account c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = 'Liz' AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      t1.src = a.accID AND t1.dst = b.accID AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      t2.src = b.accID AND t2.dst = c.accID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A standard query plan for this query is shown on the left in Fig. 2.
The plan contains some Scan operators to scan the raw node or edge records (edges could be
scanned from a join index) and some hash join operators to perform the joins, and
a final projection operator.
In some GDBMSs, you might see "linear plans" that look as in Fig. 3.</p><p><span><img loading="lazy" src="/docusaurus/assets/images/2-hop-query-plan-hash-join-4b456e97e0868d0d610f7c19ef0c967d.png" style="width:50%" class="img_ev3q"></span><span><img loading="lazy" src="/docusaurus/assets/images/2-hop-query-plan-extend-b249053ba0d9846fda95e80c16948986.png" style="width:50%" class="img_ev3q"></span></p><p>The linear plan is from our previous GraphflowDB system. Here
you are seeing an operator called Extend, which joins node records with their Transfer relationships to
read the system-level IDs of the neighbors of those node records.
Following the Extend is another Join operator to join the accID properties of those neighbors
(specifically c.accID and a.accID).
In Neo4j, you'll instead see an Expand(All) operator, which does the Extend+Join
in GraphflowDB in a single operator<sup id="fnref-1-10fd85"><a href="#fn-1-10fd85" class="footnote-ref">1</a></sup>. For very good reasons
we removed these Extend/Expand type operators in Kùzu. I will come back to this.</p><p>The interpretation of plans is that tuples are flowing from the bottom to top and
each operator will take in sets of tuples and produce sets of tuples (in a pipelined fashion).
The key motivation for factorization is that what flows
between operators are <strong>flat tuples</strong>. When the joins are m-n, this
leads to many data repetitions, which one way or another leads to repeated
computation in the operators. For example,
the final projection operator in our example would take the table shown in Figure 4 (left).</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/flat-vs-factorized-594937a8bc6d474e2cb571de63c42e7e.png" width="700" class="img_ev3q"></div><p>There are 20K tuples in the flat representation because both L1 and L2 are part of
100 incoming x 100 outgoing=10K many 2-paths. Notice the many repetitions in this relation:
L1, L2, or Liz values, or the values in a.accID and c.accID.
What gets replicated may change across systems. Some may replicate the actual values,
some may replicate indices where these values are stored but overall exactly 20K
tuples would be generated. This redundancy leads to redundant computation here and there
during query processing.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="factorization-in-a-nutshell">Factorization In a Nutshell<a href="#factorization-in-a-nutshell" class="hash-link" aria-label="Direct link to Factorization In a Nutshell" title="Direct link to Factorization In a Nutshell">​</a></h2><p>Factorization addresses exactly this problem. The core reason for the redundancy
is this observation: <em>given a fixed b value, all a's and c's are conditionally independent</em>.
More concretely, once b is bound to node L1, each incoming neighbor <code>a</code> for L1 will join
with each outgoing neighbor <code>c</code> of L1. If you took the first standard undergraduate course in DBMSs at a university
and you covered the theory of normalization, this is what is
called a <a href="https://en.wikipedia.org/wiki/Multivalued_dependency" target="_blank" rel="noopener noreferrer">multi-valued dependency</a>
in relations. Factorization exploits such dependencies to compress
relations using Cartesian products.
Above in Figure 4 (right),
I'm showing the same 20K tuples in a factorized format using only 400 values
(so 2<!-- -->*<!-- -->(100+100) instead of 2<!-- -->*<!-- -->100<!-- -->*<!-- -->100 values). </p><p>That's it! That's the core of the idea! Now of course, this simple observation leads to a ton of
hard and non-obvious questions that the entire theory on factorization answers. For example,
given a query, what are the "factorization structures", i.e., the Cartesian product structures
that can be used to compress it? Consider a simple query that counts the number of
paths that are slightly longer:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Wire]-&gt;(b:Account)-[:Deposit]&gt;(c:Account)-[:ETransfer]-&gt;(d:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Should you condition on b and factor out
a's from (c, d)'s or condition on c and factor out (a, b)'s from d's?
Or you could condition on (b, c) and factor out (a)'s from (d)'s?
To make a choice, a system has to reason about the number of Wire, Deposit,
and ETransfer records in the database.
How much and on which queries can you benefit from factorization?
The theoretical questions are endless.
The theory of factorization develops the formal foundation so that such questions can be answered and
provides principled first answers to these questions.
<a href="https://www.ifi.uzh.ch/en/dast/people/Olteanu.html" target="_blank" rel="noopener noreferrer">Dan Olteanu</a> and his
colleagues, who lead this field, recently won the <a href="https://databasetheory.org/ICDT/test-of-time" target="_blank" rel="noopener noreferrer">ICDT test of time award</a>
for their work on factorization. ICDT is one of the two main
academic venues for theoretical work on DBMSs.</p><p>But let's take a step back and appreciate this theory because it gives an excellent
advice to system developers: <em>factorize your intermediate
results if your queries contain many-to-many joins!</em>
Recall that GDBMSs most commonly evaluate many-to-many joins. So hence my point that
GDBMSs should develop factorized query processors.
The great thing this theory shows us is that this can all be done by static analysis of the query
during compilation time by only inspecting the dependencies between variables in
the query! I won't cover the exact rules but at least in my running example,
I hope it's clear that because there is no predicate between a's and c's, once
b is fixed, we can factor out a's from c's.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="examples-when-factorization-significantly-benefits">Examples When Factorization Significantly Benefits:<a href="#examples-when-factorization-significantly-benefits" class="hash-link" aria-label="Direct link to Examples When Factorization Significantly Benefits:" title="Direct link to Examples When Factorization Significantly Benefits:">​</a></h2><p>Factorized intermediate relations can be exponentially smaller
(in terms of the number of joins in the query)
than their flat versions, which
can yield orders of magnitude speed ups in query performance
for many different reasons. I will discuss three most obvious ones.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="less-data-copiesmovement">Less Data Copies/Movement<a href="#less-data-copiesmovement" class="hash-link" aria-label="Direct link to Less Data Copies/Movement" title="Direct link to Less Data Copies/Movement">​</a></h3><p>The most obvious benefit is that factorization reduces
the amount of data copied between buffers used by operators
during processing and to final <code>QueryResult</code> structure
that the application gets access to. For example, a very cool feature of Kùzu
is that it keeps final outputs in factorized format in its <code>QueryResult</code> class and
enumerates them one by one only when the user starts calling <code>QueryResult::getNext()</code>
to read the tuples.
In our running example, throughout processing Kùzu would do copies of
400 data values roughly instead of 20K to produce its <code>QueryResult</code>.
Needless to say, I could have picked a more exaggerated query, say a "star" query
with 6 relationships, and arbitrarily increased the difference in the copies done
between a flat vs factorized processor.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fewer-predicate-and-expression-evaluations">Fewer Predicate and Expression Evaluations<a href="#fewer-predicate-and-expression-evaluations" class="hash-link" aria-label="Direct link to Fewer Predicate and Expression Evaluations" title="Direct link to Fewer Predicate and Expression Evaluations">​</a></h3><p>Factorization can also reduce the amount of predicate or expression executions the system performs.
Suppose we modify our 2-hop query a bit and put two additional filters on the query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1:Transfer]-&gt;(b:Account)-[e2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = 'Liz' AND a.balance &gt; b.balance AND c.balance &gt; b.balance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>I'm omitting a plan for this query but a common plan would extend the plan in Figure 2 (or 3) above
to also scan the balance properties and to run two filter operations:
(i) above the join that joins a's and b's,
to run the predicate <code>a.balance &gt; b.balance</code>; (ii) after the final join in Figure 2
to run the predicate <code>c.balance &gt; b.balance</code>. Suppose the first filter did not eliminate any tuples.
Then, a flat processor would evaluate 20K filter executions in the second filter.
In contrast, the input to the second filter operator in a factorized processor
would be the 2 factorized tuples
shown in Figure 4 (right) but extended with <code>balance</code> properties
on a, b, and c's. Therefore there would be only 200 filter executions: (i)
for the first factorized tuple, there are only
100 comparisons to execute <code>c.balance &gt; b.balance</code> since b is matched to a single
value and there are 100 c values.; (ii) similarly for the 2nd factorized tuple.
We can obtain similar benefits when running other expressions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="aggregations">Aggregations<a href="#aggregations" class="hash-link" aria-label="Direct link to Aggregations" title="Direct link to Aggregations">​</a></h3><p>This is perhaps where factorization yields largest benefits.
One can perform several aggregations directly on factorized tuples using
algebraic properties of several aggregation functions. Let's
for instance modify our above query to a count(<!-- -->*<!-- -->) query: Find the number of 2-paths that Liz is
facilitating. A factorized processor can simply count that there are 100<!-- -->*<!-- -->100 flat tuples in the first
factorized tuple and similarly in the second one to compute that the answer is 20K.
Or consider doing min/max aggregation on factorized variables:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1:Transfer]-&gt;(b:Account)-[e2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.accID = 'L1'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN max(a.balance), min(c.balance)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is asking: find the 2-path money flow that Liz's L1 account facilitates from the highest
to lowest balance accounts (and only print the balances). If a processor
processes the 10K 2-paths that L1 is part of in factorized form, then
the processor can  compute the max and min aggregations
with only 100 comparisons each (instead of 10K comparisons each). </p><p>In short, the benefits of factorizing intermediate results just
reduces computation and data copies here and there in many cases.
You can try some of these queries on Kùzu and compare its performance on large
datasets with non-factorized systems. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-does-kùzu-perform-factorized-query-processing">How Does Kùzu Perform Factorized Query Processing?<a href="#how-does-kùzu-perform-factorized-query-processing" class="hash-link" aria-label="Direct link to How Does Kùzu Perform Factorized Query Processing?" title="Direct link to How Does Kùzu Perform Factorized Query Processing?">​</a></h2><p>The rest will be even more technical and forms part of the technical meat of our CIDR paper;
so continue reading if you are interested in database implementations.
When designing the query processor of Kùzu, we had 3 design goals: </p><ol><li>Factorize intermediate growing join results. </li><li>Always perform sequential scans of database files from disk.</li><li>When possible avoid scanning entire database files from disk.</li></ol><p>3rd design goal requires some motivation, which I will provide below. Let's go one by one.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-factorization">1. Factorization<a href="#1-factorization" class="hash-link" aria-label="Direct link to 1. Factorization" title="Direct link to 1. Factorization">​</a></h3><p>Kùzu has a vectorized query processor, which is the common wisdom
in analytical read-optimized systems. </p><img loading="lazy" align="left" style="width:350px;padding-right:15px" src="/docusaurus/assets/images/factorized-vectors-5e7e7335c81a47582cf52137070880af.png" class="img_ev3q">Vectorization, in the context of DBMS query processors refers to the design where operators pass a set of tuples, 1024 or 2048, between each other during processing[^2]. Existing vectorized query processors (in fact processors of all systems I'm aware of) pass *a single vector of flat tuples*. Instead, Kùzu's operators pass (possibly) multiple *factorized vectors of tuples* between each other. Each vector  can either be *flat* and represent a single value or *unflat* and represent a set of values, which is marked in a field called `curIdx` associated with each vector. For example, the first 10K tuples from my running example would be represented with 3 factorized vectors as on the left and would be passed to the final projection in the query plan in Figure 2. The interpretation is this: what is passed is the Cartesian product of all sets of tuples in those vectors. Operators know during compilation time how many vector groups they will take in and how many they will output. Importantly, we still do vectorized processing, i.e., each primitive operator operates on a vector of values inside tight for loops. Credit where credit's due: this simple-to-implement design was proposed by my PhD student [Amine Mhedhbi](http://amine.io/) with some feedback from me and my ex-Master's student [Pranjal Gupta](https://www.linkedin.com/in/g31pranjal/?originalSubdomain=in) and [Xiyang Feng](https://www.linkedin.com/in/xingyang-feng-14198491/?originalSubdomain=ca), who is now a core developer of Kùzu. And we directly adopted it in Kùzu. Amine has continued doing other excellent work on factorization, which we have not yet integrated, and you will need to wait until his PhD thesis is out.<h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-ensuring-sequential-scans">2. Ensuring Sequential Scans<a href="#2-ensuring-sequential-scans" class="hash-link" aria-label="Direct link to 2. Ensuring Sequential Scans" title="Direct link to 2. Ensuring Sequential Scans">​</a></h3><p>I already told you above that
Extend/Expand type join operators lead to non-sequential scans of database files.
These operators are not robust and if you are developing a disk-based system:
non-sequential scans will kill you on many queries. That's a mistake. Instead,
Kùzu uses (modified) HashJoins which are much more robust. HashJoins do not perform any scans
as part of the actual join computation so if the down stream scans
are sequential, you get sequential scans. I'll give a simulation momentarily.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-avoiding-full-scans-of-database-files">3. Avoiding Full Scans of Database Files<a href="#3-avoiding-full-scans-of-database-files" class="hash-link" aria-label="Direct link to 3. Avoiding Full Scans of Database Files" title="Direct link to 3. Avoiding Full Scans of Database Files">​</a></h3><p>Although I don't like Extend/Expand-type join operators,
they have a performance advantage. Suppose you had a simple 1-hop query that only asked for
the names of accounts that Liz's L1 account has transfered money to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.accID = 'L1'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b.name</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Suppose your database has billions of transfers but L1 has made only 3 transfers to
accounts with system-level record/node IDs: 107, 5, and 15. Then if you had
a linear plan like I showed in Figure 3, then an Extend/Expand-type
operator could read these system-level IDs and then only scan
the name properties of these 3 nodes, avoiding the full scan of the names
of all Accounts. If your query needs to read neighborhoods of millions of nodes,
this type of  computation that "reads the properties of each node's neighbors"
will degrade very quickly because: (i) each neighborhood
of each node will require reading
different parts of the disk files that store those properties; and (ii)
the system might repeatedly read the same properties over and over from disk,
as nodes share neighbors.
Instead, you want to
read all of the properties and create a hash table and read those properties
from memory.
However, if your query is accessing the neighborhoods of a few nodes,
then avoiding the scan of entire database file is an advantage.
In Kùzu, we wanted to use HashJoins but we also wanted a mechanism to scan
only the necessary parts of database files. We
do this through a technique called <em>sideways information passing</em><sup id="fnref-3-10fd85"><a href="#fn-3-10fd85" class="footnote-ref">3</a></sup>.
I'll simulate this below.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-simple-simulation">A Simple Simulation<a href="#a-simple-simulation" class="hash-link" aria-label="Direct link to A Simple Simulation" title="Direct link to A Simple Simulation">​</a></h3><p>For simplicity, we'll work on a simpler 1-hop query, so the benefits of factorization will not
be impressive but it will allow me to explain an entire query processing pipeline.
Consider this count(<!-- -->*<!-- -->) query that counts the number of transfers the L1 account has made:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[t1:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.accID = L1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An annotated query plan we generate is shown below. The figure shows step by step
the computation that will be performed and the data that will be passed between operators.
For this simulation, I am assuming that the record/nodeIDs of Accounts are as in
Figure 1a above.</p><img loading="lazy" align="left" style="width:500px;padding-right:15px" src="/docusaurus/assets/images/factorized-execution-simulation-bce4e5f587ddf2548a7052a96c74fd54.png" class="img_ev3q"><ol><li>A Scan operator will scan the accId column and find the records of
nodes with accID=L1. There is only 1 tuple (199, Liz) that will be output.</li><li>This tuple will passed to HashJoin's build side, which will create a hash table from it.</li><li>At this point the processor knows exactly the IDs of nodes, whose Transfer edges need
to be scanned on the probe side: only the edges of node with ID 199! This is where we
do sideways information passing.
Specifically, the HashJoin constructs and passes a "nodeID filter" (effectively a bitmap)
to the probe side Scan operator. Here, I'm assuming the database has 1M Accounts but as you
can see only the position 199 is 1 and others are 0.</li><li>The probe-side Scan uses the filter to only scan
the edges of 199 and avoids
scanning the entire Transfers file.
Since Kùzu is a GDBMS, we store the edges of nodes (and their properties)
in a graph-optimized format called <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)" target="_blank" rel="noopener noreferrer">CSR</a>.
Importantly, all of the edges of 199 are stored consecutively and we output them in factorized format as:
<!-- -->[(199) X {201, 202, ..., 300}]<!-- -->.</li><li>Next step can be skipped in an optimized system but currently we will probe the <!-- -->[(199) X {201, 202, ..., 300}]<!-- -->
tuple in the hash table and produce <!-- -->[(199, L1) X {201, 202, ..., 300}]<!-- -->, which is passed to the
final aggregation operator.</li><li>The agggregation operator counts that there are 100 "flat" tuples in <!-- -->[(199, L1) X {201, 202, ..., 300}]<!-- -->, simply
by inspecting the size of the 2nd vector {201, 202, ..., 300} in the tuple.</li></ol><p>As you see the processing was factorized, we only did sequential scans
but we also avoided scanning the entire Transfer database file, achieving our 3 design goals.
This is a simplifid example and there are many queries that are more complex and where we
have more advanced modified hash join operators. But the simulation presents all core techniques
in the system. You can read our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>
if you are curious about the details!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="example-experiment">Example Experiment<a href="#example-experiment" class="hash-link" aria-label="Direct link to Example Experiment" title="Direct link to Example Experiment">​</a></h3><p>How does it all perform? Quite well! Specifically this type of processing is quite robust.
Here's an experiment from our CIDR paper to give a sense of the behavior of
using modified hash joins and factorization on a micro benchmark query. This query
does a 2-hop query with aggregations on every node variable. This is on
an <a href="https://ldbcouncil.org/benchmarks/snb/" target="_blank" rel="noopener noreferrer">LDBC</a>
social network benchmark (SNB) dataset at scale factor 100 (so ~100GB of database). LDBC SNB
models a social network where user post comments and react to these comments. </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Comment)&lt;-[:Likes]-(b:Person)-[:Likes]-&gt;(c:Comment)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.ID &lt; X</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN min(a.ID), min(b.ID), min(c.ID)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Needless to say, we are picking this as it is a simple query that can demonstrate
the benefits of all of the 3 techniques above. Also needless to say, we could have exaggerated
the benefits by picking
larger stars or branched tree patterns but this will do.
In the experiment we are changing the selectivity of the predicate on the middle node, which
changes the output size. What we will compare is the behavior of Kùzu, which integrates
the 3 techniques above with (i) Kùzu-Extend: A configuration of Kùzu that uses factorization but instead of
our modified HashJoins uses an Extend-like operator;
and (ii) <a href="https://umbra-db.com/" target="_blank" rel="noopener noreferrer">Umbra</a><sup id="fnref-4-10fd85"><a href="#fn-4-10fd85" class="footnote-ref">4</a></sup>, which represents the
state of the art RDBMS. Umbra is as fast as existing RDBMSs get. It probably integrates
every known low-level performance technique in the field.
Umbra however does not
do factorization or have a mechanism to avoid scanning entire database files, so we
expect it to perform poorly on the above query. </p><p>Here's the performance table.</p><img loading="lazy" align="right" style="width:350px;padding-right:15px" src="/docusaurus/assets/images/2-hop-factorization-experiment-5ae1d2d68925fa1166f7d9b11f203171.png" class="img_ev3q">When the selectivity is very low, Extend-like operators + factorization do quite well because they don't yet suffer much from non-sequential scans and they avoid several overheads of our modified hash joins: no hash table creation and no semijoin filter mask creation. But they are not robust and degrade quickly. We can also see that even if you're Umbra, without factorization or a mechanism to avoid scanning entire files, you will not perform very well on these queries with m-n joins (even if there is only 2 of them here). We conducted several other experiments all demonstrating the robustness and scalability of factorized processing using modified hash join operators. I won't cover them but they are all in [our CIDR paper](https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf).<h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-marks">Final marks:<a href="#final-marks" class="hash-link" aria-label="Direct link to Final marks:" title="Direct link to Final marks:">​</a></h2><p>I am convinced that modern GDBMSs have to be factorized systems to remain
competitive in performance. If your system assumes that most joins will be growing,
factorization is one of a handful of modern technique for such workloads
whose principles are relatively well understood
and one can actually implement in a system. I am sure different factorized query processors will
be proposed as more people attempt at it. I was happy to see in CIDR that at least 2 systems
gurus told me they want to integrate factorization into their systems.
If someone proposes a technique that can on some queries
lead to exponential computation reductions even in a pen-and-paper theory, it is a good sign
that for many queries it can make the difference between a system timing out vs providing
an actual answer.</p><p>Finally  there is much more on the theory of factorization, which I did not cover. From my side,
most interestingly, there
are even more compressed ways to represent the intermediate results than the
vanilla Cartesian product scheme I covered in this post. Just to raise some curiosity, what I have
in mind is called
<a href="https://fdbresearch.github.io/principles.html" target="_blank" rel="noopener noreferrer">d-representations</a> but that will have to wait
for another time. For now, I invite you to check our performance out on large queries
and let us know if we are slow on some queries! The Kùzu team says hi (👋 🙋‍♀️ 🙋🏽) and
is at your service to fix all performance bugs as we continue implementing the system!
My next post will be about the novel <a href="/docusaurus/blog/wcoj">worst-case optimal join algorithms</a>, which emerged
from another theoretical insight on m-n joins! Take care until then!</p><div class="footnotes"><hr><ol><li id="fn-1-10fd85">If you come from a very graph-focused background and/or exposed to a ton of GDBMS marketing, you might react to my statement that what I am showing are standard plans that do joins. Maybe you expected to see graph-specific operators, such as a BFS or a DFS operator because the data is a graph. Or maybe someone even dared to tell you that GDBMSs don't do joins but they do traversals. Stuff like that. These word tricks and confusing jargon really has to stop and helps no one. If joins are in the nature of the computation  you are asking a DBMSs to do, calling it something else won't change the nature of the computation. Joins are joins. Every DBMSs needs to join their records with each other.<a href="#fnref-1-10fd85" class="footnote-backref">↩</a></li><li id="fn-3-10fd85">Note that GDBMSs are able to avoid scans of entire files because notice that they do the join on internal record/node IDs, which mean something very specific. If a system needs to scan the name property of node with record/node ID 75, it can often arithmetically compute the disk page and offset where this is stored, because record IDs are dense, i.e., start from 0, 1, 2..., and so can serve as  pointers if the system's storage design exploits this. This is what I was referring to as "Predefined/pointer-based joins" in my <a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">previous blog post</a>. This is a good feature of GDBMSs that allows them to efficiently evaluate the joins of node records that are happening along the "predefined" edges in the database. I don't know of a mechanism where RDBMSs can do something similar, unless they develop a mechanism to convert value-based joins to pointer-based joins. See my student <a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf" target="_blank" rel="noopener noreferrer">Guodong's work last year in VLDB</a> of how this can be done. In Kùzu, our sideways information passing technique follows Guodong's design in this work.<a href="#fnref-3-10fd85" class="footnote-backref">↩</a></li><li id="fn-4-10fd85">Umbra is being developed by <a href="https://www.professoren.tum.de/en/neumann-thomas" target="_blank" rel="noopener noreferrer">Thomas Neumann</a> and his group. If Thomas's name does not ring a bell let me explain his weight in the field like this. As the joke goes, in the field of DBMSs: there are gods at the top, then there is Thomas Neumann, and then other holy people, and then we mere mortals.<a href="#fnref-4-10fd85" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Semih Salihoğlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="internals" term="internals"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[What Every Competent GDBMS Should Do (aka The Goals & Vision of Kùzu]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/what-every-gdbms-should-do-and-vision</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/what-every-gdbms-should-do-and-vision"/>
        <updated>2023-01-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[As a co-implementor of the Kùzu GDBMS and]]></summary>
        <content type="html"><![CDATA[<p>As a co-implementor of the Kùzu GDBMS and
a professor at University of Waterloo,
I have been thinking of GDBMSs day in and day out for many years now.
After years of understanding and publishing on the architectural principles
of graph data management (<a href="http://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf" target="_blank" rel="noopener noreferrer">2</a>,
<a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf" target="_blank" rel="noopener noreferrer">3</a>,
<a href="https://www.vldb.org/pvldb/vol15/p1533-chen.pdf" target="_blank" rel="noopener noreferrer">4</a>),
we decided to develop
<a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">Kùzu</a> as a state-of-the-art modern embeddable GDBMS.
This post covers my broad opinions on GDBMSs, and the feature set they should
optimize for and why. In doing so, it also gives an overall vision of Kùzu!</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>Overview of GDBMSs</strong>: GDBMSs are relational in their cores but offer an elegant graph model
to model application data and SQL-like query languages with elegant
graph-specific syntax. Many applications, e.g., in <a href="https://tinyurl.com/3x89ceum" target="_blank" rel="noopener noreferrer">fraud detection</a>,
<a href="https://www.tigergraph.com/solutions/recommendation-engine/" target="_blank" rel="noopener noreferrer">recommendations</a>,
<a href="https://tinyurl.com/3z9bckmm" target="_blank" rel="noopener noreferrer">personalization</a>, etc. benefit from such modeling and query language features.</li><li><strong>Key Feature Set of GDBMSs</strong>: Despite being relational, GDBMSs optimize (or at
least they should!) for a distinct set of
features/use cases that RDBMSs do not traditionally optimize for: (i) pre-defined/pointer-based joins;
(ii) growing many-to-many joins;
(iii) recursive joins;
(iv) schema querying;
(v) efficient storage of semi-structured data and URIs.
GDBMSs that want to be competitive in terms of performance
need to perfect this feature set and that's exactly what Kùzu aims to do!</li><li><strong>Kùzu as the GDBMS for Graph Data Science</strong>:
One example application domain the Kùzu team is excited about is
to be a usable, efficient, and scalable GDBMS of graph data science in the Python graph analytics ecosystem.
Here we are looking at how DuckDB revolutionized tabular data science and
want to repeat it in graph data science! </li></ul></div></div><p>This week, I presented Kùzu to the database community at the <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR 2023</a>
conference in Amsterdam. For those who are not familiar with academic database conferences,
CIDR brings together work from academia and industry to discuss recent research on
systems aspects of database technology. Our paper was about Kùzu's
goals and vision and its core query processor design for evaluating complex growing joins.
We intentionally targeted CIDR for our paper because of its systems
focus and we thought many system gurus would be there: the attendees included
creators of <a href="https://www.monetdb.org/" target="_blank" rel="noopener noreferrer">MonetDB</a>, <a href="https://en.wikipedia.org/wiki/Vectorwise" target="_blank" rel="noopener noreferrer">Vectorwise</a>,
<a href="https://duckdb.org/" target="_blank" rel="noopener noreferrer">DuckDB</a>,
<a href="https://www.snowflake.com/en/" target="_blank" rel="noopener noreferrer">Snowflake</a>, <a href="https://www.databricks.com/" target="_blank" rel="noopener noreferrer">Databricks</a>, amongst others. It also meant a lot to share
our ambitious goal of developing a usable GDBMS from an academic setting in this CIDR because
it was  organized locally by CWI. The late <a href="https://en.wikipedia.org/wiki/Martin_L._Kersten" target="_blank" rel="noopener noreferrer">Martin Kersten</a>
founded the CWI database group and was a pioneer of this style of research projects and
his successors are continuing this tradition very successfully today.
CWI has created many successful DBMSs, including MonetDB (Martin's legacy), Vectorwise, and
most recently DuckDB. People paid their respects to Martin during an emotional memorial
on the first night of the conference.
As a surprise, <a href="https://memgraph.com/" target="_blank" rel="noopener noreferrer">MemGraph</a> co-founder and CTO  <a href="https://www.linkedin.com/in/markobudiselic/" target="_blank" rel="noopener noreferrer">Marko Budiselić</a>
was also there (it was his first CIDR)! Marko is an extremely friendly
and humble person you should meet and it was great to share our insights about where GDBMSs make a difference in
enterprise applications.</p><p>I want to start a 3-part blog post to cover the contents of our CIDR paper in a less academic language: </p><ul><li>Post 1: Kùzu's goals and vision as a system </li><li>Post 2: <a href="/docusaurus/blog/factorization">Factorization technique for compression</a></li><li>Post 3: <a href="/docusaurus/blog/wcoj">Worst-case optimal join algorithms</a></li></ul><p>In this Post 1, I discuss the following:
(i)   <a href="#overview-of-gdbms-and-a-bit-of-history">an overview of GDBMSs</a>.
(ii)  <a href="#features-every-competent-gdbms-should-optimize-for-">the features GDBMSs should optimize  for and why;</a> and
(iii) <a href="#k%C3%B9zu-as-a-gdbms-for-graph-data-science-pipelines">an example application domain (graph data science!) we are immediately targeting with Kùzu. </a>
(ii) and (iii) should give you a good idea about the current goals and
vision of Kùzu. If you know GDBMSs well, you should skip over (i).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview-of-gdbmss-and-a-bit-of-history">Overview of GDBMSs and a Bit of History<a href="#overview-of-gdbmss-and-a-bit-of-history" class="hash-link" aria-label="Direct link to Overview of GDBMSs and a Bit of History" title="Direct link to Overview of GDBMSs and a Bit of History">​</a></h2><p>In one sentence, GDBMSs are read-optimized analytical DBMSs for modeling and querying application
data as a graph. As a consequence they are optimized for fast querying of node and
relationship records.
Modern GDBMSs, such as Neo4j, Tigergraph, MemGraph, or Kùzu,
adopt the <a href="https://neo4j.com/developer/graph-database/#property-graph" target="_blank" rel="noopener noreferrer">property graph data model</a>
(or its variants), where you can model your records as a set of labeled nodes and
edges/relationships, and key-value properties on these relationships. When
I say GDBMSs in this post, I specifically refer to the systems that adopt this
model but I will also discuss <a href="https://en.wikipedia.org/wiki/Triplestore" target="_blank" rel="noopener noreferrer">RDF systems</a> (aka triplestores)
here and there, which are also DBMSs that adopt a graph-based model.</p><p>Here's a side comment that I have to make because I'm a professor and
professors are always ready to profess.
DBMSs based on graph models are anything but new. They have existed even before the relational
model: DBMS die-hards love remembering
that the <a href="https://en.wikipedia.org/wiki/Integrated_Data_Store" target="_blank" rel="noopener noreferrer">IDS system</a> from 1960s was based on the "network model",
which is is just another term for graph. IDS was lead by the amazing
Charlie Bachmann, <img loading="lazy" align="left" style="width:380px;padding-right:15px" src="/docusaurus/assets/images/bachmann-869ea053f50b618f11a3288ac0bdb2b6.png" class="img_ev3q"> <a href="https://amturing.acm.org/award_winners/bachman_9385610.cfm" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://youtu.be/iDVsNqFEkB0" target="_blank" rel="noopener noreferrer">2</a>, <a href="https://youtu.be/jByIpJNrm50" target="_blank" rel="noopener noreferrer">3</a>), whose photo is shown on the left and who is credited for inventing DBMSs<sup id="fnref-1-f6cc9d"><a href="#fn-1-f6cc9d" class="footnote-ref">1</a></sup>.
If you click on <a href="http://wp.sigmod.org/wp-content/uploads/2012/12/image4.jpg" target="_blank" rel="noopener noreferrer">this 1962 ad of the IDS system</a>, you will see a graph of node and
edge records. Note 1960s are pre-relational times. Ever since, every decade has seen a surge of DBMSs
that adopted a graph-based model with mixed levels of adoption success:
hierarchical model, XML, and RDF are examples.
In my view, current property GDBMSs is the most generic
and suitable to model a very broad range of application data out of these.
So they probably established themselves most successfully out of these.
There is a very fundamental reason why graph-based DBMSs have always existed and will
always exist: graphs and tables are the two most natural and generic abstract data structures
to model application data. It's no surprise they were the first two proposed data models
when the field of DBMSs were born and both have existed ever since and will continue to exist.</p><p>Back to property GDBMSs. How about their query languages? They support SQL-like high-level
query languages with several graph-specific syntax.
I call them "graph-specific" SQL. Let's look at a query snippet. Assume this is
on a database that models a set of financial "accounts" and money "transfers"
between accounts:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b.ID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is a query expressed in Cypher. Instead of a SELECT/FROM/WHERE,
you are looking at MATCH/WHERE/RETURN.
If intelligent Martians saw Cypher and SQL, their immediate reaction
would not be to notice the minor syntactic differences but instead
the fundamental similarities:  their clauses describe joins,
filters, projections, group by and aggregates, and other relational
operations that process sets of tuples.
There is of course syntactic differences that are important. Query languages of
GDBMSs adopt graph-specific syntax that are often very elegant to express several computations.
For example, the arrow syntax ((a)-<!-- -->[e]<!-- -->-&gt;(b)) in Cypher describes joins between node records. This
is much more elegant than listing names of tables that model
node records in a FROM clause, with a complex WHERE clause.
Much more importantly, they adopt a very elegant and direct syntax,
such as the Kleene star "*", to
express recursive queries. Expressing recursive computations with vanilla SQL is
objectively harder. I'll come to recursive queries later.</p><p>Now get ready for a blasphemous observation: <em>GDBMSs are relational at their cores!</em><sup id="fnref-2-f6cc9d"><a href="#fn-2-f6cc9d" class="footnote-ref">2</a></sup>.
Well, OK anyone who has studied the principles of DBMSs knows there is nothing
blasphemous here because GDBMSs actually have to be relational
because of this simple fact:
<em>the only known practical way to implement declarative high-level
query languages is to compile them to relational operators that
take in and output sets of tuples</em>. Type "Explain" to any of your
queries in your favorite  GDBMs (or RDF system) and look at their query plans and
you will see joins, scans, filters, projections, group bys, unions,
intersections, etc. You might see some graph-specific operators
but they will also be processing sets of tuples. That was the primary
observation of <a href="https://en.wikipedia.org/wiki/Edgar_F._Codd" target="_blank" rel="noopener noreferrer">Ted Codd</a> when he proposed
that data management should be done by systems implementing
relational operators that process sets of tuples. </p><p>But don't worry, I do love GDBMSs and you should too! The fact that at their cores
GDBMSs are relational doesn't mean they don't offer value beyond RDBMSs.
DBMSs are very complex software systems and they make a ton of design tradeoffs in terms of
what they optimize for. There is a very distinctive set of technical features that
GDBMSs should optimize for and excel in, where RDBMSs and SQL traditionally don't.
This feature set is exactly what
Kùzu aims to perfect over time, which is what I hope to articulate in this post.
In short: GDBMSs do offer a ton of value if
they are architected correctly and every software engineer should know
about GDBMSs<sup id="fnref-3-f6cc9d"><a href="#fn-3-f6cc9d" class="footnote-ref">3</a></sup>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="features-every-competent-gdbms-should-optimize-for-">Features Every Competent GDBMS Should Optimize For <sup id="fnref-4-f6cc9d"><a href="#fn-4-f6cc9d" class="footnote-ref">4</a></sup><a href="#features-every-competent-gdbms-should-optimize-for-" class="hash-link" aria-label="Direct link to features-every-competent-gdbms-should-optimize-for-" title="Direct link to features-every-competent-gdbms-should-optimize-for-">​</a></h2><p>Here is a list of features that differentiate GDBMSs from RDBMSs and GDBMS should
highly optimize for and support.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-1-pre-definedpointer-based-joins">Feature 1: Pre-defined/pointer-based Joins<a href="#feature-1-pre-definedpointer-based-joins" class="hash-link" aria-label="Direct link to Feature 1: Pre-defined/pointer-based Joins" title="Direct link to Feature 1: Pre-defined/pointer-based Joins">​</a></h3><p>This is perhaps the most ubiquitously adopted technique in GDBMSs that is ubiquitously missing in RDBMSs.
Although GDBMSs
can join arbitrary node records with each other, most common user queries in GDBMSs
join node records with their "neighbors". A GDBMS knows about these
neighbor node records because they are predefined to the system as relationships.
So GDBMSs universally exploit this and optimize for these types of joins. For example,
almost universally they all create a <strong>join index</strong> (aka an adjacency list index)<sup id="fnref-5-f6cc9d"><a href="#fn-5-f6cc9d" class="footnote-ref">5</a></sup>.
Here's a demonstrative example showing a "forward", i.e., from src to dst, join index:</p><img loading="lazy" src="/docusaurus/assets/images/ex-fwd-join-index-01ddee0dcd0796d42d3381aa4bc6fe55.png" width="800" class="img_ev3q"><p>Note that the join index does not store the actual data values, which
are strings (e.g., "Ali", "Noura", etc.) in the example. Instead,
it stores dense system level node record IDs.
As a result, GDBMSs can be fast on these joins because they can use: (1) the join index;
and (2) dense integer IDs to joins (instead of, say running string equality conditions). </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-2-many-to-many-growing-joins">Feature 2: Many-to-many Growing Joins<a href="#feature-2-many-to-many-growing-joins" class="hash-link" aria-label="Direct link to Feature 2: Many-to-many Growing Joins" title="Direct link to Feature 2: Many-to-many Growing Joins">​</a></h3><p>In many application data stored on GDBMSs, node records
have many-to-many relationships with each other. Think of any data as a graph,
say a network of financial transactions or who bought which items or
who is friends with whom. In many of these datasets, an entity/node connects with
many other nodes. In addition, many of the killer apps of GDBMSs search for complex patterns
on these relationships.
A classic example we like using is a Twitter friend recommendation engine that is looking for diamond patterns to implement
the following rule: If a user A follows two users B and C, who both follow D, recommend
D to A. This is the pattern:</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/diamond-pattern-b3e602c75216b281c99ae5cddb25b2ce.png" width="200" class="img_ev3q"></div><p>The whitepapers of existing GDBMSs are full of these patterns, e.g., branching trees, money laundering circles,
cliques of customers who buy similar items, etc. These correspond to complex
many-to-many joins, which by their nature are growing. If on average each of your nodes
connect with k other nodes and you have t many relationships in the pattern you are searching,
you are asking a system to search through k^t many possible combinations and guess what: exponential
functions are scary. We have been advocating the integration of 2 specific techniques
into the query processors of GDBMSs for several years now: (i) factorization; and (ii) worst-case optimal joins.
Both of these techniques are specifically designed for
many-to-many growing joins and we have integrated them in Kùzu. Stay tuned for for my next two posts on this. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-3-recursive-join-queries">Feature 3: Recursive Join Queries<a href="#feature-3-recursive-join-queries" class="hash-link" aria-label="Direct link to Feature 3: Recursive Join Queries" title="Direct link to Feature 3: Recursive Join Queries">​</a></h3><p>This is probably the most obvious feature where GDBMSs should excel in. First, objectively
the query languages of GDBMSs have much better support
for recursive join queries than SQL. Consider this query on our previous financial transaction network
example: "Give me all direct or indirect money flows into Alice's account from Canada." Now
look at this elegant way to ask this in Cypher using the Kleene star '<!-- -->*<!-- -->':</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Transfer*]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.country = 'Canada' and b.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.ID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similar to regexes, '<!-- -->*<!-- -->' represents possible 1 or more repetitions of the Transfer
edge in the join. So the join could be a direct join between (a) and (b) or a 2-hop one,
or a 3-hop one etc. You can do this with SQL of course, but it's objectively harder. Recursion
has been an afterthought when standardizing SQL. It came 20 years after SQL standardization started and is really a hack.
In contrast, recursion has been first-class citizen
feature in every graph-based DBMS's query language.
This distinction is even much more visible
if you want to do other graph-specific recursive computation, such as finding shortest paths.
In  Kùzu, we are starting to work on implementing
and optimizing recursive query support and we hope to have first a basic version and
then optimized versions that hopefully works very well and contributes to the principles of how these
queries should be evaluated.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-4-schema-querying">Feature 4: Schema Querying<a href="#feature-4-schema-querying" class="hash-link" aria-label="Direct link to Feature 4: Schema Querying" title="Direct link to Feature 4: Schema Querying">​</a></h3><p>Another important feature of GDBMSs that cannot be done in
RDBMSs is that the query languages allow querying the schema of a database in addition
to the data in the database. Suppose in a modified financial transaction network,
there are three relationship types: Wire, Deposit, and ETransfer and you
you wanted to search for a path where the first edge and the second edge types
are different. Note that the predicate is <em>on the schema</em>, specifically on the type
of the nodes/relations. You can write the following query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1]-&gt;(b:Account)-[e2]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE type(e1) != type(e2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Something akin to this cannot directly be done in SQL. One would have to write a query
that unions many sub-queries: one that joins node records over Wire and then Deposit,
another on Wire and ETransfer, another on Deposit and then Wire etc. This will be
messy. The ability to <em>not</em> specify a label on relationships,
specifically on e1 and e2, is an
elegant way to effectively express such unions of join queries.
It says: "join a and b nodes over every possible relationship".
The <code>type()</code> function on these variables allows doing querying over the schema.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs">Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., "Knowledge Graphs")<a href="#feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs" class="hash-link" aria-label="Direct link to Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)" title="Direct link to Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)">​</a></h3><p>An important application domain of GDBMSs
is "knowledge graphs". This term means different things
in different contexts and I'll take it
to refer to highly heterogenous datasets that are
often naturally modeled as RDF triples. Again, I don't want to go into the
details of this model but I assume many readers will already be familiar with
RDF. RDF is a simple data model where data is represented as (subject, predicate, object)
triples that represent facts about a domain. A great application is when modeling and
querying encyclopedic facts, such as those extracted from Wikipedia data.
For example, the following triple stores the fact
that Justin Trudeau is married to Sophie Trudeau:
(<a href="http://dbpedia.org/resource/Justin_Trudeau" target="_blank" rel="noopener noreferrer">http://dbpedia.org/resource/Justin_Trudeau</a>, <a href="http://dbpedia.org/ontology/spouse" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/spouse</a>,
<a href="http://dbpedia.org/resource/Sophie_Gr%C3%A9goire_Trudeau" target="_blank" rel="noopener noreferrer">http://dbpedia.org/resource/Sophie_Grégoire_Trudeau</a>).
There are 2 immediate challenges for a DBMS to manage
such data: </p><ol><li><p>Structuring such datasets is very difficult. Structuring here
refers to designing a relational schema for the data.
Entities can have many types, e.g., Justin Trudeau is both a "rdf:type"
<a href="http://dbpedia.org/ontology/Person" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/Person</a> as well as
<a href="http://dbpedia.org/ontology/Politician" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/Politician</a>. Further, within a single type, entities can have many different
and distinct properties, so good luck coming up with and maintaining a relational
schema for all that.
This is a direct result of
the overly ambitious domain the dataset is modeling: all encyclopedic human knowledge!
You need a data model that allows flexibility in what can be associated with entities
and their types<sup id="fnref-6-f6cc9d"><a href="#fn-6-f6cc9d" class="footnote-ref">6</a></sup>.</p></li><li><p>Those long strings used to identify entities, e.g., Justin
Trudea, are called URIs (for universal resource identifiers),
and queries will frequently access and specify them. So systems should
be competent in handling those.</p></li></ol><p>GDBMSs tend to support semi-structured schemas and certainly RDF systems
have good techniques to handle URIs.
These applications are directly in the realm of graph-based DBMSs.
Currently, they are directly targeted by RDF systems but I'm convinced
GDBMSs should also implement techniques to efficiently support them<sup id="fnref-7-f6cc9d"><a href="#fn-7-f6cc9d" class="footnote-ref">7</a></sup>. </p><p><strong>Final note on the above feature set:</strong> I referred to several classic applications but
many other applications require and benefit
from the above feature set.  One can
think of the dataset and workloads of these applications as the "beyond relational/SQL" datasets/workloads, which
often require modeling and querying in a graph-based DBMS, and
we want Kùzu to excel in and represent the state-of-art in this feature set! </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="kùzu-as-a-gdbms-for-graph-data-science-pipelines">Kùzu as a GDBMS for Graph Data Science Pipelines<a href="#kùzu-as-a-gdbms-for-graph-data-science-pipelines" class="hash-link" aria-label="Direct link to Kùzu as a GDBMS for Graph Data Science Pipelines" title="Direct link to Kùzu as a GDBMS for Graph Data Science Pipelines">​</a></h2><p>Finally, let me tell you a little bit about
a particular application domain we are currently excited
about and we want to see Kùzu used in: graph data science in the python ecosystem!
This figure from my CIDR slides describes this vision pictorially:</p><p><img loading="lazy" alt="Kùzu as a GDBMS for Graph Data Science Pipelines" src="/docusaurus/assets/images/kuzu-as-gdbms-of-gds-021cc66c81dd650fbe66c9168e0eced1.png" width="2433" height="1938" class="img_ev3q"></p><p>Suppose you are building a graph analytics, machine learning, or visualization
pipeline from raw record files on disk. You will want to model your raw records
as nodes and edges, clean them, extract features, query them, transform them,
and then you will extract data to an upstream python library, such as Pytorch Geometric, DGL,
NetworkX or a graph visualization library.
You might even want a pipeline
that extracts regular tables from your graphs to a tabular data science library,
such as NumPy,
since the outputs of queries in Cypher are tables of records.
We want people to use Kùzu as an embeddable library in their Python scripts,
to do their modeling, querying, feature extraction,
cleaning, and other transformations, all by benefiting from a high-level query language
and state-of-art graph data management techniques
that we are implementing. This is exactly what DuckDB did for tabular data science/analytics.
We are looking at DuckDB here and want to fill the same gap for graph data science/analytics!
We are currently understanding the ecosystem better and appreciate feedback
and suggestions for features we should implement to enable your workloads.</p><p>OK, this is it for now. In the next two blog posts, I will discuss
factorization and worst-case optimal join algorithms and describe
some of the principles that we adopted in Kùzu's query processor.
Until then, happy new years from the cold but cozy winter of 🇨🇦
and <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">pip install kuzu</a>!</p><div class="footnotes"><hr><ol><li id="fn-1-f6cc9d">Interestingly, Bachmann is one of a handful of Turing laureates without any academic career. If you love DBMSs, <a href="https://youtu.be/iDVsNqFEkB0" target="_blank" rel="noopener noreferrer">listen to this talk</a>  where he remembers his IDS days! Amusingly, he also talks about how he didn't know who Turing was when got the Turing award and how he met Turing's mother in England for tea 😀.<a href="#fnref-1-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-2-f6cc9d">When I say GDBMSs here, I'm referring to the core engines that implement the high-level languages of these systems and not the analytics libraries (e.g., <a href="https://neo4j.com/product/graph-data-science/" target="_blank" rel="noopener noreferrer">1</a>, <a href="https://memgraph.com/mage" target="_blank" rel="noopener noreferrer">2</a>) above these core engines that run iterative graph analytics computations, such as finding connected components, or PageRank, or betweenness centrality. These computations are better understood through either direct graph formalisms or linear algebra (and not relational) operations.<a href="#fnref-2-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-3-f6cc9d">I am a strong supporter of devoting a few lectures to GDBMSs after covering the fundamental topics on the relational model and RDBMSs in core introduction to DBMSs courses in undergraduate curriculums. Students should broaden their perspectives on the available data models and query/programming languages to them when they develop applications. GDBMSs is an obvious choice here. So is Datalog and RDF/SparQL.<a href="#fnref-3-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-4-f6cc9d">We articulated this list of features in our CIDR 2023 paper. Incidentally, <a href="https://www.cidrdb.org/cidr2023/papers/p66-wolde.pdf" target="_blank" rel="noopener noreferrer">a paper</a> written by CWI on a graph query extension to DuckDB, had a 12-item list of "techniques" that GDBMSs should implement at their cores. Let me call this the CWI list. These items are not features in the sense I'm using the word, so I call them techniques. As you'll see my features are higher-level system properties from user's perspective. Peter Boncz, who is renowned in the field for having written or advised many successful DBMSs that spinned off, presented the CWI paper. I highly recommend this as another reading if you want to know more about Peter and his co-authors' technical insights about how GDBMSs should be architected. Importantly, Kùzu has integrated or is in the process of integrating 11 of the 12 techniques in the CWI list(bulk path finding is the one we have to do more thinking on) and our prior publications had also articulated many of these insights,  such as the fact that <a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf" target="_blank" rel="noopener noreferrer">GDBMSs should be columnar systems</a> doing vectorized querying and of course we did a ton of work on <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">worst-case optimal joins</a> and <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">factorization</a>, which are also in the CWI list. I should acknowledge that Peter had been advocating for some of the techniques on the CWI list at least since 2018. I remember a presentation he gave in 2018 to GDBMSs researchers and developers titled "Why are Existing GDBMSs Incompetent?", which listed some of the techniques in the CWI list and visibly has inspired the title of this blog.<a href="#fnref-4-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-5-f6cc9d">Although some refer to these as an "adjacency list index" because that's a common term in graph terminology, I need to pay my respects to the giants in the field: these are plain old <a href="https://dl.acm.org/doi/abs/10.1145/22952.22955" target="_blank" rel="noopener noreferrer">1980s Valduriez join indices</a>. And no, they were invented in the context of RDBMSs. That said, they never found much adoption in RDBMSs. But they are almost universally adopted in GDBMSs.<a href="#fnref-5-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-6-f6cc9d">Designing the schema, i.e., defining the types of entities and relationships and class structures and constraints of such complex domains can be decades of work. What I'm referring to as schema is called an "ontology" in knowledge graph/semantic web space. If you ever thought you modeled a hard application domain, take a look at <a href="https://en.wikipedia.org/wiki/SNOMED_CT" target="_blank" rel="noopener noreferrer">SNOMED</a>, which is a decades long effort to model and standardize human medical knowledge. Last term, I had a seminar on SNODEM in my graduate course on knowledge graphs and students were baffled by the complexity of this "ontology", which  describes the types of entities and their relationships and constraints, which RDF technology stack is quite good at.<a href="#fnref-6-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-7-f6cc9d">Before we released Kùzu, we had support for adding arbitrary node/edge properties but we removed a large chunk of code out of the system to release a thinner code base. So currently you need to specify a schema for your nodes and relationships in Kùzu. We will wait and see if/when that demand comes and how strongly it comes. We know from our conversations with many users and developers of GDBMSs over the years that most datasets in enterprises are not this complex and can be structured. At least after a proof of concept phase of applications, developers structure their data.<a href="#fnref-7-f6cc9d" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Semih Salihoğlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="vision" term="vision"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Meet Kùzu 🤗]]></title>
        <id>https://your-docusaurus-test-site.com/docusaurus/blog/meet-kuzu</id>
        <link href="https://your-docusaurus-test-site.com/docusaurus/blog/meet-kuzu"/>
        <updated>2022-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Today we are very excited to make an initial version of Kùzu public on github!]]></summary>
        <content type="html"><![CDATA[<p>Today we are very excited to make an initial version of <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">Kùzu public on github</a>!
Kùzu is a new embeddable property graph database management system (GDBMS) that is
designed for high scalability and very fast querying. We are releasing
Kùzu today under a permissible MIT license. Through years of research on GDBMSs, we observed a lack of
highly efficient GDBMS in the market that adopts state-of-the-art
querying and storage techniques and that can very easily integrate into applications,
similar to DuckDB or SQLite. Kùzu aims to fill this space and evolve into the
go-to open-source system to develop
graph database applications, e.g., to manage and query your knowledge graphs,
and develop graph machine learning and analytics pipelines,
e.g., in the Python data science ecosystem. </p><p>Kùzu's core architecture is informed by 6 years of research we conducted
at University of Waterloo on an earlier prototype GDBMS called <a href="http://graphflow.io/" target="_blank" rel="noopener noreferrer">GraphflowDB</a>.
Unlike GraphflowDB, which was intended to be a prototype for our research, Kùzu aims to be
a usable feature-rich system. Some of the primary features of Kùzu's  architecture are:</p><ul><li>Flexible Property Graph Data Model and Cypher query language</li><li>Embeddable, serverless integration into applications</li><li>Columnar disk-based storage</li><li>Columnar sparse row-based (CSR) adjacency list/join indices</li><li>Vectorized and factorized query processor</li><li>Novel and very fast join algorithms</li><li>Multi-core query parallelism</li><li>Serializable ACID transactions</li></ul><p>What we are releasing today includes many of the features of the core engine. This is what we
called the "Phase 1" of the project. In the next "Phase 2" of the project, as we continue adding
more features to the core engine, e.g., better support for ad-hoc properties, string compression,
and support for new recursive queries, we will also be focusing developing around the core engine
to more easily ingest data into the system and output data to downstream data science/graph data science
libraries. You can keep an eye on our tentative <a href="https://github.com/kuzudb/kuzu/issues/981" target="_blank" rel="noopener noreferrer">roadmap here</a>.
You can also read more about some of our longer term goals and vision as a system
in <a href="https://cs.uwaterloo.ca/~ssalihog/papers/kuzu-tr.pdf" target="_blank" rel="noopener noreferrer">our new CIDR 2023 paper</a>,
which we will present in Amsterdam next January. </p><p><em>And most importantly please start using Kùzu, tell us your feature requests, use cases, and report bugs. We can evolve into a
more stable, usable, and feature-rich system only through your feedback!</em> </p><p>We are looking forward to to your feedback and a long and exciting journey as we continue developing Kùzu 🤗. </p><sub>*ps: For interested readers: the word kù-zu is the Sumerian (the oldest known human language) word for "wisdom".*</sub>]]></content>
        <author>
            <name>Kùzu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
</feed>