<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kuzudb.com/docusaurus/blog</id>
    <title>KÃ¹zu Blog</title>
    <updated>2023-11-19T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kuzudb.com/docusaurus/blog"/>
    <subtitle>KÃ¹zu Blog</subtitle>
    <icon>https://kuzudb.com/docusaurus/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.1.0 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.1.0-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.1.0-release"/>
        <updated>2023-11-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release KÃ¹zu 0.1.0 today! This is a major release with the following set of new features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release KÃ¹zu 0.1.0 today! This is a major release with the following set of new features and improvements:</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="nodegroup-based-storage">NodeGroup-Based Storage<a href="#nodegroup-based-storage" class="hash-link" aria-label="Direct link to NodeGroup-Based Storage" title="Direct link to NodeGroup-Based Storage">â€‹</a></h2><p>With this release, we have completed the major features of our NodeGroup-base storage design,
which was outlined in this <a href="https://github.com/kuzudb/kuzu/issues/1474" target="_blank" rel="noopener noreferrer">issue</a>. The primary goal of this design was to have a
storage design that is conducive to implementing compression and zone maps optimization.
Conceptually, a NodeGroup is equivalent to a <a href="https://parquet.apache.org/docs/concepts/" target="_blank" rel="noopener noreferrer">Parquet RowGroup</a>, which
represents a horizontal partition of a table consisting of k many nodes (k=64x2048 for now). Each k nodes' data are
managed and compressed as a unit on disk files. In release v0.0.7, we had completed the first part of this design and changed our
node table storage to use NodeGroups. In this release, we have completed the second part of this design and now relationship
tables are also stored as NodeGroups. That means we now compress the relationships of k many nodes together.</p><p>We also stores all column data in a single file <code>data.kz</code> which has significantly reduced the number of database files we now maintain.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-compression">String Compression<a href="#string-compression" class="hash-link" aria-label="Direct link to String Compression" title="Direct link to String Compression">â€‹</a></h3><p>We have extended our compression to compress strings in the database using dictionary compression.
For each string "column chunk" (which is a partition of an entire column in a table
storing one NodeGroup's values), each string s is
stored once in a dictionary, and for each record that has value s, we store a pointer to s.
This design applies when storing string properties on relationship tables.
This is done by using 3 column chunks in total. 2 column chunks store the dictionary as follows. One "raw strings" column chunk
stores all the unique strings in the column chunk one after another, and another "offsets column chunk" identifies
the beginning indices of each string. Then, one additional "index column chunk" stores the pointers to the strings
as indices to the "offsets" column to identify the strings.
The offset and index columns are bitpacked in the manner of integer columns.</p><p><strong>String Compression Benchmark</strong></p><p>Here is a micro-benchmark using the Comment table in LDBC100. To compare the compression rate of each column individually,
we construct a new table Tx for each string column x in the Comment table, e.g., <code>Browser Used</code>. Tx consists of the
column x and a serial primary key, which allows us to avoid storing any materialized hash index. We report the size of the data.kz file
and compare against a previous version v0.0.10 of KÃ¹zu.</p><table><thead><tr><th>Column</th><th>Version 0.0.10</th><th>Version 0.1.0</th><th>Difference</th></tr></thead><tbody><tr><td>Browser Used</td><td>4.2 GB</td><td>272 MB</td><td>-93.5%</td></tr><tr><td>Content</td><td>9.7 GB</td><td>7.5 GB</td><td>-22.7%</td></tr><tr><td>Location IP</td><td>5 GB</td><td>1.6 GB</td><td>-68.0%</td></tr></tbody></table><p>We also report the entire LDBC100 database size, including all database files (data.kz, indices, metadata, catalog), of v0.1.0
and a slightly older version v0.0.8, which included compression of nodes. So this experiment reports
both improvements that come from storing relationship tables in compressed form as well as
storing strings of both node and relationship tables in compressed form.</p><table><thead><tr><th>Database</th><th>Version 0.0.8</th><th>Version 0.1.0</th><th>Difference</th></tr></thead><tbody><tr><td>LDBC100</td><td>127 GB</td><td>94 GB</td><td>-26.0%</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-ingestion-improvements">Data Ingestion Improvements<a href="#data-ingestion-improvements" class="hash-link" aria-label="Direct link to Data Ingestion Improvements" title="Direct link to Data Ingestion Improvements">â€‹</a></h3><p>Moving our relationship table storage to a NodeGroup-based one also improved our
data ingestion times. The following benchmark reports the loading time of the LDBC100 <code>likesComment.csv</code> relationship records.
The file contains 242M records and takes 13 GB in raw CSV format. Below we compare v0.1.0 against v0.0.10 using a machine with
2 Intel Xeon Platinum 8175M CPUs, each of which has 48 physical CPU cores. We used 300 GB of the 380GB total RAM during this test.</p><table><thead><tr><th></th><th>Version 0.0.10</th><th>Version 0.1.0</th><th>Difference</th></tr></thead><tbody><tr><td>8 threads</td><td>266.8 s</td><td>229.8 s</td><td>-13.9%</td></tr><tr><td>4 threads</td><td>312.5 s</td><td>246.8 s</td><td>-21.0%</td></tr><tr><td>2 threads</td><td>446.7 s</td><td>335.6 s</td><td>-24.8%</td></tr><tr><td>1 threads</td><td>700.8 s</td><td>581.9 s</td><td>-17.0%</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-features">New Features<a href="#new-features" class="hash-link" aria-label="Direct link to New Features" title="Direct link to New Features">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="direct-scans-of-dataframes">Direct Scans of DataFrames<a href="#direct-scans-of-dataframes" class="hash-link" aria-label="Direct link to Direct Scans of DataFrames" title="Direct link to Direct Scans of DataFrames">â€‹</a></h3><p>We now support scanning Pandas DataFrames directly. Consider the following <code>person</code> DataFrame
that contains two columns, <code>id</code> and <code>height_in_cm</code> (only the latter will be used in the example):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">id = np.array([0, 2, 3, 5, 7, 11, 13], dtype=np.int64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">height_in_cm = np.array([167, 172, 183, 199, 149, 154, 165], dtype=np.uint32)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">person = pd.DataFrame({'id': id, 'height': height_in_cm})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The query below finds all students who are taller than the average height of the records in the <code>person</code> DataFrame:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">query = 'CALL READ_PANDAS("person")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         WITH avg(height / 2.54) as height_in_inch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         MATCH (s:student)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         WHERE s.height &gt; height_in_inch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         RETURN s'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">results = conn.execute(query)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Details of this feature can be found <a href="/docusaurus/docs/cypher/query-clauses/call.md#read_pandas">here</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="copy">Copy<a href="#copy" class="hash-link" aria-label="Direct link to Copy" title="Direct link to Copy">â€‹</a></h3><p>This release comes with several new features related to Cypher's <code>COPY</code> clause.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="copy-to-parquet-files">Copy To Parquet Files<a href="#copy-to-parquet-files" class="hash-link" aria-label="Direct link to Copy To Parquet Files" title="Direct link to Copy To Parquet Files">â€‹</a></h4><p>Query results can now be exported to Parquet files.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COPY ( MATCH (a:Person) RETURN a.* ) TO "person.parquet";</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="copy-to-csv-files">Copy To CSV Files<a href="#copy-to-csv-files" class="hash-link" aria-label="Direct link to Copy To CSV Files" title="Direct link to Copy To CSV Files">â€‹</a></h4><p>We added serveral configuration options when exporting to CSV files.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COPY ( MATCH (a:Person) RETURN a.* ) TO "person.csv" (delim = '|', header=true);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We also improved the performance of the CSV writer. Below is a micro benchmark of exporting the LDBC100 Comment table to CSV format.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COPY (MATCH (p:Comment) RETURN p.*) to â€˜comment.csvâ€™;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><table><thead><tr><th></th><th>Version 0.0.10</th><th>Version 0.1.0</th></tr></thead><tbody><tr><td>Runtime</td><td>1239.3s</td><td>104.56s</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="optional-column_names-argument-in-copy-from-statements">Optional <code>column_names</code> Argument in Copy From Statements<a href="#optional-column_names-argument-in-copy-from-statements" class="hash-link" aria-label="Direct link to optional-column_names-argument-in-copy-from-statements" title="Direct link to optional-column_names-argument-in-copy-from-statements">â€‹</a></h4><p>Users can now load data to a subset of the columns in a table. Previously, we required that if
users are going to load an empty table T from a file F,
e.g., a CSV or Parquet file, then F must contain: (1) as many columns as the columns in T; and (2) in the same order as
table T. Now users can optionally add a <code>column_names</code> argument in <code>COPY FROM</code> statements,
which relaxes both of these restrictions: (1) F can now contain a subset of the columns; and (2) in arbitrary
order, which needs to be specified in the <code>column_names</code> argument. Here is an example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE NODE TABLE Person (id INT64, name STRING, comment STRING, PRIMARY KEY(id));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">COPY Person (name, id) FROM "person.csv";</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The code above first creates a <code>Person</code> table with 3 columns, and then loads two of its columns from a file
that contains <code>name</code> and <code>id</code> values of the columns respectively.
The third <code>comment</code> column in the table will be set to <code>NULL</code> for all imported records. The details
of this feature can be found <a href="/docusaurus/docs/cypher/copy.md">here</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="updates">Updates<a href="#updates" class="hash-link" aria-label="Direct link to Updates" title="Direct link to Updates">â€‹</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="detach-delete">Detach Delete<a href="#detach-delete" class="hash-link" aria-label="Direct link to Detach Delete" title="Direct link to Detach Delete">â€‹</a></h4><p>KÃ¹zu now supports Cypher's <a href="/docusaurus/docs/cypher/data-manipulation-clauses/delete.md#detach-delete">DETACH DELETE</a> clause,
which deletes a node and all of its relationships together.
Previously users could only use the <code>DELETE</code> command, which deleted nodes that had no relationships.
For example, the following query deletes a <code>User</code> node with <code>name</code> Adam and all of its edges.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (u:User) WHERE u.name = 'Adam' DETACH DELETE u;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="return-deleted-rows">Return Deleted Rows<a href="#return-deleted-rows" class="hash-link" aria-label="Direct link to Return Deleted Rows" title="Direct link to Return Deleted Rows">â€‹</a></h4><p><code>RETURN</code> clauses can now return variable bindings that were used in the <code>DELETE</code> command. For example,
you can return nodes that were deleted in the previous DELETE statement as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DELETE (a:Person) RETURN a;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Details of this feature can be found <a href="/docusaurus/docs/cypher/data-manipulation-clauses/read-after-update.md">here</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="other-changes">Other Changes<a href="#other-changes" class="hash-link" aria-label="Direct link to Other Changes" title="Direct link to Other Changes">â€‹</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="sql-style-cast-function">SQL-style Cast Function<a href="#sql-style-cast-function" class="hash-link" aria-label="Direct link to SQL-style Cast Function" title="Direct link to SQL-style Cast Function">â€‹</a></h4><p>We have implemented a SQL-style <code>cast</code> function <code>cast(input, target_type)</code> to cast values between different
types. The cast function will convert the <code>input</code> argument to the <code>target_type</code> if
casting of the input value to the target type is defined. For example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">RETURN cast("[1,2,3]", "INT[]");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| CAST([1,2,3], INT32[]) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| [1,2,3]                |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Along with this, we are deprecating our previous way of doing casts with separate functions, e.g., <code>STRING(1.2)</code> or <code>to_int64("32")</code>.
Details of the <code>cast</code> function can be found <a href="/docusaurus/docs/cypher/expressions/casting.md">here</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-relationship-node-filter">Recursive Relationship Node Filter<a href="#recursive-relationship-node-filter" class="hash-link" aria-label="Direct link to Recursive Relationship Node Filter" title="Direct link to Recursive Relationship Node Filter">â€‹</a></h4><p>Since v0.0.5 we have supported filtering the intermediate relationships that can bind to
recursive relationships, based on the properties of these intermediate relationships.
With the current release, we now support filtering the intermediate nodes that are bound to recursive relationships.
As we did for filtering intermediate relationships, we adopt Memgraph's syntax for this feature as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2 (r, n | WHERE n.age &gt; 21)]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The first variable <code>r</code> that is inside the recursive relationship above binds to the intermediate relationships while
the second variable <code>n</code> binds to the intermediate nodes. The <code>|</code>symbol can be followed with a <code>WHERE</code> clause
where these variables can be used to express a filtering expression. This query finds all 1 to 2-hop paths between
two <code>User</code> nodes where the intermediate nodes of these paths have <code>age</code> properties greater than 21.
Details of this feature can be found <a href="/docusaurus/docs/cypher/query-clauses/match.md#filter-variable-length-relationships">here</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="count-subquery">Count Subquery<a href="#count-subquery" class="hash-link" aria-label="Direct link to Count Subquery" title="Direct link to Count Subquery">â€‹</a></h4><p>We have added support for counting subqueries, which checks the number of matches for the given pattern in the graph.
The output of this counting can be bound to a variable with aliasing. For example, the following query counts the
number of followers of each user in the graph.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.name, COUNT { MATCH (a)&lt;-[:Follows]-(b:User) } AS num_follower</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY num_follower;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The details of count subqueries can be found <a href="/docusaurus/docs/cypher/subquery.md#count-subquery">here</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="new-int128-data-type">New INT128 Data Type<a href="#new-int128-data-type" class="hash-link" aria-label="Direct link to New INT128 Data Type" title="Direct link to New INT128 Data Type">â€‹</a></h4><p>Finally, we now have support for 16-byte signed huge integers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="development">Development<a href="#development" class="hash-link" aria-label="Direct link to Development" title="Direct link to Development">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nightly-build">Nightly Build<a href="#nightly-build" class="hash-link" aria-label="Direct link to Nightly Build" title="Direct link to Nightly Build">â€‹</a></h3><p>We have setup a nightly build pipeline for KÃ¹zu users who want to access our latest feature set.
Here is how you can use the latest nightly version of KÃ¹zu:</p><ul><li>For the Python API, the latest nightly version can be installed with <code>pip install --pre kuzu</code>.</li><li>For the Node.js API, the latest nightly version can be installed with <code>npm i kuzu@next</code>.</li><li>For the Rust API, the latest nightly version can be found at <a href="https://crates.io/crates/kuzu/versions" target="_blank" rel="noopener noreferrer">crates.io</a>.</li><li>For the CLI, C and C++ shared library, and the Java JAR, the latest nightly version can be downloaded from the latest run of <a href="https://github.com/kuzudb/kuzu/actions/workflows/build-and-deploy.yml" target="_blank" rel="noopener noreferrer">this GitHub Actions pipeline</a>.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="reduced-binary-size">Reduced Binary Size<a href="#reduced-binary-size" class="hash-link" aria-label="Direct link to Reduced Binary Size" title="Direct link to Reduced Binary Size">â€‹</a></h3><p>With this release, we removed our Apache Arrow dependency, which significantly reduces oure binary size.
Additionally, we now strip the shared library and CLI binaries of the symbols that are not needed by our
client APIs. This further reduces our binary sizes.
For example, on a MacOS arm64 platform, these two improvements achieve the following cumulative binary size reductions:</p><table><thead><tr><th></th><th>Version 0.0.10</th><th>Version 0.1.0</th></tr></thead><tbody><tr><td>Binary Size<sup id="fnref-2-c9fccc"><a href="#fn-2-c9fccc" class="footnote-ref">2</a></sup></td><td>27.2 MB</td><td>10.3 MB</td></tr></tbody></table><p>Stripping of our other libraries (e.g. Python) is a work in progress.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="closing-remarks">Closing Remarks<a href="#closing-remarks" class="hash-link" aria-label="Direct link to Closing Remarks" title="Direct link to Closing Remarks">â€‹</a></h2><p>As usual, we would like to thank everyone in the KÃ¹zu engineering team, especially our interns, for making this release possible.
We look forward to your feedback!</p><p>Enjoy KÃ¹zu v 0.1.0 and the upcoming holiday season, which in this part of the world ðŸ‡¨ðŸ‡¦ðŸ‡¨ðŸ‡¦ coincides with
coming of the cold and cozy winter ðŸ¤—ðŸ¤—.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.12 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.12-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.12-release"/>
        <updated>2023-10-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We release KÃ¹zu 0.0.12, another minor release. This release fixes a bug that prevents the database to be opened in read-only mode on a read-only file system. It also adds support for INT128 data type.]]></summary>
        <content type="html"><![CDATA[<p>We release KÃ¹zu 0.0.12, another minor release. This release fixes a bug that prevents the database to be opened in read-only mode on a read-only file system. It also adds support for INT128 data type.</p><p>For more detailed information about the changes in this release, please see <a href="https://github.com/kuzudb/kuzu/releases/tag/v0.0.12" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zuExplorer: Visualizing Query Results and Schemas]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzuexplorer</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzuexplorer"/>
        <updated>2023-10-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Today, we are happy to release KÃ¹zuExplorer, which is KÃ¹zu's browser-based frontend to]]></summary>
        <content type="html"><![CDATA[<p>Today, we are happy to release KÃ¹zuExplorer, which is KÃ¹zu's browser-based frontend to
visualize and explore database schemas and query results in the form of a graph, table, or in JSON.
This is a very useful tool for exploring databases and debugging applications during prototyping
phase. This post describes a brief overview of the main features of KÃ¹zuExplorer with pointers to
<a href="/docusaurus/kuzuexplorer">KÃ¹zuExplorer documentation</a> for details.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="launching-kÃ¹zuexplorer">Launching KÃ¹zuExplorer<a href="#launching-kÃ¹zuexplorer" class="hash-link" aria-label="Direct link to Launching KÃ¹zuExplorer" title="Direct link to Launching KÃ¹zuExplorer">â€‹</a></h2><p>KÃ¹zuExplorer is a web application that is launched from a deployed Docker image. Assuming you have Docker
installed before proceeding, you can launch KÃ¹zuExplorer on an existing DBMS you have or on an empty database.
Details about how to launch KÃ¹zuExplorer can be found <a href="/docusaurus/kuzuexplorer/#launching-k%C3%B9zuexplorer">here</a>.
For example, to start KÃ¹zuExplorer on an empty
database, you can simply run the following command on your shell, and then access KÃ¹zuExplorer by going to
<code>http://localhost:8000</code></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">docker run -p 8000:8000 --rm kuzudb/kuzu-ui:latest</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>KÃ¹zuExplorer comes bundled with several pre-existing databases, one of which you can use to get started.
To load one of these databases, click the <code>Datasets</code> tab on the top right corner on your landing page
and then the <code>Load Dataset</code> button as shown in the below figure.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/preexisting-datasets-8a7a9a3ddb979ea5e3e4bd1611c4ebdf.png" width="600" class="img_ev3q"></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="schema-panel-schema-exploring-and-editing">Schema Panel: Schema Exploring and Editing<a href="#schema-panel-schema-exploring-and-editing" class="hash-link" aria-label="Direct link to Schema Panel: Schema Exploring and Editing" title="Direct link to Schema Panel: Schema Exploring and Editing">â€‹</a></h2><p>One of the two main functionalities of KÃ¹zuExplorer is to explore and modify the schema of your database.
By clicking the <code>Schema</code> tab on the top right corner, you'll get to a page that shows you the
Node and Relationship tables in your database in a node-link view on the left. Using the right panel,
you can do several things to explore and modify your tables, such as by adding new properties to your
node/rel tables, inserting new node/rel tables, or dropping node/rel tables. These changes can all be done
interactively by clicking buttons, which automatically generate and run the corresponding Cypher queries
(unless you have launched KÃ¹zuExplorer <a href="/docusaurus/kuzuexplorer/#access-mode">in read-only mode</a>).</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/schema-panel-28660c6e189bff43d75bf05de40c1f1b.png" width="600" class="img_ev3q"></div><p>More details
about what can be done in the Schema panel can be found <a href="/docusaurus/kuzuexplorer/schema-panel">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="shell-panel-query-result-visualization">Shell Panel: Query Result Visualization<a href="#shell-panel-query-result-visualization" class="hash-link" aria-label="Direct link to Shell Panel: Query Result Visualization" title="Direct link to Shell Panel: Query Result Visualization">â€‹</a></h2><p>Using KÃ¹zuExplorer, you can also issue Cypher queries similar to KÃ¹zu's
<a href="/docusaurus/installation#command-line">command line interface</a>, and
visualize the results of these queries.
To issue queries go to the <code>Shell</code> tab on the right corner and you can type a Cypher query.
As you type your query, KÃ¹zuExplorer shell will suggest keyword completions, which can
help you write your queries. You can then click the green "play" icon on the left hand
side of the shell panel, which will execute your queries and display the results. The
results can be displayed in three different modes: (i) a node-link graph view; (ii) a table; or (iii) as json.
As an example, the below image presents the results of the following query which retrieves all nodes and edges
in the database in a node-link graph view:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a)-[e]-&gt;(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/query-result-node-link-view-708cf57bf3620a739169dbe5c69e6b4c.png" width="600" class="img_ev3q"></div><p>You can inspect individual nodes and edge in the query results by clicking on them. More details
about what can be done in the Shell panel can be found <a href="/docusaurus/kuzuexplorer/shell-panel">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="settings-panel-configuring-visualizations">Settings Panel: Configuring Visualizations<a href="#settings-panel-configuring-visualizations" class="hash-link" aria-label="Direct link to Settings Panel: Configuring Visualizations" title="Direct link to Settings Panel: Configuring Visualizations">â€‹</a></h2><p>There is also a Settings tab on the right hand corner, which can be used for several more advanced
setting changes, e.g., changing the colors or sizes of nodes of a certain type (e.g., <code>User</code> nodes) or
the maximum number of nodes to plot on the node-link graph visualizations when visualizing query results.
Details of these can be found <a href="/docusaurus/kuzuexplorer/settings-panel">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-words">Final Words<a href="#final-words" class="hash-link" aria-label="Direct link to Final Words" title="Direct link to Final Words">â€‹</a></h2><p>KÃ¹zuExplorer should be quite useful especially when developing your applications for exploration and debugging purposes, e.g.,
you can interactively debug why your queries do not return the results you expect using KÃ¹zuExplorer by exploring the
actual nodes and relationships in your database.</p><p>This is our first version of KÃ¹zuExplorer and we will be improving it over time.
We hope you enjoy using KÃ¹zuExplorer and help us make it better! Please send us any feature or documentation requests or
bug reports by opening an issue in <a href="https://github.com/kuzudb/explorer" target="_blank" rel="noopener noreferrer">KÃ¹zuExplorer's github repo</a>!</p>]]></content>
        <author>
            <name>Chang Liu</name>
            <uri>https://www.linkedin.com/in/mewim/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.11 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.11-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.11-release"/>
        <updated>2023-10-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We release KÃ¹zu 0.0.11, another minor release. The main new feature of this release is read-only access mode for the database on Linux. The read-only mode enables the upcoming KÃ¹zu UI to optionally open a database in read-only mode while allowing other applications to access the same database concurrently.]]></summary>
        <content type="html"><![CDATA[<p>We release KÃ¹zu 0.0.11, another minor release. The main new feature of this release is read-only access mode for the database on Linux. The read-only mode enables the upcoming <a href="https://github.com/kuzudb/kuzu-ui" target="_blank" rel="noopener noreferrer">KÃ¹zu UI</a> to optionally open a database in read-only mode while allowing other applications to access the same database concurrently.</p><p>For more detailed information about the changes in this release, please see <a href="https://github.com/kuzudb/kuzu/releases/tag/v0.0.11" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.10 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.10-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.10-release"/>
        <updated>2023-10-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're happy to introduce KÃ¹zu 0.0.10, which is a minor release with a bunch of bug fixes and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We're happy to introduce KÃ¹zu 0.0.10, which is a minor release with a bunch of bug fixes and improvements:</p><ul><li>Added the frame of reference encoding for integers. <a href="https://github.com/kuzudb/kuzu/pull/2140" target="_blank" rel="noopener noreferrer">PR 2140</a></li><li>Fixed slicing of UTF-8 string. <a href="https://github.com/kuzudb/kuzu/pull/2212" target="_blank" rel="noopener noreferrer">PR 2212</a></li><li>Fixed copying of invalid UTF-8. <a href="https://github.com/kuzudb/kuzu/pull/2208" target="_blank" rel="noopener noreferrer">PR 2208</a></li><li>Added more checks and better error messages during the binding phase. <a href="https://github.com/kuzudb/kuzu/pull/2206" target="_blank" rel="noopener noreferrer">PR 2206</a></li><li>Fixed return list literal with null values. <a href="https://github.com/kuzudb/kuzu/pull/2187" target="_blank" rel="noopener noreferrer">PR 2187</a></li><li>Fixed bugs in scan multi label rel tables. <a href="https://github.com/kuzudb/kuzu/pull/2149" target="_blank" rel="noopener noreferrer">PR 2149</a></li><li>Deprecated all functions for getting the table names and properties from the client APIs and the CLI, instead, <code>CALL</code> is introduced for the same functionality. <a href="https://github.com/kuzudb/kuzu/pull/2199" target="_blank" rel="noopener noreferrer">PR 2199</a>, <a href="https://github.com/kuzudb/kuzu/pull/2207" target="_blank" rel="noopener noreferrer">2207</a></li><li>Added missing data type support in client APIs. <a href="https://github.com/kuzudb/kuzu/pull/2183" target="_blank" rel="noopener noreferrer">PR 2183</a>, <a href="https://github.com/kuzudb/kuzu/pull/2176" target="_blank" rel="noopener noreferrer">PR 2176</a>, <a href="https://github.com/kuzudb/kuzu/pull/2193" target="_blank" rel="noopener noreferrer">PR 2193</a>, <a href="https://github.com/kuzudb/kuzu/pull/2172" target="_blank" rel="noopener noreferrer">PR 2172</a></li></ul><p>For more detailed information about the changes in this release, please see <a href="https://github.com/kuzudb/kuzu/releases/tag/v0.0.10" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.9 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.9-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.9-release"/>
        <updated>2023-10-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release KÃ¹zu 0.0.9 today! This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release KÃ¹zu 0.0.9 today! This release comes with the following new main features and improvements:</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-features">New Features<a href="#new-features" class="hash-link" aria-label="Direct link to New Features" title="Direct link to New Features">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="load-from">Load From<a href="#load-from" class="hash-link" aria-label="Direct link to Load From" title="Direct link to Load From">â€‹</a></h3><p>KÃ¹zu now supports loading directly from a file without importing into the database through the <code>LOAD FROM</code> clause. For instance, the following query counts the number of rows whose first column starts with 'Adam'.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LOAD FROM "user.csv"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE column0 =~ 'Adam*'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN COUNT(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>LOAD FROM</code> can also be used as the input source for a bulk update.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LOAD FROM "user.csv"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE (:Person {name: column0, age: to_int64(column1)});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Details can be found in the <a href="/docusaurus/cypher/query-clauses/load_from">LOAD FROM documentation page</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="header-schema">Header Schema<a href="#header-schema" class="hash-link" aria-label="Direct link to Header Schema" title="Direct link to Header Schema">â€‹</a></h4><p>By default, KÃ¹zu will read the header of the file to detect column names and types. If no header is avaliable it will use auto-generated names and all columns will be strings. To manually specify the header, you can use <code>LOAD WITH HEADERS ... FROM ...</code>.</p><p>For example, the following query will load <code>name</code> as a string type for the first column and <code>age</code> as an INT64 type for the second column.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LOAD WITH HEADERS (name STRING, age INT64) FROM "user.csv"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE name =~ 'Adam*'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN name, age;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If a header is manually specified, KÃ¹zu will try to cast to the given type and throw exceptions if casting fails. More information can be found <a href="/docusaurus/cypher/query-clauses/load_from">here</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="transaction-statement">Transaction Statement<a href="#transaction-statement" class="hash-link" aria-label="Direct link to Transaction Statement" title="Direct link to Transaction Statement">â€‹</a></h3><p>This release replaces the <code>beginReadTransaction()</code>, <code>beginWriteTransaction()</code>, <code>commit()</code> and <code>rollback()</code> APIs in all language bindings with explicit statements.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BEGIN TRANSACTION;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE (a:User {name: 'Alice', age: 72});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User) RETURN *;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">COMMIT;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The above sequence of statements starts a write transaction, adds a new node, and within the same transaction also reads all of the tuples in User table before committing the transaction. More info on the new transaction statement can be found <a href="/docusaurus/cypher/transaction">here</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="comment-on-table">Comment on Table<a href="#comment-on-table" class="hash-link" aria-label="Direct link to Comment on Table" title="Direct link to Comment on Table">â€‹</a></h3><p>You can now add comments to a table using the <code>COMMENT ON TABLE</code> statement. The following query adds a comment to the <code>User</code> table.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COMMENT ON TABLE User IS 'User information';</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Comments can be extracted through the new <code>SHOW_TABLES()</code> function.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL SHOW_TABLES() RETURN *;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| name | type | comment          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| User | NODE | User information |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| City | NODE |                  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-relationship-projection">Recursive Relationship Projection<a href="#recursive-relationship-projection" class="hash-link" aria-label="Direct link to Recursive Relationship Projection" title="Direct link to Recursive Relationship Projection">â€‹</a></h3><p>This release expands recursive relationship patterns and enables projection on intermediate nodes and relationships. Previously, KÃ¹zu only supported returning all node and relationship properties on the path.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[e:Follows*1..2 (r, n | WHERE r.since &gt; 2020)]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN nodes(e), rels(e);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This incurs a significant computational overhead when a user is only interested in a subset of properties on the path. Also, returning all properties makes the result harder to interpret.</p><p>KÃ¹zu now allows projection inside recursive relationship patterns using a list-comprehension-like syntax.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[e:Follows*1..2 (r, n | WHERE r.since &gt; 2020 | {r.since}, {n.name})]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN nodes(e), rels(e);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The query above finds all paths between two users which are between 1 and 2 hops, and where the users followed each other after 2020. The query returns the <code>since</code> property of any <code>Follow</code> relationships and the name of any intermediate users.</p><p>For more information, check out <a href="/docusaurus/cypher/query-clauses/match#project-intermediate-nodes-and-rels">the new documentation</a>.</p><p>The performance improvements are shown in the <a href="#performance-improvements">Performance Improvements</a> section.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="create-rel-group">CREATE REL GROUP<sup id="fnref-1-8c98df"><a href="#fn-1-8c98df" class="footnote-ref">1</a></sup><a href="#create-rel-group" class="hash-link" aria-label="Direct link to create-rel-group" title="Direct link to create-rel-group">â€‹</a></h3><p>We have received a lot of feedback regarding the limitation that a relationship can only be defined over a single pair of node tables. This release introduces a <code>CREATE REL GROUP</code> statement which has a similar syntax to <code>CREATE REL TABLE</code>, but allows multiple <code>FROM ... TO ...</code> clauses. This statement will create a relationship table for each pair internally. When querying, a relationship group is simply syntatic sugar for any of the relationships in the group.</p><p>For example, the following statement creates a group containing a Knows_User_User relationship and a Knows_User_City relationship.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE REL TABLE GROUP Knows (FROM User To User, FROM User to City, year INT64);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To query with the group, simply treat it as any other relationship, so:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[:Knows]-&gt;(b) RETURN *;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The query above is equivalent to</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[:Knows_User_User|:Knows_User_city]-&gt;(b) RETURN *;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Note</strong></p><ul><li>For <code>COPY FROM</code> and <code>CREATE</code>, we currently don't support using a relationship group so you need to explicitly specify a single relationship table.</li></ul><p>See <a href="/docusaurus/cypher/data-definition/create-table">Create Table</a> for more information.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-types--functions">Data Types &amp; Functions<a href="#data-types--functions" class="hash-link" aria-label="Direct link to Data Types &amp; Functions" title="Direct link to Data Types &amp; Functions">â€‹</a></h3><p>We introduced a few more numerical data types:</p><ul><li>INT8: 1 byte signed integer</li><li>UINT64: 8 byte unsigned integer</li><li>UINT32: 4 byte unsigned integer</li><li>UINT16: 2 byte unsigned integer</li><li>UINT8: 1 byte unsigned integer</li></ul><p>We have also added several casting and list functions. See <a href="/docusaurus/cypher/expressions/">functions</a> for more information.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="performance-improvements">Performance Improvements<a href="#performance-improvements" class="hash-link" aria-label="Direct link to Performance Improvements" title="Direct link to Performance Improvements">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="new-csv-and-parquet-reader">New CSV and Parquet Reader<a href="#new-csv-and-parquet-reader" class="hash-link" aria-label="Direct link to New CSV and Parquet Reader" title="Direct link to New CSV and Parquet Reader">â€‹</a></h3><p>In this release, we have started replacing arrow's CSV and Parquet reader with our own lightweight and customized implementations.</p><p>Following DuckDB's implementation, we've replaced arrow's streaming CSV reader with a parallel one. The parallel CSV reader assumes there are no multi-line strings and provides a large performance boost on multi-threaded machines.</p><p>If multi-line strings are present, the CSV reading will fail, and you will need to fall back to single thread mode by setting <code>parallel=false</code>. See <a href="/docusaurus/data-import/csv-import">Data Import from CSV Files</a>.</p><p>We demonstrate the performance of our parallel csv reader through the new <a href="#load-from">LOAD FROM</a> feature as follows.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LOAD FROM "ldbc-100/comment_0_0.csv" (header = true, delim = '|') RETURN COUNT(*);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><table><thead><tr><th># Threads</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>Time (s)</td><td>297.19</td><td>170.71 (1.7x)</td><td>109.38 (2.7x)</td><td>69.01 (4.3x)</td><td>53.28 (5.6x)</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bitpacking-compression">Bitpacking Compression<a href="#bitpacking-compression" class="hash-link" aria-label="Direct link to Bitpacking Compression" title="Direct link to Bitpacking Compression">â€‹</a></h3><p>With this release, we have implemented our first compression algorithm! We are introducing the bitpacking compression algorithm for integers. It is useful when using a large integer type (e.g., INT32 or INT64) for storing small integers, which can be encoded more compactly with fewer bits. This helps both storage and query processing times.</p><p>To show the difference, we take the <code>length</code> column from LDBC <code>Comment</code> table as an example, which is of type <code>INT32</code> and whose values range from 2 to 1998.
Together with an auto-increment <code>ID</code> column as the primary key, we create a node table <code>(ID INT64, length INT32, PRIMARY KEY(ID))</code>. The loaded data file size, and loading time is listed in the below table. Data file size is largely reduced from 2.6GB to 1.1GB (2.4x), while the data loading time stays the same (75.69s vs. 75.84s).</p><p>Reduced data file size also helps reduce disk I/O operations, which can improve query scan performance. We show that with a query that sums all the lengths.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (l:length) RETURN sum(l.length);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The query time improved from 1.64s to 0.45s (3.6x)!</p><table><thead><tr><th></th><th>Data size</th><th>Loading time</th><th>Query time</th></tr></thead><tbody><tr><td>Without compression</td><td>2.6GB</td><td>75.69s</td><td>1.64s</td></tr><tr><td>With compression</td><td><strong>1.1GB (2.4x)</strong></td><td><strong>75.84s</strong></td><td><strong>0.45s (3.6x)</strong></td></tr></tbody></table><p>More compressions on integers, floats, and string values will be coming soon. Please stay tuned!</p><p>Note: The compression is currently only done on node tables. It will be adapted to rel tables in our next release. By default, we turn on compression for all node tables. To disable it, we provide an option when starting the database. For example, starting our CLI with <code>--nocompress</code> option can disable compression on all write statements to node tables.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="general-data-loading-improvement">General Data Loading Improvement<a href="#general-data-loading-improvement" class="hash-link" aria-label="Direct link to General Data Loading Improvement" title="Direct link to General Data Loading Improvement">â€‹</a></h3><p>Data loading time is improved due the following changes:</p><ul><li>Parallel csv reader.</li><li>Compression means we write less data to disk.</li><li>Removed line counting when copying rel tables.</li><li>Dedicated casting functions to avoid string copy.</li><li>Reduced hash index file size.</li></ul><table><thead><tr><th>Files</th><th># Lines</th><th>CSV file size</th><th>v0.0.8</th><th>v0.0.9</th></tr></thead><tbody><tr><td>comment.csv</td><td>220M</td><td>22.49 GB</td><td>187.76s</td><td><strong>131.48s</strong></td></tr><tr><td>person.csv</td><td>0.45M</td><td>43.6M</td><td>1.16s</td><td><strong>0.78s</strong></td></tr><tr><td>likesComment.csv</td><td>242M</td><td>13 GB</td><td>250.64s</td><td><strong>210.72s</strong></td></tr><tr><td>knows.csv</td><td>20M</td><td>1.1 GB</td><td>24.40s</td><td><strong>19.54s</strong></td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="projection-pushdown-for-recursive-joins">Projection Pushdown for Recursive Joins<a href="#projection-pushdown-for-recursive-joins" class="hash-link" aria-label="Direct link to Projection Pushdown for Recursive Joins" title="Direct link to Projection Pushdown for Recursive Joins">â€‹</a></h3><p>The following two queries both compute paths along the Knows relationship with 1 to 3 hops from a single starting point, and then returns the firstName of all nodes along the path.<sup id="fnref-2-8c98df"><a href="#fn-2-8c98df" class="footnote-ref">2</a></sup></p><p>Without Projection:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[e:Knows*1..3]-&gt;(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.ID = 933</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN properties(nodes(e), 'firstName');</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With Projection:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[e:Knows*1..3 (r, n | {}, {n.firstName})]-&gt;(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.ID = 933</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN properties(nodes(e), 'firstName');</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><table><thead><tr><th>With projection</th><th>Without projection</th></tr></thead><tbody><tr><td><strong>471.9</strong> ms</td><td>3412.8 ms</td></tr></tbody></table><p>With projection, the optimizer can completely avoid materializing a hash table for relationship properties which is a major bottleneck in computation.</p><div class="footnotes"><hr><ol><li id="fn-1-8c98df">This is an experimental feature and might be changed in the future.<a href="#fnref-1-8c98df" class="footnote-backref">â†©</a></li><li id="fn-2-8c98df">This experiment was carried out on an M1 Macbook Pro with 16GB of memory and 8 threads. Sideway information passing is disabled.<a href="#fnref-2-8c98df" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.8 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.8-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.8-release"/>
        <updated>2023-08-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're here to introduce KÃ¹zu 0.0.8, which is a minor bug-fix release together with some performance optimizations:]]></summary>
        <content type="html"><![CDATA[<p>We're here to introduce KÃ¹zu 0.0.8, which is a minor bug-fix release together with some performance optimizations:</p><ul><li>Fixed a major bug in COPY on large datasets. <a href="https://github.com/kuzudb/kuzu/pull/1963" target="_blank" rel="noopener noreferrer">PR 1963</a></li><li>Implemented the <a href="https://github.com/kuzudb/kuzu/pull/1949" target="_blank" rel="noopener noreferrer">TopK optimization</a>, significantly enhancing the performance of queries that involve ORDER BY and LIMIT clauses. We will delve deeper into this optimization in a blog post. <a href="https://github.com/kuzudb/kuzu/pull/1949" target="_blank" rel="noopener noreferrer">PR 1949</a></li><li>WITH clause (CTE) rewriter. We avoid the evaluation of node and rel in CTE projection if it's not needed for further processing. <a href="https://github.com/kuzudb/kuzu/pull/1956" target="_blank" rel="noopener noreferrer">PR 1956</a></li><li>Updated our Rust doc with converting query result to arrow arrays.</li><li>Fixed the size allocated for boolean values to match the size of the bit-packed data. <a href="https://github.com/kuzudb/kuzu/pull/1953/files" target="_blank" rel="noopener noreferrer">PR 1953</a></li></ul><p>For more detailed information about the changes in this release, please see <a href="https://github.com/kuzudb/kuzu/releases/tag/v0.0.8" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.7 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.7-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.7-release"/>
        <updated>2023-08-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release KÃ¹zu 0.0.7 today! This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release KÃ¹zu 0.0.7 today! This release comes with the following new main features and improvements: </p><ul><li><a href="/docusaurus/blog/kuzu-0.0.7-release#macro-and-udf">Macro and UDF</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.7-release#create-macro-statements">Create Macro Statements</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#c-udfs">C++ UDFs</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#data-update-and-return-clauses">Data Update and Return Clauses</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.7-release#merge-clause">Merge Clause</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#multi-label-setdelete">Multi-label Set/Delete</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#return-after-update">Return After Update</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#return-with-">Return with .<!-- -->*</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#data-export">Data Export</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#new-data-types-and-apis">New Data Types and APIs</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.7-release#map">MAP</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#union">UNION</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#converting-query-results-to-arrow">Converting Query Results to Arrow</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#nodegroup-based-node-table-storage">NodeGroup Based Node Table Storage</a></li><li><a href="/docusaurus/blog/kuzu-0.0.7-release#unnesting-arbitrary-subqueries">Unnesting Arbitrary Subqueries</a></li></ul><p>For installing the new version,
please visit the <a href="https://kuzudb.com/#download" target="_blank" rel="noopener noreferrer">download section of our website</a>
and <a href="https://kuzudb.com/docusaurus/getting-started/" target="_blank" rel="noopener noreferrer">getting started guide</a>. The full
<a href="https://github.com/kuzudb/kuzu/releases" target="_blank" rel="noopener noreferrer">release notes are here</a>. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="macro-and-udf">Macro and UDF<a href="#macro-and-udf" class="hash-link" aria-label="Direct link to Macro and UDF" title="Direct link to Macro and UDF">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="create-macro-statements">Create Macro Statements<a href="#create-macro-statements" class="hash-link" aria-label="Direct link to Create Macro Statements" title="Direct link to Create Macro Statements">â€‹</a></h3><p>In this release, we've added the support of <code>CREATE MACRO</code> statement to define customized scalar functions, i.e., those that return only a single value, through Cypher.</p><p>Here is an example of defining a macro to add two input parameters.  The second parameter <code>b:3</code> is an example of how to provide a default value for a parameter in case the parameter is absent.</p><div class="language-Cypher codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Cypher codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Create a macro which adds two parameters. If the second parameter b is not provided, the default value of 3 will be used instead.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">create macro addWithDefault(a,b:=3) as a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Executes the macro without providing the default value.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return addWithDefault(2);  // returns 5 (2 + 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Executes the macro by providing the default value (actual parameter value will be used).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return addWithDefault(4, 7);  // returns 11 (4 + 7)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See more details on supported macro expression types <a href="/docusaurus/cypher/macro">here</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="c-udfs">C++ UDFs<a href="#c-udfs" class="hash-link" aria-label="Direct link to C++ UDFs" title="Direct link to C++ UDFs">â€‹</a></h3><p>We are also introducing two C++ interfaces, <code>createScalarFunction</code> and <code>createVectorizedFunction</code> in the <code>Connection</code> class of the <a href="https://kuzudb.com/docusaurus/getting-started/cpp" target="_blank" rel="noopener noreferrer">C++ API</a> to define both scalar and vectorized <a href="/docusaurus/client-apis/cpp-api/udf">UDFs</a>.</p><p><code>createScalarFunction</code> provides a way for users to define scalar functions in C++ and use it in KÃ¹zu as if they're built-in functions.
Here is an example of a unary scalar function that increments the input value by 5:</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">static</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int32_t</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">addFiveScalar</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int32_t</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> x </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">5</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// Register the unary scalar function using the createScalarFunction API.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token function" style="color:#d73a49">createScalarFunction</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"addFiveScalar"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">addFiveScalar</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// Issue a query using the UDF.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token function" style="color:#d73a49">query</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"MATCH (p:person) return addFiveScalar(to_int32(p.age))"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For users familiar with internals of our intermediate result representation, they can make use of <code>createVectorizedFunction</code> to create vectorized function over our ValueVectors to achieve better performance.
See <a href="/docusaurus/client-apis/cpp-api/udf">our doc here</a> for more details.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-update-and-return-clauses">Data Update and Return Clauses<a href="#data-update-and-return-clauses" class="hash-link" aria-label="Direct link to Data Update and Return Clauses" title="Direct link to Data Update and Return Clauses">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="merge-clause">Merge Clause<a href="#merge-clause" class="hash-link" aria-label="Direct link to Merge Clause" title="Direct link to Merge Clause">â€‹</a></h3><p>This release implements the <code>MERGE</code> clause, which is an updating clause that will first try to match the given pattern and, if not found, create the pattern. At a high level, <code>MERGE &lt;pattern&gt;</code> can be interpreted as <code>If MATCH &lt;pattern&gt; then RETURN &lt;pattern&gt; ELSE CREATE &lt;pattern&gt;</code>.Additionally, one can further specify the <code>SET</code> operation based on whether the pattern is found or not through <code>ON CREATE</code> and <code>ON MATCH</code>.</p><p>For example, the following query tries to merge a user node with name "Adam". Suppose a node with name "Adam" exists in the database already. In this case, we update the same node's <code>age</code> property and return the node (so no new node gets inserted).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MERGE (n:User {name : 'Adam'}) ON MATCH SET n.age = 35 RETURN n.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| n.name | n.age |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Adam   | 35    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here is another example where we try to merge a <code>Follows</code> edge with <code>since</code> property equal to 2022 between <code>Adam</code> and <code>Karissa</code>. Suppose no such edge exists in the database, then the statement create the edge and set the <code>since</code> property to 1999.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User), (b:User) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' AND b.name = 'Karissa' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MERGE (a)-[e:Follows {since:2022}]-&gt;(b) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ON CREATE SET e.since = 1999</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| e                                                     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 1999}-&gt;(0:1) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="/docusaurus/cypher/data-manipulation-clauses/merge">our doc here</a> for more details.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="multi-label-setdelete">Multi-label Set/Delete<a href="#multi-label-setdelete" class="hash-link" aria-label="Direct link to Multi-label Set/Delete" title="Direct link to Multi-label Set/Delete">â€‹</a></h3><p>KÃ¹zu now allows set/delete on nodes and relationship variables that can be binding to multiple labels. For example,
to delete all nodes in database (assuming all edges have been deleted).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n) DELETE n;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similarly, to set <code>since</code> property of all relationships in the database.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH ()-[f]-&gt;() SET f.since = 2023</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that when evaluating this query, tuples in tables that don't have <code>since</code> property will be ignored.</p><p>See our docs in <a href="/docusaurus/cypher/data-manipulation-clauses/set">Set</a> and <a href="/docusaurus/cypher/data-manipulation-clauses/delete">Delete</a> for more details.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="return-after-update">Return After Update<a href="#return-after-update" class="hash-link" aria-label="Direct link to Return After Update" title="Direct link to Return After Update">â€‹</a></h3><p>We are also enabling return after updating clause starting from this release. That is updated value will be returned in queries that update values. Here are some examples:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (u:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE u.name = 'Adam' SET u.age = NULL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN u.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| u.name | u.age |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Adam   |       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (u1:User), (u2:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE u1.name = 'Adam' AND u2.name = 'Noura' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE (u1)-[e:Follows {since: 2011}]-&gt;(u2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| e                                                     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 2011}-&gt;(0:3) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See our docs in <a href="/docusaurus/cypher/data-manipulation-clauses/set">Set</a> and <a href="/docusaurus/cypher/data-manipulation-clauses/delete">Delete</a> for more examples.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="return-with-">Return with .*<a href="#return-with-" class="hash-link" aria-label="Direct link to Return with .*" title="Direct link to Return with .*">â€‹</a></h3><p>As a syntactic sugar, KÃ¹zu now supports returning all properties of node or rel with *.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User) RETURN a.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| a.name  | a.age |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Adam    | 30    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Karissa | 40    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Zhang   | 50    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Noura   | 25    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="/docusaurus/cypher/query-clauses/return#returning-node-and-relationship-properties">our doc here</a> for more details.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-export">Data Export<a href="#data-export" class="hash-link" aria-label="Direct link to Data Export" title="Direct link to Data Export">â€‹</a></h2><p>KÃ¹zu now supports exporting query results to CSV files using the <code>COPY TO</code> command. For example the following
<code>COPY TO</code> statement could return the below CSV file.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COPY (MATCH (u:User) RETURN u.*) TO 'user.csv';</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>CSV file:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">u.name,u.age</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">"Adam",30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">"Karissa",40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">"Zhang",50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">"Noura",25</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="/docusaurus/data-export/">Data Export</a> for more information.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-data-types-and-apis">New Data Types and APIs<a href="#new-data-types-and-apis" class="hash-link" aria-label="Direct link to New Data Types and APIs" title="Direct link to New Data Types and APIs">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="map">MAP<a href="#map" class="hash-link" aria-label="Direct link to MAP" title="Direct link to MAP">â€‹</a></h3><p>A <code>MAP</code> is a dictionary of key-value pairs where all keys have the same type and all values have the same type. Different from <code>STRUCT</code>, <code>MAP</code> doesn't require the same key to be present in each row. Therefore, <code>MAP</code> is more suitable when the schema is not determined.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">RETURN map([1, 2], ['a', 'b']) AS m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| m          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| {1=a, 2=b} |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="/docusaurus/cypher/data-types/map">map</a> for more information.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="union">UNION<a href="#union" class="hash-link" aria-label="Direct link to UNION" title="Direct link to UNION">â€‹</a></h3><p>KÃ¹zu's <code>UNION</code> is implemented by taking DuckDB's <code>UNION</code> type as a reference. Similar to C++ <code>std::variant</code>, <code>UNION</code> is a nested data type that is capable of holding multiple alternative values with different types. The value under key "tag" is considered as the value being currently hold by the <code>UNION</code>.</p><p>See <a href="/docusaurus/cypher/data-types/union">union</a> for more information.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="converting-query-results-to-arrow">Converting Query Results to Arrow<a href="#converting-query-results-to-arrow" class="hash-link" aria-label="Direct link to Converting Query Results to Arrow" title="Direct link to Converting Query Results to Arrow">â€‹</a></h3><p>In previous releases, we supported converting query result to Arrow tables in our <a href="https://kuzudb.com/api-docs/python/kuzu/query_result.html#QueryResult.get_as_arrow" target="_blank" rel="noopener noreferrer">Python API</a>.
In this release, converting to Arrow arrays are now also available in Rust, <a href="https://kuzudb.com/api-docs/c/kuzu_8h.html" target="_blank" rel="noopener noreferrer">C</a> (see <code>kuzu_query_result_get_arrow_schema</code> and <code>kuzu_query_result_get_next_arrow_chunk</code>), and <a href="https://kuzudb.com/api-docs/cpp/classkuzu_1_1main_1_1_query_result.html" target="_blank" rel="noopener noreferrer">C++</a> (see <code>getArrowSchema</code> and <code>getNextArrowChunk</code>) APIs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="nodegroup-based-node-table-storage">NodeGroup Based Node Table Storage<a href="#nodegroup-based-node-table-storage" class="hash-link" aria-label="Direct link to NodeGroup Based Node Table Storage" title="Direct link to NodeGroup Based Node Table Storage">â€‹</a></h2><p>This release introduces changes the storage layout of node tables.
Before this release, we used to store each column in a node table contiguously in separate files.
Each column contains one data file (e.g., <code>n-1.col</code>) and one null file (e.g., <code>n-1.null</code>) if the column may contain null values.
This design posed two problems: 1) it requires maintaining many files in the database directory, which may lead to <code>too many open files</code> error; 2) it is not suitable for data compression. Although we still don't implement compression yet (this will wait until the next few releases), this design would force us to adopt a single compression technique for the entire column. </p><p>Instead, partitioning each column into multiple chunks can offer more flexibility as each column chunk can be compressed and decompressed independently.
In this release, we introduced the concept <a href="https://github.com/kuzudb/kuzu/issues/1474" target="_blank" rel="noopener noreferrer">NodeGroup</a>, which is equivalent to <a href="https://parquet.apache.org/docs/concepts/" target="_blank" rel="noopener noreferrer">RowGroup</a> and represents a horizontal partition of a table.<sup id="fnref-1-9f2652"><a href="#fn-1-9f2652" class="footnote-ref">1</a></sup>
With node group-based storage design, we also store data of all columns in a single file <code>data.kz</code>.<sup id="fnref-2-9f2652"><a href="#fn-2-9f2652" class="footnote-ref">2</a></sup>
This will enable more powerful compression schemes, e.g., constant compression, bit-packing, dictionary compression in the coming releases.
For details on our new design, please visit <a href="https://github.com/kuzudb/kuzu/issues/1474" target="_blank" rel="noopener noreferrer">this issue</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="unnesting-arbitrary-subqueries">Unnesting Arbitrary Subqueries<a href="#unnesting-arbitrary-subqueries" class="hash-link" aria-label="Direct link to Unnesting Arbitrary Subqueries" title="Direct link to Unnesting Arbitrary Subqueries">â€‹</a></h2><p>Consider the following query that finds the name of users <code>a</code> who have at least 1 user <code>b</code> who is younger than <code>a</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE EXISTS { MATCH (a)-[:Follows]-&gt;(b:User) WHERE a.age &gt; b.age} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.name;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The query inside <code>EXISTS</code> is a correlated subquery and very expensive to evaluate because the inner subquery needs to be evaluated for each <code>a</code> with a nested loop join operator (which is often an inefficient way to evaluate joins). In this release, we implemented an optimization that unnests correlated subqueries based on the techniques adopted from this paper <a href="https://cs.emis.de/LNI/Proceedings/Proceedings241/383.pdf" target="_blank" rel="noopener noreferrer">Unnesting Arbitrary Queries</a> by Neumann and Kemper. This allows us to use hash joins instead of nested loop joins and execute these queries much faster. More details will come in a separate blog post on both this technique and how much gains we obtain.</p><div class="footnotes"><hr><ol><li id="fn-1-9f2652">We use the term NodeGroup mainly due to that we also partition rel tables based on their src/dst nodes, instead of number of rows.<a href="#fnref-1-9f2652" class="footnote-backref">â†©</a></li><li id="fn-2-9f2652">Primary key index files are still kept separately, but eventually they will also be merged into the <code>data.kz</code> file.<a href="#fnref-2-9f2652" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[IAMGraphViz: Visualizing AWS IAM Permissions with KÃ¹zu]]></title>
        <id>https://kuzudb.com/docusaurus/blog/iamgraphviz</id>
        <link href="https://kuzudb.com/docusaurus/blog/iamgraphviz"/>
        <updated>2023-07-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[IAMGraphViz Overview]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="iamgraphviz-overview">IAMGraphViz Overview<a href="#iamgraphviz-overview" class="hash-link" aria-label="Direct link to IAMGraphViz Overview" title="Direct link to IAMGraphViz Overview">â€‹</a></h2><p><a href="https://www.commonfate.io/" target="_blank" rel="noopener noreferrer">Common Fate</a>  is a framework for managing complex cloud permissions. They provide tools to simplify access at scale to AWS, Azure, and Google Cloud accounts. You can learn about what you can do with Common Fate on <a href="https://www.commonfate.io/" target="_blank" rel="noopener noreferrer">their website</a>. Here, we will talk about a recent proof of concept graph visualization tool called IAMGraphViz that <a href="https://www.linkedin.com/in/mewim/" target="_blank" rel="noopener noreferrer">Chang Liu</a> (who is coauthoring this post) and I developed using KÃ¹zu! IAMGraphViz is intended for infrastructure engineers to dig deep into the permission assignments in AWS IAM Identity Center using graph visualization. Using IAMGraphViz, one can easily visualize who has what type of access to different accounts on AWS as well as how they have access to these accounts. This is all done by analyzing the paths from users to accounts in a graph visualization, where the nodes and edges model users, accounts, groups, group memberships, permission sets and other entities in the AWS IAM Identity Center system.</p><p>The IAMGraphViz project is designed and implemented as a web application using a graph DBMS (GDBMS) to store and retrieve data. Before landing on KÃ¹zu, we surveyed using several other GDBMSs, such as Neo4j, but they were all harder to use. Neo4j, for example, requires hosting a separate database. We then discovered KÃ¹zu, which only required a <code>pip install</code> and import statement and we could simply embed it into our application. In this project our datasets could fit entirely onto a single compute node,and so KÃ¹zu was far simpler for us to work with than alternatives. KÃ¹zu is also far cheaper and more serverless-friendly than running a separate database.</p><p>This post follows the <a href="https://colab.research.google.com/drive/1fotlNnOj1FGad6skBG7MRrHVdHd3jIl6" target="_blank" rel="noopener noreferrer">Colab</a> that Chang Liu created after we discussed this use case together.</p><p>So let's get to it!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="quick-aws-iam-overview">Quick AWS IAM Overview<a href="#quick-aws-iam-overview" class="hash-link" aria-label="Direct link to Quick AWS IAM Overview" title="Direct link to Quick AWS IAM Overview">â€‹</a></h2><p>We will use the data model shown in the figure below that faithfully (but partially) models the
core concepts of AWS IAM permission management. Let's first review these concepts, all
of which will be modeled as nodes in KÃ¹zu, as a background.
We will provide as simple definitions as we can to keep the post short and provide links
to necessary AWS IAM documentation: </p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/schema-a1a8655501405ee6c34e17165daac04b.png" width="600" class="img_ev3q"></div><ol><li><p><strong><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html" target="_blank" rel="noopener noreferrer">User</a></strong> represents a
user, e.g., an actual human user, who can get access to AWS accounts (and through accounts to AWS resources).</p></li><li><p><strong><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_groups.html" target="_blank" rel="noopener noreferrer">Group</a></strong> is a collection of IAM users and lets you specify permissions for multiple users at a time (e.g., you could have a user group called Admins with typical administrator permissions).
To follow the APIs we use, instead of linking Users to Groups through a direct edge, we will do this (a bit redundantly) through a GroupMembership node.</p></li><li><p><strong><a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account" target="_blank" rel="noopener noreferrer">Account</a></strong>: An AWS account is the basic container for your AWS resources, such as s3 buckets,
Amazon Relational Database Service (Amazon RDS) databases, or Amazon Elastic Compute Cloud instances.
Using multiple AWS accounts is a common practice for many reasons, e.g., providing a natural billing boundary for costs or isolating resources for security. Common Fate customers have hundreds of
accounts, which is not an extreme.</p></li><li><p><strong><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html" target="_blank" rel="noopener noreferrer">IAM Policy</a></strong>, and <strong><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html#aws-managed-policies" target="_blank" rel="noopener noreferrer">ManagedPolicy</a></strong>: An IAM policy contains permissions for using some AWS resources. An AWS managed policy is a policy with a unique Amazon Resource Name (ARN), e.g., <code>arn:aws:iam::aws:policy/IAMReadOnlyAccess</code>, that is administered by AWS. Managed policies are common policies used by many enterprises. Managed policies are simpler to use than writing your custom policies.
For simplicity, we will only model AWS managed policies in this post.</p></li><li><p><strong><a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/permissionsetsconcept.html" target="_blank" rel="noopener noreferrer">PermissionSet</a></strong> is a set of policies that can be attached to users or groups (through AccountAssignments which we explain momentarily). For example, you can create a Database Admin permission set that includes policies for administering Amazon RDS, DynamoDB, and Aurora services, and use that single permission set to grant access to a list of target AWS accounts. Similar to GroupMembership nodes, to follow the APIs we use, instead of linking ManagedPolicy nodes to PermissionSet nodes through a direct edge, we will link them through a ManagedPolicyAttachment node.</p></li><li><p><strong><a href="https://aws.amazon.com/about-aws/whats-new/2020/09/aws-single-sign-on-adds-account-assignment-apis-and-aws-cloudformation-support-to-automate-multi-account-access-management/" target="_blank" rel="noopener noreferrer">Account Assignment</a></strong>: We will connect user and/or groups to AWS accounts with a specific permission set through an <code>AccountAssignment</code> node (see the schema above). </p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="example-visualizations">Example Visualizations<a href="#example-visualizations" class="hash-link" aria-label="Direct link to Example Visualizations" title="Direct link to Example Visualizations">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-generation">Data Generation<a href="#data-generation" class="hash-link" aria-label="Direct link to Data Generation" title="Direct link to Data Generation">â€‹</a></h3><p>In the attached <a href="https://colab.research.google.com/drive/1fotlNnOj1FGad6skBG7MRrHVdHd3jIl6" target="_blank" rel="noopener noreferrer">Colab notebook</a>, we first generate some test data
containing Users, Groups, ManagedPolicies, PermissionSets etc. For simplicity, we assume that there are three fixed groups: "Admins", "Developers", and "Auditors" and three ManagedPolicies: "AdministratorAccess", "PowerUserAccess", and "ReadOnlyAccess". Users, Accounts,
AccountAssignments, and PermissionSets are randomly generated and we randomly link different nodes to
other nodes according to our schema.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="visualization-1-draw-all-users-with-direct-or-indirect-readonlyaccess-access-to-an-account">Visualization 1: Draw all users with direct or indirect <code>ReadOnlyAccess</code> access to an account<a href="#visualization-1-draw-all-users-with-direct-or-indirect-readonlyaccess-access-to-an-account" class="hash-link" aria-label="Direct link to visualization-1-draw-all-users-with-direct-or-indirect-readonlyaccess-access-to-an-account" title="Direct link to visualization-1-draw-all-users-with-direct-or-indirect-readonlyaccess-access-to-an-account">â€‹</a></h3><p>In our first query, we are given a particular account we would like to investigate and find
all users who have <code>ReadOnlyAccess</code> to the resources of this account. Let's assume
the account's name is "account-db2071".</p><div class="language-cypher codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cypher codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (u:User)&lt;-[l*1..3]-(aa:AccountAssignment)-[l5]-(a:Account),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(aa:AccountAssignment)-[aaps]-&gt;(ps:PermissionSet)&lt;-[psmpa]-(mpa:ManagedPolicyAttachment)-[mpap]-&gt;(p:ManagedPolicy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE p.id = "arn:aws:iam::aws:policy/ReadOnlyAccess" AND a.sid = "account-db2071"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the actual IAMGraphViz implementation, we template this query with two parameters, one for the
account ID, and one for the managed policy, which users pick interactively by selecting from
a dropdown menu.
Note also that the <code>[:*1..3]</code> binding is a variable-length path because we want to find
both the direct connections from a <code>User</code> to an <code>AccountAssignment</code> (that is further connected to
<code>ManagedPolicy</code>) as well as
indirect connections through a <code>Group</code> node. The visualization we generate is shown below:</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/readonlyviz-01a07dc37ec55c977e7a98acb5396133.png" class="img_ev3q"></div><p>Note the presence of both directly and indirectly connected users to the account.
The visualization in both the actual implementation and the <a href="https://colab.research.google.com/drive/1fotlNnOj1FGad6skBG7MRrHVdHd3jIl6" target="_blank" rel="noopener noreferrer">Colab notebook</a> is generated simply
by converting the results of the query into the node and link objects of the graph visualization library,
e.g., pyvis in the case of the Colab notebook.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="visualization-2-draw-all-accounts-a-user-has-administratoraccess-to">Visualization 2: Draw all accounts a user has <code>AdministratorAccess</code> to<a href="#visualization-2-draw-all-accounts-a-user-has-administratoraccess-to" class="hash-link" aria-label="Direct link to visualization-2-draw-all-accounts-a-user-has-administratoraccess-to" title="Direct link to visualization-2-draw-all-accounts-a-user-has-administratoraccess-to">â€‹</a></h3><p>In our second query, we are given a particular user we would like to investigate and find all accounts that the user has <code>AdministratorAccess</code> to. Let's assume the user's name is "Steven Rose". </p><p>To retrive the accounts, we define a Cypher query very similar to the previous one. The only difference is that, instead of using the account as query predicate, we now use the user. The query is as follows:</p><div class="language-cypher codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cypher codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (u:User)&lt;-[l*1..3]-(aa:AccountAssignment)-[l5]-(a:Account),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(aa:AccountAssignment)-[aaps]-&gt;(ps:PermissionSet)&lt;-[psmpa]-(mpa:ManagedPolicyAttachment)-[mpap]-&gt;(p:ManagedPolicy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE p.id = "arn:aws:iam::aws:policy/AdministratorAccess" AND u.name = "Steven Rose"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The visualization we generate is shown below:</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/adminviz-81efff2ce0d12c4a702fc8628963f727.png" class="img_ev3q"></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="closing-words">Closing Words<a href="#closing-words" class="hash-link" aria-label="Direct link to Closing Words" title="Direct link to Closing Words">â€‹</a></h2><p>Many other graph visualizations can be helpful for infrastructure engineers to analyze the
IAM network of an enterprise. For example, to find inconsistent privileges given to users,
we might want to <em>find and plot multiple paths from a user to an account with different privileges</em>.
Or we might want to extend our model with more fine grained resources that are connected to accounts
and analyze paths from users to these resources (see the <a href="https://github.com/nccgroup/PMapper" target="_blank" rel="noopener noreferrer">PMapper</a> project that models the IAM data in a more detailed way). The key takeaway is this: graph visualizations can be very powerful to analyze cloud permission data and embedding KÃ¹zu into your applications
to develop tools like IAMGraphViz is extremely easy and fun ðŸ¥³ðŸ™ŒðŸ’ª!</p>]]></content>
        <author>
            <name>Chris Norman</name>
            <uri>https://www.linkedin.com/in/chrnorm/?originalSubdomain=uk</uri>
        </author>
        <author>
            <name>Chang Liu</name>
            <uri>https://www.linkedin.com/in/mewim/</uri>
        </author>
        <category label="use-case" term="use-case"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.6 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.6-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.6-release"/>
        <updated>2023-07-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are thrilled to announce the release of KÃ¹zu 0.0.6, which focuses on addressing bugs reported by our users. We addressed the following issues in this bug-fix release:]]></summary>
        <content type="html"><![CDATA[<p>We are thrilled to announce the release of KÃ¹zu 0.0.6, which focuses on addressing bugs reported by our users. We addressed the following issues in this bug-fix release:</p><ol><li>Resolved a segmentation fault occurring while loading overflow data types with parallelism.</li><li>Fixed an issue of reading out of bound for LIST vector null buffer.</li><li>Implemented several missing data types in C, JAVA, Rust, and Python API bindings.</li></ol><p>For more detailed information about the changes in this release, please visit <a href="https://github.com/kuzudb/kuzu/releases/tag/v0.0.6" target="_blank" rel="noopener noreferrer">this link</a>. </p><p>We extend our sincere gratitude to all our users who reported these bugs, as well as to everyone who supported us throughout this process. Your feedback is instrumental in making KÃ¹zu better!</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.5 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.5-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.5-release"/>
        <updated>2023-07-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release KÃ¹zu 0.0.5 today! This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release KÃ¹zu 0.0.5 today! This release comes with the following new main features and improvements: </p><ul><li><a href="/docusaurus/blog/kuzu-0.0.5-release#cypher-features">Cypher Features</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.5-release#named-path">Named Path</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#filters-of-relationships-in-recursive-patterns">Filters of Relationships in Recursive Patterns</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#all-shortest-paths">All Shortest Paths</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#call-clause"><code>Call</code> Clause</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#modifying-database-configurations">Modifying Database Configuration</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#data-types">Data Types</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.5-release#blob"><code>BLOB</code></a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#client-apis-rust-and-java">Client APIs: Rust and Java</a></li><li><a href="/docusaurus/blog/kuzu-0.0.5-release#development-testing-framework">Development:Testing Framework</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cypher-features">Cypher Features<a href="#cypher-features" class="hash-link" aria-label="Direct link to Cypher Features" title="Direct link to Cypher Features">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="named-paths">Named Paths<a href="#named-paths" class="hash-link" aria-label="Direct link to Named Paths" title="Direct link to Named Paths">â€‹</a></h3><p>This releases introduces named paths. Users can now assign a named variable to a connected graph pattern. For example, the following query returns all path between <code>Adam</code> and <code>Karissa</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows]-&gt;(b:User) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' AND b.name = 'Karissa' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Named paths can also be assigned to recursive graph patterns as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2]-&gt;(:User)-[:LivesIn]-&gt;(:City) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>One can also assign multiple named paths in a <code>MATCH</code> clause</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p1 = (a:User)-[:Follows]-&gt;(b:User), p2 = (b)-[:LivesIn]-&gt;(:City) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p1, p2;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Internally, a path is processed as a <code>STRUCT</code> with two fields, a nodes field with key <code>_NODES</code> and type <code>LIST[NODE]</code> and a rels field with key <code>_RELS</code> and type <code>LIST[REL]</code>. See <a href="https://kuzudb.com/docusaurus/cypher/data-types/path" target="_blank" rel="noopener noreferrer"><code>PATH</code></a> for details. Users can access nodes and rels field with <code>nodes(p)</code> and <code>rels(p)</code> function calls as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2]-&gt;(:User) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN nodes(p), (rels(p)[1]).since;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="filters-of-relationships-in-recursive-patterns">Filters of Relationships in Recursive Patterns<a href="#filters-of-relationships-in-recursive-patterns" class="hash-link" aria-label="Direct link to Filters of Relationships in Recursive Patterns" title="Direct link to Filters of Relationships in Recursive Patterns">â€‹</a></h3><p>Users can now put predicates on the relationships that will be "traversed/joined" in recursive patterns.
For example, the following query finds the name of users that are followed by Adam directly or indirectly through 2 hops where <em>the following started before 2022 (r.since &lt; 2022 predicate)</em>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a:User)-[:Follows*1..2 (r, _ | WHERE r.since &lt; 2022)]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Adam' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN DISTINCT b.name;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Our filter grammar follows <a href="https://memgraph.com/docs/memgraph/reference-guide/built-in-graph-algorithms" target="_blank" rel="noopener noreferrer">Memgraph's syntax</a>. The first variable <code>r</code> in the <code>(r, _ | WHERE r.since &lt; 2022)</code> predicate binds to the relationships in the recursive pattern and the <code>_</code> binds to the nodes. Since we currently don't allow filters on recursive nodes, the second variable must be <code>_</code> for now.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="all-shortest-paths">All Shortest Paths<a href="#all-shortest-paths" class="hash-link" aria-label="Direct link to All Shortest Paths" title="Direct link to All Shortest Paths">â€‹</a></h3><p>KÃ¹zu now supports all shortest paths semantic with key word <code>ALL SHORTEST</code>. The following query finds all shortest paths of up to length 3 between <code>Zhang</code> and <code>Waterloo</code> considering relationships of all labels (i.e., this is an unlabeled query and you can restrict the labels by adding them as <code>[:Follows* ALL SHORTEST 1..3]</code>).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH p = (a)-[* ALL SHORTEST 1..3]-(b) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Zhang' AND b.name = 'Waterloo' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="https://kuzudb.com/docusaurus/cypher/query-clauses/match#all-shortest-path" target="_blank" rel="noopener noreferrer">All Shortest Paths</a> on our documentation for more information.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="call-clause"><code>Call</code> Clause<a href="#call-clause" class="hash-link" aria-label="Direct link to call-clause" title="Direct link to call-clause">â€‹</a></h3><p>This release introduces <code>Call</code> as a reading clause. Similar to <a href="https://neo4j.com/docs/cypher-manual/current/clauses/call/" target="_blank" rel="noopener noreferrer">Neo4j</a>, <code>Call</code> clause is used to execute procedures. The release also contains a set of predefined procedures that can be used to query the database schemas. For example, the following query returns all metadata of <code>User</code> table:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL table_info('User') RETURN *;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| property id | name | type   | primary key |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| 0           | name | STRING | True        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| 1           | age  | INT64  | False       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>Call</code> can be used together with other clauses in the same way as a reading clause:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL table_info('User') WITH * WHERE name STARTS WITH 'a' RETURN name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| name |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| age  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>More built in procedures can be found <a href="https://kuzudb.com/docusaurus/cypher/query-clauses/call" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="modifying-database-configurations">Modifying Database Configurations<a href="#modifying-database-configurations" class="hash-link" aria-label="Direct link to Modifying Database Configurations" title="Direct link to Modifying Database Configurations">â€‹</a></h2><p><code>CALL</code> has another usage: you can now modify database configurations through a <code>Call param=x</code> pattern. For example, the following sets the maximum number of threads for query execution to 5:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CALL THREADS=5;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>More configuration options can be found <a href="https://kuzudb.com/docusaurus/cypher/configuration" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-types">Data Types<a href="#data-types" class="hash-link" aria-label="Direct link to Data Types" title="Direct link to Data Types">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="blob"><code>BLOB</code><a href="#blob" class="hash-link" aria-label="Direct link to blob" title="Direct link to blob">â€‹</a></h3><p>We have also added the <code>BLOB</code> type to store arbitrary binary objects. Here is an example query returning a blob:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">RETURN BLOB('\\xBC\\xBD\\xBA\\xAA') as result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| result                                    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| \xBC\xBD\xBA\xAA                          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>More information on the blob data type can be found <a href="https://kuzudb.com/docusaurus/cypher/data-types/blob" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="client-apis-rust-and-java">Client APIs: Rust and Java<a href="#client-apis-rust-and-java" class="hash-link" aria-label="Direct link to Client APIs: Rust and Java" title="Direct link to Client APIs: Rust and Java">â€‹</a></h2><p>In this release, we're expanding the accessibility of KÃ¹zu, bridging the gap with some of the most popular programming languages in the developer community. Specifically, we now have <a href="https://kuzudb.com/docusaurus/client-apis/rust" target="_blank" rel="noopener noreferrer">Rust</a> and <a href="https://kuzudb.com/docusaurus/client-apis/java" target="_blank" rel="noopener noreferrer">Java</a> APIs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="development-testing-framework">Development: Testing Framework<a href="#development-testing-framework" class="hash-link" aria-label="Direct link to Development: Testing Framework" title="Direct link to Development: Testing Framework">â€‹</a></h2><p>Starting with this release, we're adding some development guidelines to encourage and facilitate outside contributions from the broader open source community.</p><p>Testing is a crucial part of KÃ¹zu to ensure the correct functioning of the system.
In this release, we've implemented significant changes to our testing framework. Our approach to testing is rooted in the principle of end-to-end tests rather than individual unit tests.
Whenever possible, we route all tests in the end-to-end way through Cypher statements.
To this end, we've designed a custom testing framework that enables thorough end-to-end testing via Cypher statements.</p><p>Our testing framework draws inspiration from <a href="https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki" target="_blank" rel="noopener noreferrer">SQLLogicTest</a>, albeit with customized syntax tailored to our needs.
For a more detailed overview of our testing framework, please visit <a href="https://kuzudb.com/docusaurus/development/testing-framework" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.4 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.4-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.4-release"/>
        <updated>2023-06-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are very happy to release KÃ¹zu 0.0.4 today! This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are very happy to release KÃ¹zu 0.0.4 today! This release comes with the following new main features and improvements: </p><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#data-ingestion-improvements">Data Ingestion Improvements</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#new-cypher-features">New Cypher Features</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#undirected-relationships-in-queries">Undirected Relationships in Queries</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#recursive-queries-shortest-path-queries-and-improved-variable-length-queries">Recursive Queries: Shortest Path Queries and Improved Variable-length Queries</a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#new-data-types">New Data Types</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#serial"><code>SERIAL</code></a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#struct"><code>STRUCT</code></a></li></ul></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#client-apis">Client APIs</a><ul><li><a href="/docusaurus/blog/kuzu-0.0.4-release#windows-compatibility">Windows compatibility</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#c">C</a></li><li><a href="/docusaurus/blog/kuzu-0.0.4-release#nodejs">Node.js</a></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-ingestion-improvements">Data Ingestion Improvements<a href="#data-ingestion-improvements" class="hash-link" aria-label="Direct link to Data Ingestion Improvements" title="Direct link to Data Ingestion Improvements">â€‹</a></h2><p>We continue to improve our data ingestion in this release.
We still rely on Apache Arrow to parse parquet and csv files.
Several bottlenecks in our earlier implementation are identified and optimized now, including copying from arrow arrays and construction of hash indexes.
We now also store null bits separately, which simplifies our loading logic and makes it faster.</p><p>Here are some benchmark numbers for loading two node and two rel tables that only contain primitive types or strings from the LDBC benchmark:</p><ul><li>CPU: MAC M1 MAX</li><li>Disk: 2TB SSD</li><li>System Memory: 32GB</li><li>Dataset: LDBC-100</li><li>Number of thread: 10</li></ul><table><thead><tr><th>Files</th><th># lines</th><th>file size</th><th>v0.0.3</th><th>v0.0.4</th></tr></thead><tbody><tr><td>comment.csv</td><td>220M</td><td>22.49 GB</td><td>890s</td><td><strong>108s (8.2x)</strong></td></tr><tr><td>post.csv</td><td>58M</td><td>7.68 GB</td><td>304s</td><td><strong>32s (9.5x)</strong></td></tr><tr><td>likesComment.csv</td><td>242M</td><td>13 GB</td><td>772s</td><td><strong>142s (5.4x)</strong></td></tr><tr><td>knows.csv</td><td>20M</td><td>1.1 GB</td><td>80s</td><td><strong>21s (3.8x)</strong></td></tr></tbody></table><p>Besides performance improvement, we now also allow interrupting <code>COPY</code> statements in the shell.
You can interrupt long running <code>COPY</code> statements without crashing the shell.</p><p>We will continue to improve our data ingestion to make it more efficient and robust as we're moving to the <a href="https://github.com/kuzudb/kuzu/issues/1474" target="_blank" rel="noopener noreferrer">new storage design</a> in the coming releases. Please stay tuned!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-cypher-features">New Cypher Features<a href="#new-cypher-features" class="hash-link" aria-label="Direct link to New Cypher Features" title="Direct link to New Cypher Features">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="undirected-relationships-in-queries">Undirected Relationships in Queries<a href="#undirected-relationships-in-queries" class="hash-link" aria-label="Direct link to Undirected Relationships in Queries" title="Direct link to Undirected Relationships in Queries">â€‹</a></h3><p>KÃ¹zu now supports undirected relationships in Cypher queries. An undirected relationship is the union of both in-coming and out-going relationships. This feature is mostly useful in the following two cases. </p><p><strong>Case 1: Relationship is undirected by nature</strong>
Relationships between nodes in KÃ¹zu are currently directed (though we are internally debating to add a native undirected relationship type). A relationship file must contain <code>FROM</code> and <code>TO</code> columns each of which refers to a primary key column of a node table. However, sometimes the nature of the relationships are undirected, e.g., an <code>isFriendOf</code> relationships in a social network. </p><p>Currently, you have two options: (1) you can either store each friendship twice, e.g., <code>Alice isFriendOf Bob</code> and <code>Bob isFriendOf Alice</code>. This is a bad choice because internally KÃ¹zu will index each edge twice (in the forward and backward) edges, so this one fact ends up getting stored 4 times. Or (2) you can store it once, say <code>Alice isFriendOf Bob</code>. </p><p>The advantage of option (1) was that in KÃ¹zu v 0.0.3, if you want to find all friends of <code>Alice</code>, you could simply ask this query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[:isFriendOf]-&gt;(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice' RETURN b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Instead, if you chose option (2), you would have to ask two queries, one to <code>MATCH (a:Person)-[:isFriendOf]-&gt;(b:Person)</code> and the other to <code>MATCH (a:Person)&lt;-[:isFriendOf]-(b:Person)</code>, and <code>UNION</code> them, which gets messy if you want to do more with those neighbors (e.g., find their neighbors etc.). </p><p>With undirected edge support, you can now choose option (2) and find <code>Alice</code>'s friends with:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[:isFriendOf]-(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>So if you do not specify a direction in your relationships, KÃ¹zu will automatically query both the forward and backward relationships for you.</p><p><em>Note from KÃ¹zu developers: As noted above, we are debating a native undirected relationship type. That seems to solve the problem of, in which fake direction should an undirected relationship be saved at? Should be a <code>Alice-[isFriendOf]-&gt;Bob</code> or vice versa. Happy to hear your thoughts on this.</em></p><p><strong>Case 2: Relationship direction is not of interest</strong>
Although relationship is stored in a directed way, its direction may not be of interest in the query. The following query tries to find all comments that have interacted with comment <code>KÃ¹zu</code>. These comments could be either replying to or replied by <code>KÃ¹zu</code>. The query can be asked naturally in an undirected way.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (c:Comment)-[:replyOf]-(other:Comment)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE c.author = 'KÃ¹zu'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN other;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-queries-shortest-path-queries-and-improved-variable-length-queries">Recursive Queries: Shortest Path Queries and Improved Variable-length Queries<a href="#recursive-queries-shortest-path-queries-and-improved-variable-length-queries" class="hash-link" aria-label="Direct link to Recursive Queries: Shortest Path Queries and Improved Variable-length Queries" title="Direct link to Recursive Queries: Shortest Path Queries and Improved Variable-length Queries">â€‹</a></h3><p>This release brings in the beginnings of a series of major improvements we will do to recursive joins.
The two major changes in this release are: </p><p><strong>Multilabeled and undirected Variable-length Join Queries</strong>
Prior to this release we supported variable-length join queries only in the restricted case when the variable-length relationship could have a single relationship label and was directed. For example you could write this query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[:knows*1..2]-&gt;(b:Person)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>But you couldn't ask for arbitrary labeled variable-length relationships between Persons <code>a</code> and <code>b</code> (though you
could write the non-recursive version of that query: <code>MATCH (a:Person)-[:knows]-&gt;(b:Person) ...</code>.
Similarly we did not support undirected version of the query: <code>MATCH (a:Person)-[:knows*1..2]-(b:Person)</code>.
KÃ¹zu now supports multi-label as well as undirected variable-length relationships.
For example, the following query finds all nodes that are reachable within 1 to 3 hops from <code>Alice</code>, irrespective
of the labels on the connections or destination <code>b</code> nodes:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person)-[e:*1..3]-(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Shortest path</strong></p><p>Finally, we got to implementing an initial version of shortest path queries. You can find (one of the) shortest paths between nodes by adding the <code>SHORTEST</code> keyword to a varible-length relationship. The following query asks for a shortest path between <code>Alice</code> and all active users that <code>Alice</code> follows within 10 hops and return these users, and the length of the shortest path.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[p:Follows* SHORTEST 1..10]-&gt;(b:User)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice' AND b.state = 'Active'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b, p, length(p)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>p</code> in the query binds to the sequences of relationship, node, relationship, node, etc. Currently we only return the internal IDs of the relationships and nodes (soon, we will return all their properties).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-data-types">New Data Types<a href="#new-data-types" class="hash-link" aria-label="Direct link to New Data Types" title="Direct link to New Data Types">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="serial"><code>SERIAL</code><a href="#serial" class="hash-link" aria-label="Direct link to serial" title="Direct link to serial">â€‹</a></h3><p>This release introduces <code>SERIAL</code> data type. Similar to <code>AUTO_INCREMENT</code> supported by many other databases, <code>SERIAL</code> is mainly used to create
an incremental sequence of unique identifier column which can serve as a primary key column.</p><p>Example:</p><p><code>person.csv</code></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Alice</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bob</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Carol</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE NODE TABLE Person(ID SERIAL, name STRING, PRIMARY KEY(ID));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">COPY Person FROM `person.csv`;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Person) RETURN a;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Output:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| a                                       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (label:Person, 3:0, {ID:0, name:Alice}) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (label:Person, 3:1, {ID:1, name:Bob})   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| (label:Person, 3:2, {ID:2, name:Carol}) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When the primary key of your node tables are already consecutive integers starting from 0, you should omit the primary key column in the input file and make primary key a SERIAL type. This will improve loading time significantly. Similarly, queries that need to scan primary key will also get faster. That's because internally we will not store a HashIndex or primary key column so any scan over primary key will not trigger a disk I/O.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="struct"><code>STRUCT</code><a href="#struct" class="hash-link" aria-label="Direct link to struct" title="Direct link to struct">â€‹</a></h3><p>KÃ¹zu now supports <code>STRUCT</code> data type similar to <a href="https://www.postgresql.org/docs/current/rowtypes.html" target="_blank" rel="noopener noreferrer">composite type</a> in Postgres. Here is an example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">WITH {name:'University of Waterloo', province:'ON'} AS institution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN institution.name AS name;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Output:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| name                   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| University of Waterloo |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We support storing structs as node properties for now. For example you can create: <code>CREATE NODE TABLE Foo(name STRING, exStruct STRUCT(x INT16, y STRUCT(z INT64, w STRING)), PRIMARY KEY (name))</code>. We will support storing structs on relationships soon. As shown in the <code>CREATE NODE</code> example above, you can store arbitrarily
nested structs, e.g., structs that contain structs as a field, on nodes. One missing feature we have for now is storing and processing a <code>LIST&lt;STRUCT&gt;</code> composite type. </p><p><strong>Note</strong>: Updating <code>STRUCT</code> column with update statement is not supported in this release but will come soon.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="client-apis">Client APIs<a href="#client-apis" class="hash-link" aria-label="Direct link to Client APIs" title="Direct link to Client APIs">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="windows-compatibility">Windows compatibility<a href="#windows-compatibility" class="hash-link" aria-label="Direct link to Windows compatibility" title="Direct link to Windows compatibility">â€‹</a></h3><p>Developers can now build KÃ¹zu from scratch on Windows platform! Together with this release we also provide pre-built libraries and python wheels on Windows.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="c">C<a href="#c" class="hash-link" aria-label="Direct link to C" title="Direct link to C">â€‹</a></h3><p>We provide official C language binding in this release. Developers can now embed KÃ¹zu with native C interfaces.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nodejs">Node.js<a href="#nodejs" class="hash-link" aria-label="Direct link to Node.js" title="Direct link to Node.js">â€‹</a></h3><p>We provide official Node.js language binding. With Node.js API, developer can leverage KÃ¹zu analytical capability in their Node.js projects. We will
soon follow this blog post with one (or a few) blog posts on developing some applications with Node.js.</p>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scaling Pytorch Geometric GNNs With KÃ¹zu]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-pyg-remote-backend</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-pyg-remote-backend"/>
        <updated>2023-05-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, we'll walk through how to use KÃ¹zu as a Pytorch Geometric (PyG) Remote Backend to train a GNN model on very large graphs that do not fit on your machine's RAM.]]></summary>
        <content type="html"><![CDATA[<p>In this post, we'll walk through how to use KÃ¹zu as a <a href="https://pytorch-geometric.readthedocs.io/en/latest/advanced/remote.html" target="_blank" rel="noopener noreferrer">Pytorch Geometric (PyG) <em>Remote Backend</em></a> to train a GNN model on very large graphs that do not fit on your machine's RAM. </p><p>Let's start with a quick overview of PyG Remote Backends: PyG Remote Backends are plug-in replacements for PyG's in-memory graph and feature stores, so they can be used seamlessly with the rest of the PyG interfaces to develop your GNN models. If a PyG Remote Backend is a disk-based storage system, such as KÃ¹zu, PyG will fetch subgraphs from KÃ¹zu, which stores and scans its data from disk, allowing you to train models on very large graphs for which PyG's in-memory storage would run out of memory and fail.</p><p>As you'll see, if you already have PyG models you have developed in Python, replacing PyG's default storage with KÃ¹zu is extremely simple. <strong><em>It
consists of loading your graph into KÃ¹zu and then changing 1 line of code in your PyG model</em></strong>. To demonstrate how simple this is and how it performs,
se will follow this <a href="https://github.com/pyg-team/pytorch_geometric/tree/master/examples/kuzu/papers_100M" target="_blank" rel="noopener noreferrer">Sample Code</a> to demonstrate how to do this.
So let's get to it!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="dataset-predictive-task-and-gnn-model">Dataset, Predictive Task, and GNN Model<a href="#dataset-predictive-task-and-gnn-model" class="hash-link" aria-label="Direct link to Dataset, Predictive Task, and GNN Model" title="Direct link to Dataset, Predictive Task, and GNN Model">â€‹</a></h2><p>Let's start by describing our graph dataset, our predictive task, and the GNN model we will use for the predictive task.</p><p><strong>Dataset</strong>: We will use the <code>ogbn-papers100M</code> dataset of ~100M nodes and ~2.5B edges from the <a href="https://ogb.stanford.edu/" target="_blank" rel="noopener noreferrer">Open Graph Benchmark</a> (OGB). To find the dataset,
you can search for "ogbn-papers100M" <a href="https://ogb.stanford.edu/docs/nodeprop/" target="_blank" rel="noopener noreferrer">here</a>. The dataset takes about 128GB of RAM when using PyG's default in-memory storage. The graph's nodes and edges model the following:</p><p><em>Nodes</em> are papers that have these properties:</p><ul><li><code>ID</code>: an int64 node identifier</li><li><code>year</code>: the publication date of the paper (you can ignore this as it will not be used in our example but this property is part of the dataset)</li><li><code>x</code>: 128-dimensional node features (so 128-size float tensors)</li><li><code>y</code>: a numeric label indicating the category/field of the paper. These numbers indicate different <a href="https://arxiv.org/category_taxonomy" target="_blank" rel="noopener noreferrer">arXiv categories</a> for
papers. Although the exact mapping is not important, you can think of these for example as 0 indicating "physics", 2 indicating "geometry" etc.</li></ul><p><em>Edges/Relationships</em> are citations between papers and do not contain any properties.</p><p><strong>Predictive task:</strong> Predict the <code>y</code> labels of nodes using the node features stored in the <code>x</code> properties.</p><p><strong>GNN Model</strong>: We will train a 3-layer GraphSage model that contains 5.6 million parameters to perform this predictive task. Our model is based on the implementation <a href="https://github.com/mengyangniu/ogbn-papers100m-sage/tree/main" target="_blank" rel="noopener noreferrer">here</a>. We picked this model because it was one of the better-performing models in the <a href="https://ogb.stanford.edu/docs/leader_nodeprop/" target="_blank" rel="noopener noreferrer">PyG Leaderboard for the ogbn-papers100M dataset</a> (search "GraphSAGE_res_incep" under "Leaderboard for ogbn-papers100M") that we could develop using pre-existing layers in the PyG library (so we do not have to write any custom layers).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step-1-preliminaries-and-loading-ogbn-papers100m-into-kÃ¹zu">Step 1: Preliminaries and Loading ogbn-papers100M into KÃ¹zu<a href="#step-1-preliminaries-and-loading-ogbn-papers100m-into-kÃ¹zu" class="hash-link" aria-label="Direct link to Step 1: Preliminaries and Loading ogbn-papers100M into KÃ¹zu" title="Direct link to Step 1: Preliminaries and Loading ogbn-papers100M into KÃ¹zu">â€‹</a></h2><p>As a preliminary, the <a href="https://github.com/pyg-team/pytorch_geometric/blob/master/examples/kuzu/papers_100M/prepare_data.py" target="_blank" rel="noopener noreferrer"><code>prepare_data.py</code></a> script in <a href="https://github.com/pyg-team/pytorch_geometric/tree/master/examples/kuzu/papers_100M" target="_blank" rel="noopener noreferrer">Sample Code</a> generates four numpy files for each property of the papers: (i) <code>./ids.npy</code>; (ii) <code>./node_feat.npy</code> (storing <code>x</code> properties); (iii) <code>./node_year.npy</code>; and (iv) <code>./node_label.npy</code> (storing <code>y</code> labels). In addition, it will generate an <code>./edge_index.csv</code> file that stores the citation relationships. In the below code snippets, we will assume you have gone through those steps.</p><p>Let's start with how you load the <code>ogbn-papers100M</code> dataset into KÃ¹zu. You will first need to define a <code>paper</code> NODE TABLE and a <code>cite</code> REL TABLE, whose schemas will follow exactly the structure of the dataset and then use <code>COPY FROM</code> statements in KÃ¹zu's version of Cypher to ingest those numpy and csv files into your <code>paper</code> and <code>cite</code> tables:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import kuzu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Creating an empty KÃ¹zu database under the papers100M directory...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db = kuzu.Database('papers100M')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn = kuzu.Connection(db, num_threads=cpu_count())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Creating KÃ¹zu tables...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "CREATE NODE TABLE paper(id INT64, x FLOAT[128], year INT64, y FLOAT, "</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "PRIMARY KEY (id));")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute("CREATE REL TABLE cites (FROM paper TO paper, MANY_MANY);")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Copying nodes to KÃ¹zu tables...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute('COPY paper FROM ("%s",  "%s",  "%s", "%s") BY COLUMN;' %</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ('./ids.npy', './node_feat.npy', './node_year.npy', './node_label.npy'))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("Copying edges to KÃ¹zu tables...")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">conn.execute('COPY cites FROM "%s";' % ('./edge_index.csv'))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print("All done!")</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The one important note here is that you should store your node features using <a href="https://kuzudb.com/docs/cypher/data-types/list.html" target="_blank" rel="noopener noreferrer">KÃ¹zu's FIXED-LIST data type</a> using <code>FLOAT[128]</code> syntax (instead of the less efficient VAR-LIST data type, which uses <code>FLOAT[]</code> syntax for lists that can have different lengths). FIXED-LIST is a data type that we specifically added to KÃ¹zu to efficiently store node features and embeddings in graph ML applications.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step-2-get-kÃ¹zu-remote-backend-by-calling-dbget_torch_geometric_remote_backend">Step 2: Get KÃ¹zu Remote Backend by Calling <code>db.get_torch_geometric_remote_backend()</code><a href="#step-2-get-kÃ¹zu-remote-backend-by-calling-dbget_torch_geometric_remote_backend" class="hash-link" aria-label="Direct link to step-2-get-kÃ¹zu-remote-backend-by-calling-dbget_torch_geometric_remote_backend" title="Direct link to step-2-get-kÃ¹zu-remote-backend-by-calling-dbget_torch_geometric_remote_backend">â€‹</a></h2><p>After loading your data to KÃ¹zu, the only thing you have to do is to call the <code>get_torch_geometric_remote_backend()</code> function on your Database object <code>db</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">feature_store, graph_store = db.get_torch_geometric_remote_backend(multiprocessing.cpu_count())</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This function returns two objects that implement PyG's Remote Backend interfaces: (i) <code>feature_store</code> is an instance of <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.FeatureStore.html#torch_geometric.data.FeatureStore" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data.FeatureStore</code></a>; and (ii) <code>graph_store</code> is an instance of <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.GraphStore.html#torch_geometric.data.GraphStore" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data.GraphStore</code></a>. These two handles are your KÃ¹zu Remote Backends that you can pass to your PyG models/subgraph samplers and they will make your existing PyG models work seamllessly with KÃ¹zu! That's all
you really have to know about how to use KÃ¹zu as a Remote Backend. <strong><em>There is no more KÃ¹zu functions you have to call in the rest of the demonstration. You only have
to do 1 line of code change in your regular PyG code.</em></strong>
The rest of the example contains standard code you normally write to develop your PyG models.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step-3-define--pass-kÃ¹zus-feature_store-and-graph_store-to-your-gnn-model">Step 3: Define &amp; Pass KÃ¹zu's <code>feature_store</code> and <code>graph_store</code> to your GNN Model<a href="#step-3-define--pass-kÃ¹zus-feature_store-and-graph_store-to-your-gnn-model" class="hash-link" aria-label="Direct link to step-3-define--pass-kÃ¹zus-feature_store-and-graph_store-to-your-gnn-model" title="Direct link to step-3-define--pass-kÃ¹zus-feature_store-and-graph_store-to-your-gnn-model">â€‹</a></h2><p>First, we'll define the GraphSage model in PyG. We'll put <code>...</code>'s here and there to shorten the example because, as we said above, this is your regular PyG code:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Define the model for training. The model is ported from</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># https://github.com/mengyangniu/ogbn-papers100m-sage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class SAGE(nn.Module):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, in_feats, n_hidden, n_classes, n_layers, activation,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 dropout):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super().__init__()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.n_layers = n_layers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def forward(self, edge_list, x):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for layer_index, layer in enumerate(self.layers):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return self.mlp(collect)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Next, we will enable PyG to use KÃ¹zu's Remote Backend when training. We create a <a href="https://pytorch-geometric.readthedocs.io/en/latest/_modules/torch_geometric/loader/neighbor_loader.html" target="_blank" rel="noopener noreferrer"><code>torch_geometric.loader.NeighborLoader</code></a>, which is the subgraph sampler we will use, and pass the <code>feature_store</code> and <code>graph_store</code> we obtained from KÃ¹zu to it. <strong><em>This is the 1 line change you have to do!</em></strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Plug the graph store and feature store into the NeighborLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu_sampler = NeighborLoader(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data=(feature_store, graph_store),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num_neighbors={('paper', 'cites', 'paper'): [12, 12, 12]},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    batch_size=LOADER_BATCH_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_nodes=('paper', input_nodes),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num_workers=4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filter_per_worker=False,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong><code>data=(feature_store, graph_store)</code></strong> is the important line. When you use this sampler in training to construct mini-batches, it will perform subgraph sampling and load the required node features from KÃ¹zu automatically and return a <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.HeteroData.html" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data.HeteroData</code></a> object, which can be directly plugged into a GNN model. That training code looks like this (again abbreviated because this is all PyG code):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">model = SAGE(128, 1024, 172, 3, torch.nn.functional.relu, 0.2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">criterion = torch.nn.CrossEntropyLoss()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for epoch in range(NUM_EPOCHS):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    start_time = time.time()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // **The below for loop line is where we ask the sampler to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sample a mini batch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for b in kuzu_sampler:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x = b['paper']['x']</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y = b['paper']['y']</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        edge_index = b['paper', 'cites', 'paper'].edge_index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        model.train()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        optimizer.zero_grad()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out = model(edge_index, x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loss = criterion(out, y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loss.backward()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        optimizer.step()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>for b in kuzu_sampler:</code> is the exact line where the sampler will end up calling on KÃ¹zu to sample a subgraph and scan the features of the nodes in that subgraph. This all ends up using KÃ¹zu's disk-based storage, allowing you to train GNNs on graphs that don't fit on your RAM. One distinct advantage of KÃ¹zu is that, because it is an embeddable DBMS,
we can do the conversion of scanned node features from KÃ¹zu into PyG's tensors as a zero-copy operation. We simply write the scanned node features into a buffer array allocated in Python without any additional data transfer between the systems.</p><p>Currently, only the <code>feature_store</code> scans data from KÃ¹zu's disk-based storage. For <code>graph_store</code>, our current implementation stores the entire graph topology in COO format in memory. This does limit how much you can scale, but in many models trained on large graphs, features take up more space than the graph topology, so scaling node features out of memory should still allow you to scale to very lage graphs that won't fit in your RAM.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="adjusting-kÃ¹zus-buffer-pool-size">Adjusting KÃ¹zu's Buffer Pool Size<a href="#adjusting-kÃ¹zus-buffer-pool-size" class="hash-link" aria-label="Direct link to Adjusting KÃ¹zu's Buffer Pool Size" title="Direct link to Adjusting KÃ¹zu's Buffer Pool Size">â€‹</a></h3><p>As with most DBMSs, KÃ¹zu has a Buffer Manager that maintains a buffer pool to keep parts of the database in memory. When you use KÃ¹zu, you decide how much memory to allocate to it. The more memory you give to KÃ¹zu, the less I/O it will perform on scans. So, in the context of this post, the larger the buffer manager size you set, the faster your training time will be when training large graphs out of memory. You set KÃ¹zu's buffer pool size when you construct your <code>Database</code> object, before you call the <code>get_torch_geometric_remote_backend()</code> function. For example, the code below sets the BM size to <code>40 * 1024**3</code> bytes, which is equal to 40GB. You should set it as high as possible without running out of memory for performance reasons.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">KUZU_BM_SIZE = 40 * 1024**3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Create kuzu database</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db = kuzu.Database("papers100M", KUZU_BM_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">feature_store, graph_store = db.get_torch_geometric_remote_backend(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mp.cpu_count())</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="an-experiment-demonstrating-throughput-numbers-with-different-buffer-pool-sizes">An Experiment Demonstrating Throughput Numbers With Different Buffer Pool Sizes<a href="#an-experiment-demonstrating-throughput-numbers-with-different-buffer-pool-sizes" class="hash-link" aria-label="Direct link to An Experiment Demonstrating Throughput Numbers With Different Buffer Pool Sizes" title="Direct link to An Experiment Demonstrating Throughput Numbers With Different Buffer Pool Sizes">â€‹</a></h2><p>Let's demonstrate what troughput numbers you can expect under different memory settings.
As a baseline we will first measure the throughput of training
as time/batch using PyG's default in-memory
storage. This seting uses ~106GB of memory.
We will then simulate limited memory settings by training the same
model using KÃ¹zu Remote Backend and limiting KÃ¹zu's buffer pool size to
different levels.
Here are the important configurations for the experiment:</p><ul><li>Available RAM in the machine: 384GB RAM</li><li>CPU: Two Xeon Platinum 8175M (48 cores/96 threads)</li><li>GPU: RTX 4090 with 24GB GPU memory</li><li>SSD in the system for disk storage: 2TB Kingston KC3000 NVMe SSD</li><li>Mini-batch size: 1152. Recall the <code>kuzu_sampler = NeighborLoader(...)</code> that we defined above. There we gave this argument
<code>num_neighbors={('paper', 'cites', 'paper'): [12, 12, 12]}</code> to the <code>NeighborLoader</code>, which means that the sampler will sample 3-degree neighbors of these 1152 nodes,
sampling 12 neighbors at each degree.
We picked 1152 as our mini-batch size because this is the size at which we generate batches that take a peak of 23GB of memory, so beyond this we would run out of GPU memory. <sup id="fnref-1-5f0073"><a href="#fn-1-5f0073" class="footnote-ref">1</a></sup></li><li>#<!-- --> PyG Workers: 16 (we did a parameter sweep and setting this to 4, 8, 16 perform very similarly)</li><li>#<!-- --> KÃ¹zu Query Processor Threads: 24 (48 and 96 also perform similarly)</li></ul><p>We will run KÃ¹zu with 60GB, 40GB, 20GB, and 10GB buffer pool size.
The lower KÃ¹zu's buffer pool size, the more
disk I/Os KÃ¹zu will perform. Note however that in this experiment KÃ¹zu will use more memory than
these sizes for two reasons: (i) KÃ¹zu stores some parts of the database always in memory
though this is not very important in this setting; (ii) As we said, currently
KÃ¹zu Remote Backend uses in-memory storage for the graph topology (but not node features!),
which takes ~48GB of RAM. So you can roughly think of KÃ¹zu using 48 + BM size in these experiments.</p><p>We will do 500 batches of training and report the throughput number as average end-to-end time/batch.
We also report the time that's spent on GPU for Training as <code>Training Time (s)</code> and
time spent on copying data from CPU to GPU as <code>CPU-to-GPU Copying Time (s)</code>. For
KÃ¹zu configurations, you can roughly
interpret <code>Per Batch Time (s) -  Training Time (s) -  CPU-to-GPU Copying Time (s)</code>
as the time spent for scanning data from KÃ¹zu into CPU's memory. We expect that to increase
as we lower the BM size.</p><table><thead><tr><th>Configuration</th><th>Per Batch Time (s)</th><th>Training Time (s)</th><th>CPU-to-GPU Copying Time</th><th>Time Scanning Data from KÃ¹zu</th><th>Memory Usage</th></tr></thead><tbody><tr><td>PyG In-memory</td><td>0.281</td><td>0.240</td><td>0.024</td><td>---</td><td>~110 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=60GB)</td><td>0.380 (1.35x)</td><td>0.239</td><td>0.018</td><td>0.123</td><td>~110 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=40GB)</td><td>0.513 (1.82x)</td><td>0.239</td><td>0.022</td><td>0.251</td><td>~90 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=20GB)</td><td>1.162 (4.88x)</td><td>0.238</td><td>0.022</td><td>0.901</td><td>~70 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=10GB)</td><td>1.190 (4.23x)</td><td>0.238</td><td>0.022</td><td>0.930</td><td>~60 GB</td></tr></tbody></table><p>So, when have enough memory, there is about 1.35x slow down (from 0.281s to 0.380s per batch)
compared to using PyG's default storage. This
is the case when KÃ¹zu has enough buffer memory (60GB) to store the features but we still incur the cost of
scanning them through KÃ¹zu's buffer manager. So no disk I/O happens (except the first time
the features are scanned to the buffer manager). When we use 40GB of buffer pool and below, we start doing some I/O,
and the average time per batch degrade to 0.513, 1.162, amd 1.190 respectively when using 40GB, 20GB, and 10GB.
We seem to stabilize around 4x degradation at 10GB or 20GB level, where most of the feature scans
are now happening from disk. These numbers hopefully look good for many settings!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="next-steps">Next Steps<a href="#next-steps" class="hash-link" aria-label="Direct link to Next Steps" title="Direct link to Next Steps">â€‹</a></h2><p>We will be doing 2 immediate optimizations in the next few releases
related to KÃ¹zu's PyG integration.
First, we will change our <code>graph_store</code> to use an in DBMS subgraph sampler, so we can virtually work at any limited memory level.
Second, in an even earlier release, we had a more basic PyG integration feature, the
<a href="https://kuzudb.com/docs/client-apis/python-api/query-result.html#query_result.QueryResult.get_as_torch_geometric" target="_blank" rel="noopener noreferrer"><code>QueryResult.get_as_torch_geometric()</code></a> function.
This feature is more of an ETL feature. It is designed for cases where you want to filter
a subset of your nodes and edges and convert them directly into PyG <code>HeteroData</code> objects (i.e., use PyG's default in-memory storage)
as you build PyG pipelines using graph databases you store in KÃ¹zu.
If you are converting a large graph this can be quite slow, and we will be improving this so that such ETL pipelines
are much faster!</p><p>We are excited to hear about your feedback on KÃ¹zu's PyG integration features and get more ideas about
how else we can help users who are building GNN pipelines. Please reach out to us over <a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" target="_blank" rel="noopener noreferrer">KÃ¹zu Slack</a>
for your questions and ideas!.</p><div class="footnotes"><hr><ol><li id="fn-1-5f0073">If you read our <a href="https://kuzudb.com/blog/kuzu-0.0.3-release.html#k%C3%B9zu-as-a-pyg-remote-backend" target="_blank" rel="noopener noreferrer">v0.0.3 blog post</a>,
which had a shorter section about PyG interface, you will notice that we used a much larger batch size there (48000),
which was the size that saturated GPU memory. Although the example there was also on the <code>ogbn-papers100M</code> dataset, we used a much smaller model with ~200K parameters
and sampled subgraphs from 2 degree neighbors of these batches. Now we use a much larger model with 5.6 million parameters and samples from 3-degree neighbors.<a href="#fnref-1-5f0073" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>Chang Liu</name>
            <uri>https://www.linkedin.com/in/mewim/</uri>
        </author>
        <author>
            <name>Semih SalihoÄŸlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="use-case" term="use-case"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.3 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.3-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.3-release"/>
        <updated>2023-04-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are happy to release KÃ¹zu 0.0.3 today. This release comes with the following new main features and improvements:]]></summary>
        <content type="html"><![CDATA[<p>We are happy to release KÃ¹zu 0.0.3 today. This release comes with the following new main features and improvements:</p><ul><li><a href="/docusaurus/blog/kuzu-0.0.3-release#k%C3%B9zu-as-a-pyg-remote-backend">KÃ¹zu as a Pytorch Geometric (PyG) Remote Backend</a>: You can now train PyG GNNs and other models directly using graphs (and node features) stored on KÃ¹zu.  See this <a href="https://colab.research.google.com/drive/12fOSqPm1HQTz_m9caRW7E_92vaeD9xq6" target="_blank" rel="noopener noreferrer">Colab notebook</a>
for a demonstrative example. </li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#data-ingestion-improvements">Data ingestion from multiple files and numpy files</a>: See below for details</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#query-optimizer-improvements">Query optimizer improvements</a>: See below for details</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#new-buffer-manager">New buffer manager</a>: A new state-of-art buffer manager based on <a href="https://www.cs.cit.tum.de/fileadmin/w00cfj/dis/_my_direct_uploads/vmcache.pdf" target="_blank" rel="noopener noreferrer">VMCache</a>.</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#new-data-types">INT32, INT16, FLOAT, and FIXED LIST data types</a> (the latter is particularly suitable to store node features in graph ML applications)</li><li><a href="/docusaurus/blog/kuzu-0.0.3-release#other-system-functionalities">Query timeout mechanism and interrupting queries from CLI</a>.</li></ul><p>For installing the new version,
please visit the <a href="https://kuzudb.com/#download" target="_blank" rel="noopener noreferrer">download section of our website</a>
and <a href="https://kuzudb.com/docs/getting-started.html" target="_blank" rel="noopener noreferrer">getting started guide</a> and the full
<a href="https://github.com/kuzudb/kuzu/releases" target="_blank" rel="noopener noreferrer">release notes are here</a>. Please visit
the <a href="https://kuzudb.com/docs/getting-started/colab-notebooks" target="_blank" rel="noopener noreferrer">Colab Notebooks</a> section of our
documentation website to play with our <a href="https://kuzudb.com/docs/getting-started/colab-notebooks" target="_blank" rel="noopener noreferrer">Colab notebooks</a>.</p><p>Enjoy! Please give us a try, <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">a Github â­</a> and your feedback and feature requests! Also follow
us on <a href="https://twitter.com/kuzudb" target="_blank" rel="noopener noreferrer">Twitter</a>!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="kÃ¹zu-as-a-pyg-remote-backend">KÃ¹zu as a PyG Remote Backend<a href="#kÃ¹zu-as-a-pyg-remote-backend" class="hash-link" aria-label="Direct link to KÃ¹zu as a PyG Remote Backend" title="Direct link to KÃ¹zu as a PyG Remote Backend">â€‹</a></h2><p>KÃ¹zu now implements PyG's Remote Backend interface. So you can directly
train GNNs using KÃ¹zu as your backend storage. Quoting <a href="https://pytorch-geometric.readthedocs.io/en/latest/advanced/remote.html" target="_blank" rel="noopener noreferrer">PyG documentation's</a> description
of the Remote Backend feature:</p><blockquote><p>...<!-- -->[this feature enables]<!-- --> users to train GNNs on graphs far larger than the size of their
machineâ€™s available memory. It does so by introducing simple, easy-to-use, and extensible abstractions of a <code>torch_geometric.data.FeatureStore</code> and a   <code>torch_geometric.data.GraphStore</code> that plug directly into existing familiar PyG interfaces.</p></blockquote><p>With our current release, once you store your graph and features in KÃ¹zu,
PyG's samplers work seamlessly using KÃ¹zu's implementation of <code>FeatureStore</code> and <code>GraphStore</code> interfaces. For example,
this enables your existing GNN models to work seamlessly by fetching both subgraph samples and node features
from KÃ¹zu instead of PyG's in-memory storage.
Therefore you can train graphs that do not
fit into your memory since KÃ¹zu, as a DBMS, stores its data on disk. Try this demonstrative <a href="https://colab.research.google.com/drive/12fOSqPm1HQTz_m9caRW7E_92vaeD9xq6" target="_blank" rel="noopener noreferrer">Colab notebook</a> to
see an example of how to do this. The current release comes with a limitation that we only truly implement the <code>FeatureStore</code> interface.
Inside <code>GraphStore</code> we still store the graph topology in memory.
So in reality only the features are stored and scanned from disk. We plan to address this limitation later on.</p><p>Here is also a demonstrative experiment (but certainly not comprehensive study) for the type of training performance
vs memory usage tradeoff you can expect.
We trained a simple 3-layers Graph Convolutional Network (GCN) model on <a href="https://ogb.stanford.edu/docs/nodeprop/#ogbn-papers100M" target="_blank" rel="noopener noreferrer">ogbn-papers100M</a> dataset, which contains about 111 million nodes
with 128 dimensional node features and about 1.6 billion edges.
Storing the graph topology takes around 48GB<sup id="fnref-1-3b764c"><a href="#fn-1-3b764c" class="footnote-ref">1</a></sup> and the features takes 53 GBs. Given our current limitation,
we can reduce 53 GB to something much smaller (we will limit it to as low as 10GB).
We used a machine with one RTX 4090 GPU with 24 GB of memory, two Xeon Platinum 8175M CPUs, and 384 GB RAM, which
is enough for PyG's in-memory store to store the entire graph and all features in memory.</p><p>During training, we use the <code>NeighborLoader</code> of PyG with batch size of 48000 and sets the <code>num_neighbors</code> to <code>[30] * 2</code>, which means at each batch roughly 60 neighbor nodes of 48000 nodes will be sampled from the <code>GraphStore</code> and the features of those nodes will be scanned
from KÃ¹zu's storage. We picked this sample size because this gives us a peak GPU memory usage of approximately 22 GB, i.e.,
we can saturate the GPU memory. We used 16 cores<sup id="fnref-2-3b764c"><a href="#fn-2-3b764c" class="footnote-ref">2</a></sup> during the sampling process. We run each experiment in a Docker instance
and limit the memory systematically from 110GB, which is enough for PyG to run completely in memory, down to 90, 70, and 60GB.
At each memory level we run the same experiment by using KÃ¹zu as a Remote Backend, where we
have to use about 48GB to store the topology and give the remaining memory to KÃ¹zu's buffer manager.
For example when the memory is 60GB, we can only give ~10GB to KÃ¹zu.</p><table><thead><tr><th>Configuration</th><th>End to End Time (s)</th><th>Per Batch Time (s)</th><th>Time Spent on Training (s)</th><th>Time Spent on Copying to GPU (s)</th><th>Docker Memory</th></tr></thead><tbody><tr><td>PyG In-memory</td><td>140.17</td><td>1.4</td><td>6.62</td><td>31.25</td><td>110 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=60GB)</td><td>392.6</td><td>3.93</td><td>6.29</td><td>34.18</td><td>110 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=40GB)</td><td>589.0</td><td>5.89</td><td>6.8</td><td>32.6</td><td>90 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=20GB)</td><td>1156.1</td><td>11.5</td><td>6.0</td><td>36</td><td>70 GB</td></tr><tr><td>KÃ¹zu Remote Backend (bm=10GB)</td><td>1121.92</td><td>11.21</td><td>6.88</td><td>35.03</td><td>60 GB</td></tr></tbody></table><p>So, when have enough memory, there is about 2.8x slow down (from 1.4s to 3.93s per batch). This
is the case when KÃ¹zu has enough buffer memory (60GB) to store the 53GB of features but we still incur the cost of
scanning them through KÃ¹zu's buffer manager. So no or very little disk I/O happens (except the first time
the features are scanned to the buffer manager). Then as we lower the memory, KÃ¹zu can hold only part
of the of node features in its buffer manager, so
we force KÃ¹zu to do more and more I/O. The per batch time increase to 5.89s at 40GB of buffer manager size,
then seems to stabilize around 11s (so around 8.2x slowdown). </p><p>The slow down is better if you use smaller batch sizes but for the end to end training time, you
should probably still prefer to use larger batch sizes. This is a place where we would need to
do more research to see how much performance is on the table with further optimizations.</p><p>But in summary, if you have
large datasets that don't fit on your current systems' memories and would like to easily train your PyG models
off of disk (plus get all the usability features of a GDBMS as you prepare your datasets for training),
this feature can be very useful for you!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-ingestion-improvements">Data Ingestion Improvements<a href="#data-ingestion-improvements" class="hash-link" aria-label="Direct link to Data Ingestion Improvements" title="Direct link to Data Ingestion Improvements">â€‹</a></h2><p><strong>Ingest from multiple files</strong>: You can now load data from multiple files of the same type into a node/rel table in two ways:</p><ul><li><strong>file list</strong>: <code>["vPerson0.csv", "vPerson1.csv", "vPerson2.csv"]</code></li><li><strong>glob pattern matching</strong>: Similar to Linux <a href="https://man7.org/linux/man-pages/man7/glob.7.html" target="_blank" rel="noopener noreferrer">Glob</a>, this will load files that matches the glob pattern.</li></ul><p><strong>Ingest from npy files</strong>: We start exploring how to enable data ingesting in column by column fashion. Consider a <code>Paper</code> table defined in the following DDL.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE NODE TABLE Paper(id INT64, feat FLOAT[768], year INT64, label DOUBLE, PRIMARY KEY(id));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Suppose your raw data is stored in npy formats where each column is represented as a numpy array on disk:
"node_id.npy", "node_feat_f32.npy", "node_year.npy", "node_label.npy".
You can now directly copy from npy files where each file is loaded to a column in <code>Paper</code> table as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">COPY Paper FROM ("node_id.npy", "node_feat_f32.npy", "node_year.npy", "node_label.npy") BY COLUMN;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Reduce memory consumption when ingesting data into node tables:</strong>
This release further optimizes the memory consumption during data ingestion of node tables.
We no longer keep the whole node table in memory before flushing it to disk as a whole. Instead, we process a chunk of a file
and flush its corresponding pages, so incur only the memory cost of ingesting a chunk (or as many chunks as there are threads running).
This greatly reduces memory usage when the node table is very large.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="query-optimizer-improvements">Query Optimizer Improvements<a href="#query-optimizer-improvements" class="hash-link" aria-label="Direct link to Query Optimizer Improvements" title="Direct link to Query Optimizer Improvements">â€‹</a></h2><p><strong>Projection push down for sink operator</strong>:
We now push down projections down to the first sink operator
above the last point in a query plan they are needed.
Consider the following query</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:person) WHERE a.age &gt; 35 RETURN a.salary AS s ORDER BY s;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This query's (simplified) plan is:  <code>Scan-&gt;Filter-&gt;OrderBY-&gt;ResultCollector</code>, where both
<code>ORDER BY</code> and the final <code>ResultCollector</code> are sink operators.
<code>ResultCollector</code> is where we accumulate the expressions in the <code>RETURN</code> clause.
This is simplified because <code>ORDER BY</code> actually consists of several physical operators.
Both column <code>age</code> and <code>salary</code> are scanned initially but only <code>salary</code> is needed in <code>ResultCollector</code>.
<code>age</code>, which is needed by <code>Filter</code> is projected out in the <code>ResultCollector</code>. We now push the projection of <code>age</code>
to <code>ORDER BY</code>, so <code>ORDER BY</code> does not have to materialize it.</p><p><strong>Other optimizations:</strong> We implemented several other optimizations, such as we reorder the filter expressions so equality conditions
are evaluated first, several improvements to cardinality estimator, and improved sideway information passing for joins. For the latter,
in our core join operator, which we called  ASP-Joins in our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>, we would blindly
perform sideways information passing (sip) from build to probe (or vice versa;
see <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">our paper</a> for details). Sometimes if there is no
filters on the probe and build sides, this is just an overhead as it won't decrease the amount of scans on either side.
In cases where we think sip won't help reduce scans, we do vanilla Hash Joins now.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-buffer-manager">New Buffer Manager<a href="#new-buffer-manager" class="hash-link" aria-label="Direct link to New Buffer Manager" title="Direct link to New Buffer Manager">â€‹</a></h2><p>Before this release, we had two internal buffer pools with 2 different frame sizes of 4KB and 256KB,
so operators could only grab buffers of these two sizes. Plus when you loaded your DB and wanted to allocate
say 10GB buffer pool, we manually gave a fixed percentage to 4KB pool and the rest to 256KB pool.
This didn't give any flexibility for storing large objects and complicated code to manage
buffers when operators needed them.  Terrible design;
just don't do this!</p><p>We bit the bullet and decided to read the literature and pick a state-of-art buffer manager design that is
also practical. We switched to the mmap-based approach described in VMCache design from <a href="https://www.cs.cit.tum.de/fileadmin/w00cfj/dis/_my_direct_uploads/vmcache.pdf" target="_blank" rel="noopener noreferrer">this recent paper</a> by Leis et al..
This is a very nice design
and makes it very easy to support multiple buffer sizes very easily and only uses hardware locks (we used
software locks in our previous buffer manager). It also supports using optimistic reading,
which we verified improves our query performance a lot.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="new-data-types">New Data Types<a href="#new-data-types" class="hash-link" aria-label="Direct link to New Data Types" title="Direct link to New Data Types">â€‹</a></h2><p>We now support several additional data types that were missing.</p><p><strong><a href="https://kuzudb.com/docs/cypher/data-types/list.html" target="_blank" rel="noopener noreferrer">FIXED-LIST</a> data type:</strong> This is important if you're doing graph ML and storing node features
in KÃ¹zu. It is the efficient way to store fixed-length vectors. Here's the summary of how
to declare a node or rel property in your schemas to use the fixed-list data type.</p><table><thead><tr><th>Data Type</th><th>Description</th><th>DDL definition</th></tr></thead><tbody><tr><td>FIXED-LIST</td><td>a list of fixed number of values of the same numerical type</td><td>INT64<!-- -->[8]</td></tr></tbody></table><p>When possible use FIXED LIST instead of regular <a href="https://kuzudb.com/docs/cypher/data-types/list.html" target="_blank" rel="noopener noreferrer">VAR-LIST</a> data type
for cases when you know the size of your lists/vectors. It's much more efficient.</p><p>Note that FIXED-LIST is an experimental feature. Currently only bulk loading (e.g. <code>COPY</code> statement) and reading is supported.</p><p><strong>INT32, INT16, FLOAT data types:</strong> The release also comes with support for the following data types:</p><table><thead><tr><th>Data Type</th><th>Size</th><th>Description</th></tr></thead><tbody><tr><td>INT32</td><td>4 bytes</td><td>signed four-byte integer</td></tr><tr><td>INT16</td><td>2 bytes</td><td>signed two-byte integer</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>single precision floating-point number</td></tr></tbody></table><p>For our next release, our focus on data types will be on complex ones, STRUCT and MAP. So stay tuned for those!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="other-system-functionalities">Other System Functionalities<a href="#other-system-functionalities" class="hash-link" aria-label="Direct link to Other System Functionalities" title="Direct link to Other System Functionalities">â€‹</a></h2><p><strong>Query timeout</strong>: We will now automatically stop any query that exceeds a specified timeout value (if one exists).
The default query timeout value is set to -1, which signifies that the query timeout feature is initially disabled.
You can activate the query timeout by configuring a positive timeout value through:</p><ul><li><ol><li>C++ API: <code>Connection::setQueryTimeOut(uint64_t timeoutInMS)</code></li></ol></li><li><ol start="2"><li>CLI: <code>:timeout [timeoutValue]</code></li></ol></li></ul><p><strong>Interrupt:</strong> You can also interrupt your queries and can stop your long running queries manually. There
are two ways to do this:</p><ul><li>C++ API: <code>Connection::interrupt()</code>: interrupt all running queries within the current connection.</li><li>CLI: interrupt through <code>CTRL + C</code></li></ul><p>Note: The Interruption and Query Timeout features are not applicable to <code>COPY</code> commands in this release.</p><div class="footnotes"><hr><ol><li id="fn-1-3b764c">Internally, PyG coverts the edge list to CSC format for sampling, which duplicates the graph structures in memory. When you download the graph topology it actually takes about 24GB.<a href="#fnref-1-3b764c" class="footnote-backref">â†©</a></li><li id="fn-2-3b764c">We set <code>num_workers</code> to 16 when running the PyG in-memory setup. Since KÃ¹zu does not currently work with multiple workers in Python, we limit <code>num_workers</code> to 1 when sampling from KÃ¹zu but internally KÃ¹zu scans in parallel with 16 threads.<a href="#fnref-2-3b764c" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms]]></title>
        <id>https://kuzudb.com/docusaurus/blog/wcoj</id>
        <link href="https://kuzudb.com/docusaurus/blog/wcoj"/>
        <updated>2023-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Joins of a sets of records is objectively the most expensive operation in DBMSs.]]></summary>
        <content type="html"><![CDATA[<p>Joins of a sets of records is objectively the most expensive operation in DBMSs.
In my previous post on <a href="/docusaurus/blog/factorization">factorization</a>, I said that in the field of databases, once
in a while you run into a very simple idea that deviates from the norm that gets you very excited.
Today, I will discuss another such idea, worst-case optimal join (wcoj) algorithms.
Wcoj algorithms and the theory around it in one sentence says this:</p><ul><li>Queries involving complex "cyclic joins" over many-to-many relationships should be
evaluated column at a time instead of table at a time, which is the norm. </li></ul><p>Wcoj algorithms find their best applications when finding cyclic patterns on graphs,
such as cliques or cycles, which is common in the workloads of fraud detection and
recommendation applications. As such, they should be integrated into every graph DBMS
(and possibly to RDBMSs) and I am convinced that they eventually will.</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>History of Wcoj Algorithms:</strong> Research on wcoj algorithms started with a solution to open question
about the maximum sizes of join queries. This result made researchers realize this: the traditional
"binary join plans" paradigm of generating query plans that join 2 tables a time
until all of the tables in the query are joined is provably
suboptimal for some queries. Specifically, when join queries are
cyclic, which in graph terms means when the searched graph pattern has cycles
in it, and the relationships between records are many-to-many, then this
paradigm can generate unnecessarily large amounts of intermediate results.</li><li><strong>Core Algorithmic Step of Wcoj Algorithms:</strong>  Wcoj algorithms fix this sub-optimality by
performing the joins one column at a time (instead of 2 tables at a time) using multiway intersections.</li><li><strong>How KÃ¹zu Integrates Wcoj Algorithms:</strong> KÃ¹zu generates plans that seamlessly mix binary joins
and wcoj-style multiway intersections. Multiway intersections are performed by an operator called
"multiway HashJoin", which has one or more build phases that creates one or more hash tables that stores
sorted adjacency lists; and a probe phase that performs multi-way intersections using the sorted lists.</li><li><strong>Yes, the Term "Worst-case Optimal" Is Confusing Even to Don Knuth:</strong> I know, Don Knuth also found the term
"worst-case optimal" a bit confusing. See my <a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">anecdote on this</a>.
It basically means that the worst-case runtimes of these algorithms are asymptotically optimal.</li></ul></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="joins-running-example--traditional-table-at-a-time-joins">Joins, Running Example &amp; Traditional Table-at-a-time Joins<a href="#joins-running-example--traditional-table-at-a-time-joins" class="hash-link" aria-label="Direct link to Joins, Running Example &amp; Traditional Table-at-a-time Joins" title="Direct link to Joins, Running Example &amp; Traditional Table-at-a-time Joins">â€‹</a></h2><p>Joins are objectively the most expensive and powerful operation in DBMSs.
In SQL, you indicate them in the FROM clause by listing
a set of table names, in Cypher in the MATCH clause, where you draw a graph pattern
to describe how to join node records with each other.
As a running example, consider a simple social network of users and followers,
whose node-link diagram is shown below. I am also showing the table that contains these records
in a <code>User</code> (ignore the <code>name</code> property for now) and <code>Follows</code> tables.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-running-ex-data-cba423e4b308520aec94e4553da2914c.png" class="img_ev3q"></div><p>Consider finding triangles, which is one of the simplest
forms of cycles and cliques, in this network. The SQL and Cypher
versions of this query are shown below. </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SQL:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM  Follows f1, Follows f2, Follows f3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE f1.dst=f2.src AND f2.dst=f3.src AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      f3.dst = f1.src</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Cypher:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[f1:Follows]-&gt;(b:User)-[f2:Follows]-&gt;(c:User)-[f3:Follows]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN  *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That long MATCH clause "draws" a triangle and for our case here, this is equivalent
to joining three copies of the Follows table. </p><p>Now ever since the System R days and <a href="https://courses.cs.duke.edu/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf" target="_blank" rel="noopener noreferrer">Patricia Selinger's 1979 seminal paper</a> that
described how System R compiled and optimized SQL queries, there has been an
unchallenged dogma in DBMSs that the joins specified in the query would be
evaluated pairwise, table at a time.
Here's a blurb from Selinger's paper, where one can see this
assumption:
"<em>In System R a user need not know how the
tuples are physically stored ... Nor does a user
specify in what order joins are to be performed. The System
R optimizer chooses both join order and ...</em>"
To this day, this is the norm. DBMSs pick a "join order" which is the order in
which the tables should be joined iteratively 2 at a time.
In the above example, for example
there are three possible join orders. One way to represent these orders is by
writing different parenthesization of the joins: </p><ul><li>(i) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>â‹ˆ</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo><mo>â‹ˆ</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F2) \bowtie F3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>; (ii) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>â‹ˆ</mo><mo stretchy="false">(</mo><mi>F</mi><mn>2</mn><mo>â‹ˆ</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F1 \bowtie (F2 \bowtie F3))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">))</span></span></span></span></span>;
and (iii) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>â‹ˆ</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo><mo>â‹ˆ</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F3) \bowtie F2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span>. </li></ul><p>The optimization problem for a system is of course more complex than just
ordering tables because the system also has to choose which
binary join algorithm to use when joining each pair of tables, e.g., hash joins vs merge joins.
But take any system you want, and they will all follow the same paradigm of
joining 2 base or intermediate tables iteratively, until all tables are joined:
hence the term <em>binary joins</em> to describe the plans of existing systems.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-math-puzzle-that-started-it-all">A Math Puzzle That Started it All<a href="#a-math-puzzle-that-started-it-all" class="hash-link" aria-label="Direct link to A Math Puzzle That Started it All" title="Direct link to A Math Puzzle That Started it All">â€‹</a></h2><p>So, what's the problem with binary join plans? When join queries are cyclic
and the relationships are many-to-many, they can generate provably large amounts
of (so unnecessary in a formal sense) intermediate results. First, cyclicity for
join queries has formal (and a bit intimidating) definitions but if you think of
graph patterns, it simply means that the searched pattern's undirected version has
cycles. Why do binary joins generate unnecessarily large intermediate results? I'll
get to this below but first a bit of history on the origins of this insight.
The whole topic of "worst-case optimal joins" started with 2 papers, a <a href="https://arxiv.org/abs/1711.04506" target="_blank" rel="noopener noreferrer">2007 SODA</a>
and a <a href="https://arxiv.org/abs/1711.03860" target="_blank" rel="noopener noreferrer">2008 FOCS</a>
paper, which are top venues in algorithms and theory. In these papers,
several theoreticians solved a fundamental open question
about join queries. Suppose I give you:</p><ol><li>An arbitrary natural join query, say of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span> relations. In DBMS literature we denote such
queries as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>R</mi><mn>1</mn><mo stretchy="false">(</mo><msub><mi>a</mi><mn>11</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>r</mi><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>â‹ˆ</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>â‹ˆ</mo><mi>R</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>r</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q=R1(a_{11}, ..., a_{r1}) \bowtie ... \bowtie Rm(a_{m1}, ..., a_{rm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.</li><li>Sizes of R1, ..., Rm, e.g., for simplicity assume they all have <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many tuples. </li></ol><p>"Natural" here means that the join predicates are equality predicates on identical column
names. You, as the second person in this puzzle, are allowed to set the values inside these relations.
<strong>The open question was: how large can you make the final output?</strong> So for example, if I told you that there are
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many tuples in the <code>Follows</code> tables, what is the maximum number of triangle outputs there can  be?<sup id="fnref-1-627daf"><a href="#fn-1-627daf" class="footnote-ref">1</a></sup>
Even more concretely for the triangle query, the question is: out of all possible graphs with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many edges,
what is the maximum number of triangles they contain?</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-edge-covers-35e349b3d28dc29585b69a3173b820da.png" class="img_ev3q"></div><p>It still surprises me that the answer to this question was not known until 2008.
It just looks like a fundamental question someone in databases must have answered before.
Now excuse me for bombarding your brains with some necessary math definitions.
These two papers showed that the answer is: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><msup><mi>Ï</mi><mo>âˆ—</mo></msup></msup></mrow><annotation encoding="application/x-tex">IN^{\rho^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8973em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8973em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Ï</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Ï</mi><mo>âˆ—</mo></msup></mrow><annotation encoding="application/x-tex">\rho^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">Ï</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span></span></span> is a property
of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span></span></span></span></span> called the <em>fractional edge cover number</em> of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span></span></span></span></span>.
This is the solution to
an optimization problem and best explained by thinking about the "join query graph",
which, for our purposes, is the triangle graph pattern (ignoring the edge directions), shown
in Fig 2a and 2b.</p><p>The optimization problem is this:
put a weight between <!-- -->[0, 1]<!-- --> to
each "query edge" such that each "query node" is "covered", i.e., the sum of
the query edges touching each query node is &gt; 1. Each such solution is called an
edge cover. The problem is to find the edge cover whose total weight is the minimum. That is
called the fractional edge cover number of the query. For the triangle query,
one edge cover, shown in Fig 2a, is <!-- -->[1, 1, 0]<!-- -->, which has
a total weight of 1 + 1 + 0 = 2.
The minimum weight edge cover is <!-- -->[1/2, 1/2, 1/2]<!-- -->, shown in Fig 2b,
with a total weight  of 1.5. Therefore, the fractional edge cover number <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Ï</mi><mo>âˆ—</mo></msup></mrow><annotation encoding="application/x-tex">\rho^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">Ï</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span></span></span>
of the triangle query is 1.5.
In general, each edge cover is an upper bound but the FOCS paper showed
that the fractional edge cover number is the tight upper bound.
So the maximum number of triangles there can be on a graph with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> edges is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î˜</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(IN^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord">Î˜</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
and this is tight, i.e., there are such graphs. Nice scientific progress!
Nowadays, the quantity <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><msup><mi>Ï</mi><mo>âˆ—</mo></msup></msup></mrow><annotation encoding="application/x-tex">IN^{\rho^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8973em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8973em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Ï</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> is known as the <code>AGM bound</code> of a query,
after the first letters of the last names of the authors of the FOCS paper.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="problem-with-table-at-a-timebinary-joins">Problem With Table-at-a-time/Binary Joins<a href="#problem-with-table-at-a-timebinary-joins" class="hash-link" aria-label="Direct link to Problem With Table-at-a-time/Binary Joins" title="Direct link to Problem With Table-at-a-time/Binary Joins">â€‹</a></h2><p>Now this immediately made the same researchers realize that binary join plans are
provably sub-optimal because they can generate polynomially more intermediate results
than the AGM bound of the query. This happens because on cyclic queries,
the strategy of joining tables
2 at a time may lead to unnecessarily computing some acyclic sub-joins.
For example, in the triangle query, the plan
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>â‹ˆ</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo><mo>â‹ˆ</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F2) \bowtie F3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> first computes <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>â‹ˆ</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F1 \bowtie F2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">â‹ˆ</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> sub-join,
which in graph terms computes the 2-paths in the graph.
This is a problem because often there can be many more of these acyclic sub-joins
than there can be outputs for the cyclic join.
For this plan, there can
be <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">IN^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> many 2-paths (which is the AGM bound of 2-paths),
which is polynomially larger than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup></mrow><annotation encoding="application/x-tex">IN^{1.5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span></span></span></span></span>.
For example in our running example, there are 1000<!-- -->*<!-- -->1000 = 1M many 2 paths,
but on a graph with 2001 edges there can be at most 89.5K triangles (well ours
has only 3 triangles (because the triangle query we are using is symmetric
the sole triangle would generate 3 outputs for 3 rotations of it)).</p><p>Any other plan in this case would have generated <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">IN^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> many 2-paths,
so there is no good binary join plan here. I want to emphasize that this sub-optimality does not occur
when the queries are acyclic or when the dataset does not have
many-to-many relationships. If the joins were primary-foreign key non-growing joins,
then binary join plans will work just fine. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solution-column-at-a-time-worst-case-optimal-join-algorithms">Solution: Column-at-a-time "Worst-case Optimal" Join Algorithms<a href="#solution-column-at-a-time-worst-case-optimal-join-algorithms" class="hash-link" aria-label="Direct link to Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms" title="Direct link to Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms">â€‹</a></h2><p>So the immediate
next question is: are there algorithms whose runtimes can be bounded by
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(IN^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>? If so, how are they different? The answer to this question
is a bit anti-climactic. The core idea existed in the 2007 SODA and 2008 FOCS papers,
though it was refined more ~4 years later in some theoretical papers
by <a href="https://hung-q-ngo.github.io/" target="_blank" rel="noopener noreferrer">Hung Ngo</a>, <a href="https://u.cs.biu.ac.il/~porat/" target="_blank" rel="noopener noreferrer">Ely Porat</a>,
<a href="https://cs.stanford.edu/~chrismre/" target="_blank" rel="noopener noreferrer">Chris RÃ©</a>, and <a href="https://cse.buffalo.edu/faculty/atri/" target="_blank" rel="noopener noreferrer">Atri Rudra</a>
in the database fields <a href="https://dl.acm.org/doi/10.1145/2213556.2213565" target="_blank" rel="noopener noreferrer">PODS</a> and
<a href="https://dl.acm.org/doi/10.1145/2590989.2590991" target="_blank" rel="noopener noreferrer">SIGMOD Record</a>. The answer is simply
to perform the join column at a time, using multiway
intersections. "Intersections of what?" you should be asking.
For joins over arbtrary relations, we need special indices but I want to
skip this detail.
In the context of GDBMSs, GDBMSs already
have join indices (aka adjacency list indices) and for the common joins
they perform, this will be enough for our purposes.</p><p>I will next demonstrate a wcoj
algorithm known as "Generic Join" from the <a href="https://dl.acm.org/doi/10.1145/2590989.2590991" target="_blank" rel="noopener noreferrer">SIGMOD Record paper</a>.
It can be seen as the simplest of all wcoj algorithms.
As "join order", we will pick a "column order"
instead of Selinger-style table order. So in our triangle query,
the order could be a,b,c. Then we will build indices over each relation
that is consistent with this order. In our case there are conceptually three (identical)
relations: <code>Follows1(a, b)</code>, <code>Follows2(b, c)</code>, <code>Follows3(c, a)</code>. For <code>Follows1</code>,
we need to be able to read all <code>b</code> values for a given <code>a</code> value (e.g., <code>a=5</code>).
In graph terms, this just means that we need "forward join index".
For <code>Follows3</code>, because <code>a</code> comes earlier than <code>c</code>, we will want an index
that gives us <code>c</code> values for a given <code>a</code> value. This is equivalent to a
"backward join index". In graphs, because joins happen through the
relationship records, which can, for the purpose of the joins,
be taught of as a binary relation (src, dst), 2 indices is enough
for our purposes. On general relations, one may need many more indices.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-gj-simulation-fa62f030f92938f86bccfef623730795.png" style="width:600px" class="img_ev3q"></div><p>We will iteratively find: (i) all <code>a</code> values
that can be in the final triangles; (ii) all <code>ab</code>'s that be in the final
triangles; and (iii) all <code>abc</code>'s, which are the triangles. Let's simulate the computation:</p><ul><li>Step 1: Find all <code>a</code>'s. Here we will just take
all nodes as possible a values. This is shown under "Step 1" in the above figure.</li><li>Step 2: For each a value, e.g., a=1, we extend it to find all <code>ab</code>'s that
can be part of triangles: Here we use the forward index to look up all
<code>b</code> values for node with ID 1. So on and so forth. This will generate the
second intermediate relation.</li><li>Step 3: For each <code>ab</code> value, e.g., the tuple (a=1 b=0), we will
intersect all <code>c</code>'s with <code>a</code>=1, and all <code>c</code>'s with <code>b</code>=0. That is, we will intersect
the backward adjacency list of the node with ID 1, and forward adjacency list of
the node with ID 0. If the intersection is non-empty, we produce some triangles.
In this case, we will produce the triangle (<code>a</code>=1, <code>b</code>=0, <code>c</code>=1001)
The result of this computation will produce the third and final
output table in the figure.</li></ul><img loading="lazy" align="right" style="width:200px;padding-left:3px" src="/docusaurus/assets/images/wcoj-4-clique-7f96dfbbc1f31fd9ff502128749eb055.png" class="img_ev3q">Note that this process did not produce the 2-paths as an intermediate step, which is how wcoj algorithms fix for the sub-optimality of binary join algorithms. If your query was more complex then a wcoj algorithm can do k-way intersections where k &gt; 2. For example on the 4-clique query shown on the right, suppose the column order is abcd, then given abc triangles, we would do a 3-way intersection of forward index of a's, backward index of b's, and forward index of c's, to complete the triangles to joins. This type of multiway intersections is the necessary algorithmic step to be efficient on cyclic queries.<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-kÃ¹zu-performs-worst-case-optimal-join-algorithms">How KÃ¹zu Performs Worst-case Optimal Join Algorithms:<a href="#how-kÃ¹zu-performs-worst-case-optimal-join-algorithms" class="hash-link" aria-label="Direct link to How KÃ¹zu Performs Worst-case Optimal Join Algorithms:" title="Direct link to How KÃ¹zu Performs Worst-case Optimal Join Algorithms:">â€‹</a></h2><p>Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a> describes this in detail, so I will be brief here.
First, KÃ¹zu mixes binary joins and wcoj-like multiway intersections
following some principles that my PhD student <a href="http://amine.io/" target="_blank" rel="noopener noreferrer">Amine Mhedhbi</a>
had worked quite hard on early in his PhD. I recommend these two papers,
one by <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">Amine and me</a>
and one by the <a href="https://db.in.tum.de/~freitag/papers/p1891-freitag.pdf" target="_blank" rel="noopener noreferrer">Umbra group</a>
on several different ways people have proposed for mixing binary and wcoj algorithms in query plans.
Overall message of these studies is that, wcoj are critical when the query has a very cyclic component
and multiway intersections can help. If the query does not have this property,
systems should just use binary joins.
So wcoj-like computations should be seen as complementing binary join plans.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-kuzu-multiway-hash-join-a88a24d208d62d3d41d7475f5c15596a.png" style="width:600px" class="img_ev3q"></div><p>Second, KÃ¹zu performs multiway intersections in a <em>Multiway HashJoin</em> operator.
In our CIDR paper we call this operator Multiway ASPJoin. It can&nbsp;be thought
of a modified hash-join operator where we use multiple hash tables and do
an intersection to produce outputs as I will simulate.
Let me change the query a little and add a filter on <code>a.name = Noura</code>,
where <code>name</code> is the primary key of <code>User</code> records. You can see from Fig 1a
that Noura is the primary key of node with ID 1. In my simulation,
the Multiway HashJoin operator will take <code>ab</code> tuples and extend them
to <code>abc</code> tuples through a 2-way intersection. In general multiway HashJoin
has 3 phases: 1 accumulate phase, build phases to build k-2 hash tables,
and a probe phase. Here are the steps.</p><ul><li>Step 1 - Accumulate Phase: The operator receives the <code>ab</code> tuples which will be extended
to triangles. This allows the system to see exactly
the forward/backward lists of which nodes will be intersected. Then, the operator passes
this information sideways to only scan those lists. In this case,
because there is a primary key filter on Noura, the only <code>ab</code> tuple that will be read
is (a=1,b=0). This is stored in a temporary buffer that we call "Factorized Table" in the system.</li><li>Step 2 - Build Phase 1: In the first build step, Multway HashJoin will pass a nodeID filter
to the <code>Scan Follows (a)&lt;-(c)</code> operator with only 1=true for node ID 1, and 0 for every other node ID.
The operator can do this because at this stage the operator knows exactly which backward
adjacency lists will be needed when we extend the tuple (in this case only node with ID 1's
backward list is needed). The Scan operator uses this node ID filter to scan only this backward list,
{1001}, and avoids
scanning the rest of the file that stores the backwards Follows edges. This list is first sorted
based on the IDs of the neighbor IDs and stored in a hash table, denoted as "Hash Table (a)&lt;-(c)"
in the figure.</li><li>Step 3 - Build Phase 2: This is similar to Build phase 1. Using a semijoin filter
with node 0's ID, we scan only node 2's forward <code>Follows</code> list {1001, 1002, ..., 2000},
sort it, and then store in a hash table "Hash Table (b)-&gt;(c)".</li><li>Step 4 - Probe: We re-scan the accumulated <code>ab</code> tuples from the factorized table.
For each tuple, we first probe "Hash Table (a)&lt;-(c)"
and then "Hash Table (b)-&gt;(c)" to fetch two lists, intersect them, and produce outputs.
In this case there is only one tuple (a=1, b=0), so we will fetch a=1's backward list and b=0's forward list,
intersect these lists, and produce the triangle (a=1, b=0, c=1001).</li></ul><p>This performs quite well. Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a> has some performance numbers
comparing against other types of WCO joins implementations (see the experiments in Table 3). Since I did not cover other ways to implement
wco join algorithms inside DBMSs, these experiments would be difficult to explain here.
Instead, let me just demonstrate some simple comparisons between using binary joins and wco joins
in KÃ¹zu on a simple triangle query. On larger cyclic queries, e.g., 4- or 5- cliques,
the differences are much larger and often binary join plans do not finish on time.
You can try this experiment too. </p><p>Here is the configuration. The dataset I'm using
is a popular web graph that is used in academic papers called <a href="https://snap.stanford.edu/data/web-BerkStan.html" target="_blank" rel="noopener noreferrer">web-BerkStan</a>.
It has 685K nodes and 7.6M edges.
I modeled these as a simple <code>Page</code> nodes and <code>Links</code> edges.</p><p>I start KÃ¹zu on my own laptop, which is a Macbook Air 2020 with Apple M1 chip, 16G memory,
and 512GB SSD, and run the following two queries (by default, KÃ¹zu uses all thread available, which is 8 in this case):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Q1: KÃ¹zu-WCO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Page)-[e1:Links]-&gt;(b:Page)-[e2:Links]-&gt;(c:Page)-[e3:Links]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This will compile plan that uses a wco Multiway HashJoin operator. I will refer to this
plan as KÃ¹zu-WCO below. I am also running the following query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Q2: KÃ¹zu-BJ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Page)-[e1:Links]-&gt;(b:Page)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WITH *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (b:Page)-[e2:Links]-&gt;(c:Page)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WIH *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (c)-[e3:Links]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Currently KÃ¹zu compiles each MATCH/WITH block separately so this is hack to force the system
to use binary join plan. The plan will join <code>e1</code> <code>Links</code> with <code>e2</code> <code>Links</code> and then
join the result of that with <code>e3</code> <code>Links</code>, all using binary HashJoin operator. I will
refer to this as KÃ¹zu-BJ. Here are the results:</p><table><thead><tr><th>Configuration</th><th align="center">Time</th></tr></thead><tbody><tr><td>KÃ¹zu-WCO</td><td align="center">1.62s</td></tr><tr><td>KÃ¹zu-BJ</td><td align="center">51.17s</td></tr></tbody></table><p>There are ~41M triangles in the output. We see <strong>31.6x</strong> performance improvement in this simple query.
In larger densely cyclic queries, binary join plans just don't work.</p><p>To try this locally, you can download our prepared CSV files from <a href="https://github.com/kuzudb/kuzudb.github.io/tree/main/data/web-berkstan" target="_blank" rel="noopener noreferrer">here</a>, and compile from our <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">latest master</a><sup id="fnref-2-627daf"><a href="#fn-2-627daf" class="footnote-ref">2</a></sup> (<code>make clean &amp;&amp; make release NUM_THREADS=8</code>).
Then start KÃ¹zu's shell, and load data into KÃ¹zu:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./build/release/tools/shell/kuzu_shell -i web.db</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; CREATE NODE TABLE Page (id INT64, PRIMARY KEY(INT64));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; CREATE REL TABLE Links (FROM Page TO Page, MANY_MANY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; COPY Page FROM 'web-node.csv';</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; COPY Links FROM 'web-edge.csv';</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, run those two queries (KÃ¹zu-WCO and KÃ¹zu-BJ) to see the difference!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">A Thank You &amp; an Anecdote About Knuth's Reaction to the Term "Worst-case Optimal"<a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal" class="hash-link" aria-label="Direct link to A Thank You &amp; an Anecdote About Knuth's Reaction to the Term &quot;Worst-case Optimal&quot;" title="Direct link to A Thank You &amp; an Anecdote About Knuth's Reaction to the Term &quot;Worst-case Optimal&quot;">â€‹</a></h2><p>Before wrapping up, I want to say thank you to <a href="https://cs.stanford.edu/~chrismre/" target="_blank" rel="noopener noreferrer">Chris RÃ©</a>, who is a
co-inventor of earliest wcoj algorithms.
In the 5th year of my PhD, Chris had introduced me to this area and
we had written a paper together on the topic in the context of evaluating
joins in distributed systems, such as MapReduce and Spark. I ended up working on
these algorithms and trying to make them performant in actual systems
for many more years than I initially predicted.
I also want to say thank you to <a href="https://hung-q-ngo.github.io/" target="_blank" rel="noopener noreferrer">Hung Ngo</a> and <a href="https://cse.buffalo.edu/faculty/atri/" target="_blank" rel="noopener noreferrer">Atri Rudra</a>,
with whom I have had several conversations during those years on these algorithms.</p><p>Finally, let me end with a fun story about the term "worst-case optimal":
Several years ago <a href="https://uwaterloo.ca/computer-science/events/dls-donald-knuth-all-questions-answered" target="_blank" rel="noopener noreferrer">Don Knuth</a> was visiting UWaterloo
to give a Distinguished Lecture Seminar, which is our department's most prestigious
lecture series. A colleague of mine and I had a 1-1 meeting with him.
Knuth must be known to anyone with a CS degree but importantly he is
credited for founding the field of algorithm analysis (e.g., for popularizing
the big-oh notation for analyzing algorithms' performances).
In our meeting, he asked me what I was working on
and I told him about these new algorithms called "worst-case optimal join algorithms".
The term was so confusing to him and his immediate interpretation
was: "Are they so good that they are optimal even in their worst-case performances?" </p><p>The term actually means that the worst-case runtime of these algorithms
meets a known lower bound for the worst-case runtime of any join algorithm,
which is  <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î©</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><msup><mi>Ï</mi><mo>âˆ—</mo></msup></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(IN^{\rho^*})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1473em;vertical-align:-0.25em"></span><span class="mord">Î©</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8973em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Ï</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.
Probably a more standard term would be to call them
"asymptotically optimal", just like people call sort merge an asymptotically optimal
sorting algorithm under the comparison model.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-words">Final Words<a href="#final-words" class="hash-link" aria-label="Direct link to Final Words" title="Direct link to Final Words">â€‹</a></h2><p>What other fundamental algorithmic developments have
been made in the field on join processing? It is surprising but there are still main gaps
in the field's understanding of how fast joins can be processed.
There has been some very interesting
work in an area called <em>beyond worst-case optimal join algorithms</em>. These papers
ask very fundamental questions about joins, such as how can we prove that a join algorithm
is correct, i.e., it produces the correct output given its input?
The high-level answer is that each join algorithm must be producing a proof that its output is correct,
through the comparison operations it makes.
The goal of this line of research is to design practical algorithms whose implicit proofs are optimal,
i.e., as small as possible. This is
probably the most ambitious level of optimality one can go for in algorithm design.
There are already some algorithms, e.g., an algorithm called <a href="https://dl.acm.org/doi/pdf/10.1145/2967101" target="_blank" rel="noopener noreferrer">Tetris</a>. The area
is fascinating and has deep connections to computational geometry. I
advised a <a href="https://arxiv.org/abs/1909.12102" target="_blank" rel="noopener noreferrer">Master's thesis</a> on the topic once and learned quite a bit about
computational geometry that I never thought could be relevant to my work. The current
beyond worst-case optimal join algorithms however are currently not practical.
Some brave souls need to get into the space and think hard about whether
practical versions of these algorithms can be developed. That would be very exciting.</p><p>This completes my 3-part blog on the contents of our CIDR paper and 2 core techniques:
<a href="/docusaurus/blog/factorization">factorization</a> and worst-case optimal join algorithms that we have integrated into
KÃ¹zu to optimize for many-to-many joins. My goal in these blog
posts was to explain these ideas to a general CS/software engineering audience and
I hope these posts have made this material more approachable. My other goal
was to show the role of theory in advancing systems. Both of these ideas emerged from
pen-and-paper theory papers that theoreticians wrote but gave clear advice to DBMS developers.
As I said many times, I'm convinced that among many other techniques, these two
techniques need to be integral to any GDBMS that wants to be competitive in performance,
because queries with many-to-many joins are first-class-citizens in the workloads of these systems.</p><p>We will keep writing more blog posts in the later months about our new releases,
and other technical topics. If there are things you'd like us to write about,
please reach out to us! Also please give KÃ¹zu a try, prototype applications with it,
break it, let us know of your performance or other bugs, so we can continue improving
it. Give us a <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">GitHub star</a> too and take care until the next posts!</p><div class="footnotes"><hr><ol><li id="fn-1-627daf">The question is interesting in the set semantics when you cannot pick every column value of every tuple the same value, which forces a Cartesian product of all the relations.<a href="#fnref-1-627daf" class="footnote-backref">â†©</a></li><li id="fn-2-627daf">We found a minor bug in the latest release 0.0.2 when a node has a very large number of edges, which is fixed in the master branch, that's why we suggest using the master branch.<a href="#fnref-2-627daf" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>Semih SalihoÄŸlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="internals" term="internals"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[KÃ¹zu 0.0.2 Release]]></title>
        <id>https://kuzudb.com/docusaurus/blog/kuzu-0.0.2-release</id>
        <link href="https://kuzudb.com/docusaurus/blog/kuzu-0.0.2-release"/>
        <updated>2023-02-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This post is about the second release of KÃ¹zu. However, we want to start with something much more important:]]></summary>
        <content type="html"><![CDATA[<p>This post is about the second release of KÃ¹zu. However, we want to start with something much more important:</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="donate-to-the-victims-of-tÃ¼rkiye-syria-earthquake">Donate to the Victims of <a href="https://www.bbc.com/news/world-middle-east-64590946" target="_blank" rel="noopener noreferrer">TÃ¼rkiye-Syria Earthquake</a>:<a href="#donate-to-the-victims-of-tÃ¼rkiye-syria-earthquake" class="hash-link" aria-label="Direct link to donate-to-the-victims-of-tÃ¼rkiye-syria-earthquake" title="Direct link to donate-to-the-victims-of-tÃ¼rkiye-syria-earthquake">â€‹</a></h3><p>Our hearts, thoughts, and prayers go to all the victims, those who survived and those who passed,
in Syria and TÃ¼rkiye.
There will be a very difficult winter for all those who survived so everyone needs to help.
Here are two pointers for trustworthy organizations we know of that are trying to help
victims on the ground. For TÃ¼rkiye (where Semih is from), you can donate to <a href="https://ahbap.org/bagis-kategorisi/5" target="_blank" rel="noopener noreferrer">Ahbap</a>
(Please be aware that <strong>the donation currency is in TL</strong> and 14 TL = 1 CAD; 19TL = 1 USD); and for Syria
you can donate to the <a href="https://www.whitehelmets.org/en/" target="_blank" rel="noopener noreferrer">White Helmets</a>. Be generous! We'll leave pointers to several
other organizations below in this footnote<sup id="fnref-1-4af10a"><a href="#fn-1-4af10a" class="footnote-ref">1</a></sup>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview-of-kÃ¹zu-002">Overview of KÃ¹zu 0.0.2<a href="#overview-of-kÃ¹zu-002" class="hash-link" aria-label="Direct link to Overview of KÃ¹zu 0.0.2" title="Direct link to Overview of KÃ¹zu 0.0.2">â€‹</a></h2><p>Back to our release. KÃ¹zu codebase is changing fast but this release still has a focus: we
have worked quite hard since the last release to integrate KÃ¹zu to import data from
different formats and export data to different formats. There are also several important
features in the new Cypher clauses and queries we support,  additional string
processing capabilities, and new DDL statement support. We will give a summary of each
of these below.</p><p>For installing the new version, please visit the <a href="https://kuzudb.com/docs/getting-started.html" target="_blank" rel="noopener noreferrer">installation guide</a> and
the full
<a href="https://github.com/kuzudb/kuzu/releases" target="_blank" rel="noopener noreferrer">release notes are here</a>. If you are eager to play with
a few Colab notebooks, here are several links: </p><ul><li><a href="https://colab.research.google.com/drive/15OLPggnRSBmR_K9yzq6iAGE5MDzNwqoN" target="_blank" rel="noopener noreferrer">General KÃ¹zu Demo</a></li><li><a href="https://colab.research.google.com/drive/1fzcwBwTY-M19p7OOTIaynfgHFcAQo9NK" target="_blank" rel="noopener noreferrer">Export Query Results to Pytorch Geometric: Node Property Prediction Example</a></li><li><a href="https://colab.research.google.com/drive/1QdX7CDdajIAb04lqaO5PfJlpKG-ljG28" target="_blank" rel="noopener noreferrer">Export Query Results to Pytorch Geometric: Link Prediction Example</a></li><li><a href="https://colab.research.google.com/drive/1NDsnFDWcSGoaOl-mOgG0zrPG2VAr8Q6H" target="_blank" rel="noopener noreferrer">Export Query Results to NetworkX</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="exporting-query-results-to-pytorch-geometric-and-networkx">Exporting Query Results to Pytorch Geometric and NetworkX<a href="#exporting-query-results-to-pytorch-geometric-and-networkx" class="hash-link" aria-label="Direct link to Exporting Query Results to Pytorch Geometric and NetworkX" title="Direct link to Exporting Query Results to Pytorch Geometric and NetworkX">â€‹</a></h2><p>Perhaps most excitingly, we have added the first capabilities to integrate with 2 popular
graph data science
libraries: (i) <a href="https://github.com/pyg-team/pytorch_geometric" target="_blank" rel="noopener noreferrer">Pytorch Geometric</a> (PyG) for performing
graph machine learning; and (ii) <a href="https://networkx.org/" target="_blank" rel="noopener noreferrer">NetworkX</a> for a variety of
graph analytics, including visualization. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pytorch-geometric-queryresultget_as_torch_geometric-function">Pytorch Geometric: <code>QueryResult.get_as_torch_geometric()</code> function<a href="#pytorch-geometric-queryresultget_as_torch_geometric-function" class="hash-link" aria-label="Direct link to pytorch-geometric-queryresultget_as_torch_geometric-function" title="Direct link to pytorch-geometric-queryresultget_as_torch_geometric-function">â€‹</a></h3><p>Our <a href="https://kuzudb.com/api-docs/python/" target="_blank" rel="noopener noreferrer">Python API</a> now has a
new <a href="https://kuzudb.com/api-docs/python/kuzu/query_result.html#QueryResult.get_as_torch_geometric" target="_blank" rel="noopener noreferrer"><code>QueryResult.get_as_torch_geometric()</code></a> function that
converts results of queries to PyG's in-memory graph representation
<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html" target="_blank" rel="noopener noreferrer"><code>torch_geometric.data</code></a>.
If your query results contains nodes and relationship objects, then the function uses
those nodes and relationships to construct either <code>torch_geometric.data.Data</code> or
<code>torch_geometric.data.HeteroData</code> objects. The function also auto-converts any numeric or boolean property
on the nodes into tensors on the nodes that can be used as features in the <code>Data/HeteroData</code> objects.
Any property that cannot be auto-converted and the edge properties are also returned in case you need
want to manually put them into the <code>Data/HeteroData</code> objects.</p><p><strong>Colab Demonstrations:</strong>
Here are 2 Colab notebooks that you can play around with to see how you can develop graph learning
pipelines using KÃ¹zu as your GDBMSs:</p><ol><li><a href="https://colab.research.google.com/drive/1fzcwBwTY-M19p7OOTIaynfgHFcAQo9NK" target="_blank" rel="noopener noreferrer">Node property prediction</a></li><li><a href="https://colab.research.google.com/drive/1QdX7CDdajIAb04lqaO5PfJlpKG-ljG28" target="_blank" rel="noopener noreferrer">Link prediction</a></li></ol><p>The examples demonstrate how to extract a subgraph,
train graph convolutional or neural networks (GCNs or GNNs), make some node property
or link predictions and save them back in KÃ¹zu so you can query these predictions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="networkx-queryresultget_as_networkx-function">NetworkX: <code>QueryResult.get_as_networkx()</code> function<a href="#networkx-queryresultget_as_networkx-function" class="hash-link" aria-label="Direct link to networkx-queryresultget_as_networkx-function" title="Direct link to networkx-queryresultget_as_networkx-function">â€‹</a></h3><p>Our <a href="https://kuzudb.com/docs/client-apis/python-api/overview.html" target="_blank" rel="noopener noreferrer">Python API</a> now has a
new <a href="https://kuzudb.com/api-docs/python/kuzu/query_result.html#QueryResult.get_as_networkx" target="_blank" rel="noopener noreferrer"><code>QueryResult.get_as_networkx()</code></a> function that can convert query results
that contain nodes and relationships into NetworkX directed or undirected graphs. Using this function, you can build pipelines
that benefits from KÃ¹zu's DBMS functionalities (e.g., querying, data extraction and transformations,
using a high-level query language with very fast performance), and NetworkX's rich library of
graph analytics algorithms.</p><p><strong>Colab Demonstration:</strong>
Here is a <a href="https://colab.research.google.com/drive/1NDsnFDWcSGoaOl-mOgG0zrPG2VAr8Q6H?usp=sharing#scrollTo=AkpBul7ZpUM5" target="_blank" rel="noopener noreferrer">Colab notebook</a>
that you can play around with that shows how to do basic graph visualization of query results
and build a pipeline that computes PageRanks of a subgraph and store those PageRank
values back as new node properties in KÃ¹zu and query them.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-import-from-and-export-to-parquet-and-arrow">Data Import from and Export to Parquet and Arrow<a href="#data-import-from-and-export-to-parquet-and-arrow" class="hash-link" aria-label="Direct link to Data Import from and Export to Parquet and Arrow" title="Direct link to Data Import from and Export to Parquet and Arrow">â€‹</a></h2><p>We have removed our own CSV reader and instead now use <a href="https://arrow.apache.org/" target="_blank" rel="noopener noreferrer">Arrow</a>
as our default library when bulk importing data through <a href="https://kuzudb.com/docs/data-import/csv-import.html" target="_blank" rel="noopener noreferrer"><code>COPY FROM</code> statements</a>.
Using Arrow, we can not only bulk import
from CSV files but also from arrow IPC and parquet files. We detect the file type
from the suffix of the file; so if the query says <code>COPY user FROM ./user.parquet</code>,
we infer that this is a parquet file and parse it so. See the details <a href="/docusaurus/data-import/parquet-import">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="multi-labeled-or-unlabeled-queries">Multi-labeled or Unlabeled Queries<a href="#multi-labeled-or-unlabeled-queries" class="hash-link" aria-label="Direct link to Multi-labeled or Unlabeled Queries" title="Direct link to Multi-labeled or Unlabeled Queries">â€‹</a></h2><p>A very useful feature of the query languages of GDBMSs is their
ability to elegantly express unions of join queries.
We had written about this feature of GDBMSs in this blog post about
<a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">What Every Competent GDBMS Should Do</a>
(see the last paragraph of Section <code>Feature 4: Schema Querying</code>).
In Cypher, a good example
of this is to not bind the node and relationship variables to a specific node/relationship
labels/tables. Consider this query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[e]-&gt;(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Karissa'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a, e, b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This query asks for all types of relationships that Karissa can have to any possible other
node (not necessarily of label <code>User</code>) in the query. So if the database contains
<code>Likes</code> relationships from <code>Users</code> to <code>Comments</code>, <code>Follows</code> relationships
from <code>Users</code> to <code>Users</code>, and <code>LivesIn</code> relationships from <code>Users</code> and <code>Cities</code>,
variables e and b can bind to records from all of these
relationship and node labels, respectively. </p><p>You can also restrict the labels of nodes/rels to a fixed set that contains
more than one label using the <code>|</code> syntax.
For example you can do:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[e:Likes|Follows]-&gt;(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Karissa'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a, e, b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This forces e to match to only Likes relationship or Follows relationship records (so
excludes the <code>LivesIn</code> records we mentioned above). The <code>|</code> is a syntax adapted from
regexes originally and is also used in query languages that support <code>regular path queries</code>. </p><p>KÃ¹zu now supports such queries. Our query execution
is based on performing scans of each possible node/rel table and index
and when a variable <code>x</code> can bind to multiple node/rel tables, <code>L1, L2, ..., Lk</code>,
we reserve one vector for each possible property of each node/rel table.<br>
<!-- -->If anyone has any optimizations to do something smarter, it would be very interesting
to hear!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="other-important-changes">Other Important Changes<a href="#other-important-changes" class="hash-link" aria-label="Direct link to Other Important Changes" title="Direct link to Other Important Changes">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="enhanced-string-features">Enhanced String Features<a href="#enhanced-string-features" class="hash-link" aria-label="Direct link to Enhanced String Features" title="Direct link to Enhanced String Features">â€‹</a></h3><p>We've added two important features to enhance KÃ¹zu's ability to store and process strings:</p><p>1) Support of UTF-8 characters. With the help of <a href="https://github.com/JuliaStrings/utf8proc" target="_blank" rel="noopener noreferrer">utf8proc</a>, you can now store string node/relationship
properties in KÃ¹zu that has UTF-8 characters;
2) Support of <a href="/docusaurus/cypher/expressions/pattern-matching">regex pattern matching</a> with strings. KÃ¹zu now supports Cypher's <code>=~</code> operator for regex searches, which will return true if its pattern mathces the entire input string. For example: <code>RETURN 'abc' =~ '.*(b|d).*';</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="case-expression">CASE Expression<a href="#case-expression" class="hash-link" aria-label="Direct link to CASE Expression" title="Direct link to CASE Expression">â€‹</a></h3><p>We've added <a href="/docusaurus/cypher/expressions/case-expression">CASE</a> for conditional expressions.
Two forms (<a href="/docusaurus/cypher/expressions/case-expression#simple-form">Simple Form</a> and <a href="/docusaurus/cypher/expressions/case-expression#general-form">General Form</a>) of CASE expression are supported.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="alterdropsetdelete">ALTER/DROP/SET/DELETE<a href="#alterdropsetdelete" class="hash-link" aria-label="Direct link to ALTER/DROP/SET/DELETE" title="Direct link to ALTER/DROP/SET/DELETE">â€‹</a></h3><p>We added <a href="/docusaurus/cypher/data-definition/alter">ALTER TABLE</a> and <a href="/docusaurus/cypher/data-definition/drop">DROP TABLE</a> DDL statements.
After creating a new node or relationship table, you can now drop it, rename it, and alter it by adding new columns/properties,
renaming or dropping existing columns/properties.</p><p>Besides schema level changes, you can change properties of existing nodes/rels with <a href="/docusaurus/cypher/data-manipulation-clauses/set">SET</a> statements, and remove existing nodes/rels with <a href="/docusaurus/cypher/data-manipulation-clauses/delete">DELETE</a> statements.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="disable-relationships-with-multiple-source-or-destination-labels">Disable Relationships with Multiple Source or Destination Labels<a href="#disable-relationships-with-multiple-source-or-destination-labels" class="hash-link" aria-label="Direct link to Disable Relationships with Multiple Source or Destination Labels" title="Direct link to Disable Relationships with Multiple Source or Destination Labels">â€‹</a></h3><p>We now no longer support defining a relationship between multiple source or destination labels.
This is to simplify our storage. But please let us know if you have strong use cases on this.</p><p>Enjoy our new release and don't forget to donate to the earthquake victims.</p><div class="footnotes"><hr><ol><li id="fn-1-4af10a">For TÃ¼rkiye two other organizations are <a href="https://en.afad.gov.tr/earthquake-campaign" target="_blank" rel="noopener noreferrer">AFAD</a>, which is the public institute for coordinating natural disaster response and <a href="https://www.akut.org.tr/en/donation" target="_blank" rel="noopener noreferrer">Akut</a>, a volunteer-based and highly organized search and rescue group. For Syria, another campaign I can recommend is <a href="https://molhamteam.com/en/campaigns/439?fbclid=IwAR3_t443XME9Gh0r75KM4VpQ58WLNPd8w8tyMV2JprdObwecPwhWAdX2FOQ" target="_blank" rel="noopener noreferrer">Molham Team</a>, which is an organization founded by Syrian refugee students.<a href="#fnref-1-4af10a" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Factorization & Great Ideas from Database Theory]]></title>
        <id>https://kuzudb.com/docusaurus/blog/factorization</id>
        <link href="https://kuzudb.com/docusaurus/blog/factorization"/>
        <updated>2023-01-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Many of the core principles of how to develop DBMSs are well understood.]]></summary>
        <content type="html"><![CDATA[<p>Many of the core principles of how to develop DBMSs are well understood.
For example, a very good query compilation paradigm is to
map high-level queries to a logical plan of relational operators, then optimize this plan,
and then further map it to an executable code often in the form of a physical query plan.
Similarly, if you want updates to a DBMS to be atomic and durable,
a good paradigm is to use a write-ahead log that serves as a source of truth
and can be used to undo or redo operations. Many systems adopt such common wisdom paradigms.
As core DBMS researcher, once in a while however, you run into a very simple idea
that deviates from the norm that gets you very excited.
Today, I want to write about one such idea called <a href="https://www.cs.ox.ac.uk/dan.olteanu/papers/os-sigrec16.pdf" target="_blank" rel="noopener noreferrer">factorization</a>. </p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>Overview of Factorization &amp; Why Every GDBMS Must Adopt It</strong>: Factorization
is a compression technique to compress the intermediate results
that query processors generate when evaluating many-to-many (m-n) joins.
Factorization can compress an intermediate result size exponentially
in the number m-n joins in the query.</li><li><strong>Example Benefits of Factorization</strong>: Benefits of keeping intermediate
results smaller reduces the computation processors perform
on many queries. Examples include reducing copies by keeping the output
data size small, reducing filter and expression evaluation computations exponentially,
and performing very fast aggregations.</li><li><strong>How KÃ¹zu Implements Factorization:</strong> KÃ¹zu's query processor
is designed to achieve 3 design goals: (i) factorize intermediate results;
(ii) always perform sequential scans of database files; and (iii) avoid
scanning large chunks of database files when possible. In addition, the processor is
vectorized as in modern columnar DBMSs. These design goals are achieved by passing
multiple <em>factorized vectors</em> between each other and using modified HashJoin operators
that do <em>sideways information passing</em> to avoid scans of entire files.</li></ul></div></div><p>This is a quite technical and long blog post and will appeal more to people who are interested
in internals of DBMSs. It's about a technique that's quite dear to my heart called factorization,
which is a very
simple data compression technique. Probably all
compression techniques you know are designed to compress database files that
are stored on disk. Think of run-length encoding, dictionary compression, or bitpacking.
In contrast, you can't use factorization to compress your raw database files.
Factorization has a very unique property:
it is designed to compress the intermediate
data that are generated when query processors of DBMSs evaluate
many-to-many (m-n) growing joins. If you have read <a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">my previous blog</a>,
efficiently handling m-n joins was one of the items on my list of properties
that competent GDBMSs should excel in. This is because
the workloads of GDBMSs commonly contain m-n joins
across node records. Each user in a social network or an account in a financial transaction network
or will have thousands of connections and if you want
a GDBMS to find patterns on your graphs, you are
asking queries with m-n joins. Factorization is directly designed
for these workloads and because of that every competent GDBMS must develop
a factorized query processor. In fact, if I were to try to write a new analytical RDBMS,
I would probably also integrate factorization into it.</p><p>This post forms the 2nd part of my 3-part posts on the contents of our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>
where we introduced KÃ¹zu. The 3rd piece will be on another technique called worst-case
optimal join algorithms, which is also designed for a specific class of m-n joins.
Both in this post and the next, I have two goals. First is to try to articulate these techniques
using a language that is accessible to general software engineers.
Second, is to make people appreciate the role of
pen-and-paper theory in advancing the field of DBMSs. Both of these techniques were first
articulated in a series of purely theoretical papers which gave excellent
practical advice on how to improve DBMS performance.
Credit goes to the great theoreticians who pioneered these techniques whom I will cite
in these posts. Their work should be highly appreciated.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-quick-background-traditional-query-processing-using-flat-tuples">A Quick Background: Traditional Query Processing Using Flat Tuples<a href="#a-quick-background-traditional-query-processing-using-flat-tuples" class="hash-link" aria-label="Direct link to A Quick Background: Traditional Query Processing Using Flat Tuples" title="Direct link to A Quick Background: Traditional Query Processing Using Flat Tuples">â€‹</a></h2><p>Here is a short background on the basics of
query processors before I explain factorization. If you know about
query plans and how to interpret them,
you can skip to <a href="#factorization-in-a-nutshell">here</a> after reading
my running example.
Consider a database of Account node and Transfer edge records below.
The two Accounts with <code>accID</code> fields L1 and L2 are owned by Liz and
each have 100 incoming and 100 outgoing Transfer edges.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/2-hop-data-50098805289935a1f613617907dcb303.png" width="600" class="img_ev3q"></div><p>Now consider a 2-hop path query in Cypher returning the accID's of source
and destinations of money flows Liz's accounts are facilitating:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[t1:Transfer]-&gt;(b:Account)-[t2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = 'Liz' </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.accID, c.accID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here's the SQL version of the query if you modeled your records as relations.
Same query different syntax:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT a.accID, c.accID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM Account a, Transfer t1, Account b, Transfer t2, Account c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = 'Liz' AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      t1.src = a.accID AND t1.dst = b.accID AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      t2.src = b.accID AND t2.dst = c.accID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A standard query plan for this query is shown on the left in Fig. 2.
The plan contains some Scan operators to scan the raw node or edge records (edges could be
scanned from a join index) and some hash join operators to perform the joins, and
a final projection operator.
In some GDBMSs, you might see "linear plans" that look as in Fig. 3.</p><p><span><img loading="lazy" src="/docusaurus/assets/images/2-hop-query-plan-hash-join-1749ba183a543df750077e115557b565.png" style="width:50%" class="img_ev3q"></span><span><img loading="lazy" src="/docusaurus/assets/images/2-hop-query-plan-extend-4e1220b8e7fda83e9f20c611b4afb028.png" style="width:50%" class="img_ev3q"></span></p><p>The linear plan is from our previous GraphflowDB system. Here
you are seeing an operator called Extend, which joins node records with their Transfer relationships to
read the system-level IDs of the neighbors of those node records.
Following the Extend is another Join operator to join the accID properties of those neighbors
(specifically c.accID and a.accID).
In Neo4j, you'll instead see an Expand(All) operator, which does the Extend+Join
in GraphflowDB in a single operator<sup id="fnref-1-10fd85"><a href="#fn-1-10fd85" class="footnote-ref">1</a></sup>. For very good reasons
we removed these Extend/Expand type operators in KÃ¹zu. I will come back to this.</p><p>The interpretation of plans is that tuples are flowing from the bottom to top and
each operator will take in sets of tuples and produce sets of tuples (in a pipelined fashion).
The key motivation for factorization is that what flows
between operators are <strong>flat tuples</strong>. When the joins are m-n, this
leads to many data repetitions, which one way or another leads to repeated
computation in the operators. For example,
the final projection operator in our example would take the table shown in Figure 4 (left).</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/flat-vs-factorized-4a4ea855b7bda3921e29e9d05a2157f8.png" width="700" class="img_ev3q"></div><p>There are 20K tuples in the flat representation because both L1 and L2 are part of
100 incoming x 100 outgoing=10K many 2-paths. Notice the many repetitions in this relation:
L1, L2, or Liz values, or the values in a.accID and c.accID.
What gets replicated may change across systems. Some may replicate the actual values,
some may replicate indices where these values are stored but overall exactly 20K
tuples would be generated. This redundancy leads to redundant computation here and there
during query processing.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="factorization-in-a-nutshell">Factorization In a Nutshell<a href="#factorization-in-a-nutshell" class="hash-link" aria-label="Direct link to Factorization In a Nutshell" title="Direct link to Factorization In a Nutshell">â€‹</a></h2><p>Factorization addresses exactly this problem. The core reason for the redundancy
is this observation: <em>given a fixed b value, all a's and c's are conditionally independent</em>.
More concretely, once b is bound to node L1, each incoming neighbor <code>a</code> for L1 will join
with each outgoing neighbor <code>c</code> of L1. If you took the first standard undergraduate course in DBMSs at a university
and you covered the theory of normalization, this is what is
called a <a href="https://en.wikipedia.org/wiki/Multivalued_dependency" target="_blank" rel="noopener noreferrer">multi-valued dependency</a>
in relations. Factorization exploits such dependencies to compress
relations using Cartesian products.
Above in Figure 4 (right),
I'm showing the same 20K tuples in a factorized format using only 400 values
(so 2<!-- -->*<!-- -->(100+100) instead of 2<!-- -->*<!-- -->100<!-- -->*<!-- -->100 values). </p><p>That's it! That's the core of the idea! Now of course, this simple observation leads to a ton of
hard and non-obvious questions that the entire theory on factorization answers. For example,
given a query, what are the "factorization structures", i.e., the Cartesian product structures
that can be used to compress it? Consider a simple query that counts the number of
paths that are slightly longer:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Wire]-&gt;(b:Account)-[:Deposit]&gt;(c:Account)-[:ETransfer]-&gt;(d:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Should you condition on b and factor out
a's from (c, d)'s or condition on c and factor out (a, b)'s from d's?
Or you could condition on (b, c) and factor out (a)'s from (d)'s?
To make a choice, a system has to reason about the number of Wire, Deposit,
and ETransfer records in the database.
How much and on which queries can you benefit from factorization?
The theoretical questions are endless.
The theory of factorization develops the formal foundation so that such questions can be answered and
provides principled first answers to these questions.
<a href="https://www.ifi.uzh.ch/en/dast/people/Olteanu.html" target="_blank" rel="noopener noreferrer">Dan Olteanu</a> and his
colleagues, who lead this field, recently won the <a href="https://databasetheory.org/ICDT/test-of-time" target="_blank" rel="noopener noreferrer">ICDT test of time award</a>
for their work on factorization. ICDT is one of the two main
academic venues for theoretical work on DBMSs.</p><p>But let's take a step back and appreciate this theory because it gives an excellent
advice to system developers: <em>factorize your intermediate
results if your queries contain many-to-many joins!</em>
Recall that GDBMSs most commonly evaluate many-to-many joins. So hence my point that
GDBMSs should develop factorized query processors.
The great thing this theory shows us is that this can all be done by static analysis of the query
during compilation time by only inspecting the dependencies between variables in
the query! I won't cover the exact rules but at least in my running example,
I hope it's clear that because there is no predicate between a's and c's, once
b is fixed, we can factor out a's from c's.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="examples-when-factorization-significantly-benefits">Examples When Factorization Significantly Benefits:<a href="#examples-when-factorization-significantly-benefits" class="hash-link" aria-label="Direct link to Examples When Factorization Significantly Benefits:" title="Direct link to Examples When Factorization Significantly Benefits:">â€‹</a></h2><p>Factorized intermediate relations can be exponentially smaller
(in terms of the number of joins in the query)
than their flat versions, which
can yield orders of magnitude speed ups in query performance
for many different reasons. I will discuss three most obvious ones.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="less-data-copiesmovement">Less Data Copies/Movement<a href="#less-data-copiesmovement" class="hash-link" aria-label="Direct link to Less Data Copies/Movement" title="Direct link to Less Data Copies/Movement">â€‹</a></h3><p>The most obvious benefit is that factorization reduces
the amount of data copied between buffers used by operators
during processing and to final <code>QueryResult</code> structure
that the application gets access to. For example, a very cool feature of KÃ¹zu
is that it keeps final outputs in factorized format in its <code>QueryResult</code> class and
enumerates them one by one only when the user starts calling <code>QueryResult::getNext()</code>
to read the tuples.
In our running example, throughout processing KÃ¹zu would do copies of
400 data values roughly instead of 20K to produce its <code>QueryResult</code>.
Needless to say, I could have picked a more exaggerated query, say a "star" query
with 6 relationships, and arbitrarily increased the difference in the copies done
between a flat vs factorized processor.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fewer-predicate-and-expression-evaluations">Fewer Predicate and Expression Evaluations<a href="#fewer-predicate-and-expression-evaluations" class="hash-link" aria-label="Direct link to Fewer Predicate and Expression Evaluations" title="Direct link to Fewer Predicate and Expression Evaluations">â€‹</a></h3><p>Factorization can also reduce the amount of predicate or expression executions the system performs.
Suppose we modify our 2-hop query a bit and put two additional filters on the query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1:Transfer]-&gt;(b:Account)-[e2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = 'Liz' AND a.balance &gt; b.balance AND c.balance &gt; b.balance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>I'm omitting a plan for this query but a common plan would extend the plan in Figure 2 (or 3) above
to also scan the balance properties and to run two filter operations:
(i) above the join that joins a's and b's,
to run the predicate <code>a.balance &gt; b.balance</code>; (ii) after the final join in Figure 2
to run the predicate <code>c.balance &gt; b.balance</code>. Suppose the first filter did not eliminate any tuples.
Then, a flat processor would evaluate 20K filter executions in the second filter.
In contrast, the input to the second filter operator in a factorized processor
would be the 2 factorized tuples
shown in Figure 4 (right) but extended with <code>balance</code> properties
on a, b, and c's. Therefore there would be only 200 filter executions: (i)
for the first factorized tuple, there are only
100 comparisons to execute <code>c.balance &gt; b.balance</code> since b is matched to a single
value and there are 100 c values.; (ii) similarly for the 2nd factorized tuple.
We can obtain similar benefits when running other expressions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="aggregations">Aggregations<a href="#aggregations" class="hash-link" aria-label="Direct link to Aggregations" title="Direct link to Aggregations">â€‹</a></h3><p>This is perhaps where factorization yields largest benefits.
One can perform several aggregations directly on factorized tuples using
algebraic properties of several aggregation functions. Let's
for instance modify our above query to a count(<!-- -->*<!-- -->) query: Find the number of 2-paths that Liz is
facilitating. A factorized processor can simply count that there are 100<!-- -->*<!-- -->100 flat tuples in the first
factorized tuple and similarly in the second one to compute that the answer is 20K.
Or consider doing min/max aggregation on factorized variables:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1:Transfer]-&gt;(b:Account)-[e2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.accID = 'L1'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN max(a.balance), min(c.balance)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is asking: find the 2-path money flow that Liz's L1 account facilitates from the highest
to lowest balance accounts (and only print the balances). If a processor
processes the 10K 2-paths that L1 is part of in factorized form, then
the processor can  compute the max and min aggregations
with only 100 comparisons each (instead of 10K comparisons each). </p><p>In short, the benefits of factorizing intermediate results just
reduces computation and data copies here and there in many cases.
You can try some of these queries on KÃ¹zu and compare its performance on large
datasets with non-factorized systems. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-does-kÃ¹zu-perform-factorized-query-processing">How Does KÃ¹zu Perform Factorized Query Processing?<a href="#how-does-kÃ¹zu-perform-factorized-query-processing" class="hash-link" aria-label="Direct link to How Does KÃ¹zu Perform Factorized Query Processing?" title="Direct link to How Does KÃ¹zu Perform Factorized Query Processing?">â€‹</a></h2><p>The rest will be even more technical and forms part of the technical meat of our CIDR paper;
so continue reading if you are interested in database implementations.
When designing the query processor of KÃ¹zu, we had 3 design goals: </p><ol><li>Factorize intermediate growing join results. </li><li>Always perform sequential scans of database files from disk.</li><li>When possible avoid scanning entire database files from disk.</li></ol><p>3rd design goal requires some motivation, which I will provide below. Let's go one by one.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-factorization">1. Factorization<a href="#1-factorization" class="hash-link" aria-label="Direct link to 1. Factorization" title="Direct link to 1. Factorization">â€‹</a></h3><p>KÃ¹zu has a vectorized query processor, which is the common wisdom
in analytical read-optimized systems. </p><img loading="lazy" align="left" style="width:350px;padding-right:15px" src="/docusaurus/assets/images/factorized-vectors-fa0c388632af28cb8b3448fcdad3f8cf.png" class="img_ev3q">Vectorization, in the context of DBMS query processors refers to the design where operators pass a set of tuples, 1024 or 2048, between each other during processing[^2]. Existing vectorized query processors (in fact processors of all systems I'm aware of) pass *a single vector of flat tuples*. Instead, KÃ¹zu's operators pass (possibly) multiple *factorized vectors of tuples* between each other. Each vector  can either be *flat* and represent a single value or *unflat* and represent a set of values, which is marked in a field called `curIdx` associated with each vector. For example, the first 10K tuples from my running example would be represented with 3 factorized vectors as on the left and would be passed to the final projection in the query plan in Figure 2. The interpretation is this: what is passed is the Cartesian product of all sets of tuples in those vectors. Operators know during compilation time how many vector groups they will take in and how many they will output. Importantly, we still do vectorized processing, i.e., each primitive operator operates on a vector of values inside tight for loops. Credit where credit's due: this simple-to-implement design was proposed by my PhD student [Amine Mhedhbi](http://amine.io/) with some feedback from me and my ex-Master's student [Pranjal Gupta](https://www.linkedin.com/in/g31pranjal/?originalSubdomain=in) and [Xiyang Feng](https://www.linkedin.com/in/xingyang-feng-14198491/?originalSubdomain=ca), who is now a core developer of KÃ¹zu. And we directly adopted it in KÃ¹zu. Amine has continued doing other excellent work on factorization, which we have not yet integrated, and you will need to wait until his PhD thesis is out.<h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-ensuring-sequential-scans">2. Ensuring Sequential Scans<a href="#2-ensuring-sequential-scans" class="hash-link" aria-label="Direct link to 2. Ensuring Sequential Scans" title="Direct link to 2. Ensuring Sequential Scans">â€‹</a></h3><p>I already told you above that
Extend/Expand type join operators lead to non-sequential scans of database files.
These operators are not robust and if you are developing a disk-based system:
non-sequential scans will kill you on many queries. That's a mistake. Instead,
KÃ¹zu uses (modified) HashJoins which are much more robust. HashJoins do not perform any scans
as part of the actual join computation so if the down stream scans
are sequential, you get sequential scans. I'll give a simulation momentarily.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-avoiding-full-scans-of-database-files">3. Avoiding Full Scans of Database Files<a href="#3-avoiding-full-scans-of-database-files" class="hash-link" aria-label="Direct link to 3. Avoiding Full Scans of Database Files" title="Direct link to 3. Avoiding Full Scans of Database Files">â€‹</a></h3><p>Although I don't like Extend/Expand-type join operators,
they have a performance advantage. Suppose you had a simple 1-hop query that only asked for
the names of accounts that Liz's L1 account has transfered money to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.accID = 'L1'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b.name</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Suppose your database has billions of transfers but L1 has made only 3 transfers to
accounts with system-level record/node IDs: 107, 5, and 15. Then if you had
a linear plan like I showed in Figure 3, then an Extend/Expand-type
operator could read these system-level IDs and then only scan
the name properties of these 3 nodes, avoiding the full scan of the names
of all Accounts. If your query needs to read neighborhoods of millions of nodes,
this type of  computation that "reads the properties of each node's neighbors"
will degrade very quickly because: (i) each neighborhood
of each node will require reading
different parts of the disk files that store those properties; and (ii)
the system might repeatedly read the same properties over and over from disk,
as nodes share neighbors.
Instead, you want to
read all of the properties and create a hash table and read those properties
from memory.
However, if your query is accessing the neighborhoods of a few nodes,
then avoiding the scan of entire database file is an advantage.
In KÃ¹zu, we wanted to use HashJoins but we also wanted a mechanism to scan
only the necessary parts of database files. We
do this through a technique called <em>sideways information passing</em><sup id="fnref-3-10fd85"><a href="#fn-3-10fd85" class="footnote-ref">3</a></sup>.
I'll simulate this below.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-simple-simulation">A Simple Simulation<a href="#a-simple-simulation" class="hash-link" aria-label="Direct link to A Simple Simulation" title="Direct link to A Simple Simulation">â€‹</a></h3><p>For simplicity, we'll work on a simpler 1-hop query, so the benefits of factorization will not
be impressive but it will allow me to explain an entire query processing pipeline.
Consider this count(<!-- -->*<!-- -->) query that counts the number of transfers the L1 account has made:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[t1:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.accID = L1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An annotated query plan we generate is shown below. The figure shows step by step
the computation that will be performed and the data that will be passed between operators.
For this simulation, I am assuming that the record/nodeIDs of Accounts are as in
Figure 1a above.</p><img loading="lazy" align="left" style="width:500px;padding-right:15px" src="/docusaurus/assets/images/factorized-execution-simulation-1b0f9917e3eead4cf85e02818fd579db.png" class="img_ev3q"><ol><li>A Scan operator will scan the accId column and find the records of
nodes with accID=L1. There is only 1 tuple (199, Liz) that will be output.</li><li>This tuple will passed to HashJoin's build side, which will create a hash table from it.</li><li>At this point the processor knows exactly the IDs of nodes, whose Transfer edges need
to be scanned on the probe side: only the edges of node with ID 199! This is where we
do sideways information passing.
Specifically, the HashJoin constructs and passes a "nodeID filter" (effectively a bitmap)
to the probe side Scan operator. Here, I'm assuming the database has 1M Accounts but as you
can see only the position 199 is 1 and others are 0.</li><li>The probe-side Scan uses the filter to only scan
the edges of 199 and avoids
scanning the entire Transfers file.
Since KÃ¹zu is a GDBMS, we store the edges of nodes (and their properties)
in a graph-optimized format called <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)" target="_blank" rel="noopener noreferrer">CSR</a>.
Importantly, all of the edges of 199 are stored consecutively and we output them in factorized format as:
<!-- -->[(199) X {201, 202, ..., 300}]<!-- -->.</li><li>Next step can be skipped in an optimized system but currently we will probe the <!-- -->[(199) X {201, 202, ..., 300}]<!-- -->
tuple in the hash table and produce <!-- -->[(199, L1) X {201, 202, ..., 300}]<!-- -->, which is passed to the
final aggregation operator.</li><li>The agggregation operator counts that there are 100 "flat" tuples in <!-- -->[(199, L1) X {201, 202, ..., 300}]<!-- -->, simply
by inspecting the size of the 2nd vector {201, 202, ..., 300} in the tuple.</li></ol><p>As you see the processing was factorized, we only did sequential scans
but we also avoided scanning the entire Transfer database file, achieving our 3 design goals.
This is a simplifid example and there are many queries that are more complex and where we
have more advanced modified hash join operators. But the simulation presents all core techniques
in the system. You can read our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>
if you are curious about the details!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="example-experiment">Example Experiment<a href="#example-experiment" class="hash-link" aria-label="Direct link to Example Experiment" title="Direct link to Example Experiment">â€‹</a></h3><p>How does it all perform? Quite well! Specifically this type of processing is quite robust.
Here's an experiment from our CIDR paper to give a sense of the behavior of
using modified hash joins and factorization on a micro benchmark query. This query
does a 2-hop query with aggregations on every node variable. This is on
an <a href="https://ldbcouncil.org/benchmarks/snb/" target="_blank" rel="noopener noreferrer">LDBC</a>
social network benchmark (SNB) dataset at scale factor 100 (so ~100GB of database). LDBC SNB
models a social network where user post comments and react to these comments. </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Comment)&lt;-[:Likes]-(b:Person)-[:Likes]-&gt;(c:Comment)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.ID &lt; X</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN min(a.ID), min(b.ID), min(c.ID)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Needless to say, we are picking this as it is a simple query that can demonstrate
the benefits of all of the 3 techniques above. Also needless to say, we could have exaggerated
the benefits by picking
larger stars or branched tree patterns but this will do.
In the experiment we are changing the selectivity of the predicate on the middle node, which
changes the output size. What we will compare is the behavior of KÃ¹zu, which integrates
the 3 techniques above with (i) KÃ¹zu-Extend: A configuration of KÃ¹zu that uses factorization but instead of
our modified HashJoins uses an Extend-like operator;
and (ii) <a href="https://umbra-db.com/" target="_blank" rel="noopener noreferrer">Umbra</a><sup id="fnref-4-10fd85"><a href="#fn-4-10fd85" class="footnote-ref">4</a></sup>, which represents the
state of the art RDBMS. Umbra is as fast as existing RDBMSs get. It probably integrates
every known low-level performance technique in the field.
Umbra however does not
do factorization or have a mechanism to avoid scanning entire database files, so we
expect it to perform poorly on the above query. </p><p>Here's the performance table.</p><img loading="lazy" align="right" style="width:350px;padding-right:15px" src="/docusaurus/assets/images/2-hop-factorization-experiment-20c4be9f7a0f21358cd888fd15ba38a9.png" class="img_ev3q">When the selectivity is very low, Extend-like operators + factorization do quite well because they don't yet suffer much from non-sequential scans and they avoid several overheads of our modified hash joins: no hash table creation and no semijoin filter mask creation. But they are not robust and degrade quickly. We can also see that even if you're Umbra, without factorization or a mechanism to avoid scanning entire files, you will not perform very well on these queries with m-n joins (even if there is only 2 of them here). We conducted several other experiments all demonstrating the robustness and scalability of factorized processing using modified hash join operators. I won't cover them but they are all in [our CIDR paper](https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf).<h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-marks">Final marks:<a href="#final-marks" class="hash-link" aria-label="Direct link to Final marks:" title="Direct link to Final marks:">â€‹</a></h2><p>I am convinced that modern GDBMSs have to be factorized systems to remain
competitive in performance. If your system assumes that most joins will be growing,
factorization is one of a handful of modern technique for such workloads
whose principles are relatively well understood
and one can actually implement in a system. I am sure different factorized query processors will
be proposed as more people attempt at it. I was happy to see in CIDR that at least 2 systems
gurus told me they want to integrate factorization into their systems.
If someone proposes a technique that can on some queries
lead to exponential computation reductions even in a pen-and-paper theory, it is a good sign
that for many queries it can make the difference between a system timing out vs providing
an actual answer.</p><p>Finally  there is much more on the theory of factorization, which I did not cover. From my side,
most interestingly, there
are even more compressed ways to represent the intermediate results than the
vanilla Cartesian product scheme I covered in this post. Just to raise some curiosity, what I have
in mind is called
<a href="https://fdbresearch.github.io/principles.html" target="_blank" rel="noopener noreferrer">d-representations</a> but that will have to wait
for another time. For now, I invite you to check our performance out on large queries
and let us know if we are slow on some queries! The KÃ¹zu team says hi (ðŸ‘‹ ðŸ™‹â€â™€ï¸ ðŸ™‹ðŸ½) and
is at your service to fix all performance bugs as we continue implementing the system!
My next post will be about the novel <a href="/docusaurus/blog/wcoj">worst-case optimal join algorithms</a>, which emerged
from another theoretical insight on m-n joins! Take care until then!</p><div class="footnotes"><hr><ol><li id="fn-1-10fd85">If you come from a very graph-focused background and/or exposed to a ton of GDBMS marketing, you might react to my statement that what I am showing are standard plans that do joins. Maybe you expected to see graph-specific operators, such as a BFS or a DFS operator because the data is a graph. Or maybe someone even dared to tell you that GDBMSs don't do joins but they do traversals. Stuff like that. These word tricks and confusing jargon really has to stop and helps no one. If joins are in the nature of the computation  you are asking a DBMSs to do, calling it something else won't change the nature of the computation. Joins are joins. Every DBMSs needs to join their records with each other.<a href="#fnref-1-10fd85" class="footnote-backref">â†©</a></li><li id="fn-3-10fd85">Note that GDBMSs are able to avoid scans of entire files because notice that they do the join on internal record/node IDs, which mean something very specific. If a system needs to scan the name property of node with record/node ID 75, it can often arithmetically compute the disk page and offset where this is stored, because record IDs are dense, i.e., start from 0, 1, 2..., and so can serve as  pointers if the system's storage design exploits this. This is what I was referring to as "Predefined/pointer-based joins" in my <a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">previous blog post</a>. This is a good feature of GDBMSs that allows them to efficiently evaluate the joins of node records that are happening along the "predefined" edges in the database. I don't know of a mechanism where RDBMSs can do something similar, unless they develop a mechanism to convert value-based joins to pointer-based joins. See my student <a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf" target="_blank" rel="noopener noreferrer">Guodong's work last year in VLDB</a> of how this can be done. In KÃ¹zu, our sideways information passing technique follows Guodong's design in this work.<a href="#fnref-3-10fd85" class="footnote-backref">â†©</a></li><li id="fn-4-10fd85">Umbra is being developed by <a href="https://www.professoren.tum.de/en/neumann-thomas" target="_blank" rel="noopener noreferrer">Thomas Neumann</a> and his group. If Thomas's name does not ring a bell let me explain his weight in the field like this. As the joke goes, in the field of DBMSs: there are gods at the top, then there is Thomas Neumann, and then other holy people, and then we mere mortals.<a href="#fnref-4-10fd85" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>Semih SalihoÄŸlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="internals" term="internals"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[What Every Competent GDBMS Should Do (aka The Goals & Vision of KÃ¹zu]]></title>
        <id>https://kuzudb.com/docusaurus/blog/what-every-gdbms-should-do-and-vision</id>
        <link href="https://kuzudb.com/docusaurus/blog/what-every-gdbms-should-do-and-vision"/>
        <updated>2023-01-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[As a co-implementor of the KÃ¹zu GDBMS and]]></summary>
        <content type="html"><![CDATA[<p>As a co-implementor of the KÃ¹zu GDBMS and
a professor at University of Waterloo,
I have been thinking of GDBMSs day in and day out for many years now.
After years of understanding and publishing on the architectural principles
of graph data management (<a href="http://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf" target="_blank" rel="noopener noreferrer">2</a>,
<a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf" target="_blank" rel="noopener noreferrer">3</a>,
<a href="https://www.vldb.org/pvldb/vol15/p1533-chen.pdf" target="_blank" rel="noopener noreferrer">4</a>),
we decided to develop
<a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">KÃ¹zu</a> as a state-of-the-art modern embeddable GDBMS.
This post covers my broad opinions on GDBMSs, and the feature set they should
optimize for and why. In doing so, it also gives an overall vision of KÃ¹zu!</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>Overview of GDBMSs</strong>: GDBMSs are relational in their cores but offer an elegant graph model
to model application data and SQL-like query languages with elegant
graph-specific syntax. Many applications, e.g., in <a href="https://tinyurl.com/3x89ceum" target="_blank" rel="noopener noreferrer">fraud detection</a>,
<a href="https://www.tigergraph.com/solutions/recommendation-engine/" target="_blank" rel="noopener noreferrer">recommendations</a>,
<a href="https://tinyurl.com/3z9bckmm" target="_blank" rel="noopener noreferrer">personalization</a>, etc. benefit from such modeling and query language features.</li><li><strong>Key Feature Set of GDBMSs</strong>: Despite being relational, GDBMSs optimize (or at
least they should!) for a distinct set of
features/use cases that RDBMSs do not traditionally optimize for: (i) pre-defined/pointer-based joins;
(ii) growing many-to-many joins;
(iii) recursive joins;
(iv) schema querying;
(v) efficient storage of semi-structured data and URIs.
GDBMSs that want to be competitive in terms of performance
need to perfect this feature set and that's exactly what KÃ¹zu aims to do!</li><li><strong>KÃ¹zu as the GDBMS for Graph Data Science</strong>:
One example application domain the KÃ¹zu team is excited about is
to be a usable, efficient, and scalable GDBMS of graph data science in the Python graph analytics ecosystem.
Here we are looking at how DuckDB revolutionized tabular data science and
want to repeat it in graph data science! </li></ul></div></div><p>This week, I presented KÃ¹zu to the database community at the <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR 2023</a>
conference in Amsterdam. For those who are not familiar with academic database conferences,
CIDR brings together work from academia and industry to discuss recent research on
systems aspects of database technology. Our paper was about KÃ¹zu's
goals and vision and its core query processor design for evaluating complex growing joins.
We intentionally targeted CIDR for our paper because of its systems
focus and we thought many system gurus would be there: the attendees included
creators of <a href="https://www.monetdb.org/" target="_blank" rel="noopener noreferrer">MonetDB</a>, <a href="https://en.wikipedia.org/wiki/Vectorwise" target="_blank" rel="noopener noreferrer">Vectorwise</a>,
<a href="https://duckdb.org/" target="_blank" rel="noopener noreferrer">DuckDB</a>,
<a href="https://www.snowflake.com/en/" target="_blank" rel="noopener noreferrer">Snowflake</a>, <a href="https://www.databricks.com/" target="_blank" rel="noopener noreferrer">Databricks</a>, amongst others. It also meant a lot to share
our ambitious goal of developing a usable GDBMS from an academic setting in this CIDR because
it was  organized locally by CWI. The late <a href="https://en.wikipedia.org/wiki/Martin_L._Kersten" target="_blank" rel="noopener noreferrer">Martin Kersten</a>
founded the CWI database group and was a pioneer of this style of research projects and
his successors are continuing this tradition very successfully today.
CWI has created many successful DBMSs, including MonetDB (Martin's legacy), Vectorwise, and
most recently DuckDB. People paid their respects to Martin during an emotional memorial
on the first night of the conference.
As a surprise, <a href="https://memgraph.com/" target="_blank" rel="noopener noreferrer">MemGraph</a> co-founder and CTO  <a href="https://www.linkedin.com/in/markobudiselic/" target="_blank" rel="noopener noreferrer">Marko BudiseliÄ‡</a>
was also there (it was his first CIDR)! Marko is an extremely friendly
and humble person you should meet and it was great to share our insights about where GDBMSs make a difference in
enterprise applications.</p><p>I want to start a 3-part blog post to cover the contents of our CIDR paper in a less academic language: </p><ul><li>Post 1: KÃ¹zu's goals and vision as a system </li><li>Post 2: <a href="/docusaurus/blog/factorization">Factorization technique for compression</a></li><li>Post 3: <a href="/docusaurus/blog/wcoj">Worst-case optimal join algorithms</a></li></ul><p>In this Post 1, I discuss the following:
(i)   <a href="#overview-of-gdbms-and-a-bit-of-history">an overview of GDBMSs</a>.
(ii)  <a href="#features-every-competent-gdbms-should-optimize-for-">the features GDBMSs should optimize  for and why;</a> and
(iii) <a href="#k%C3%B9zu-as-a-gdbms-for-graph-data-science-pipelines">an example application domain (graph data science!) we are immediately targeting with KÃ¹zu. </a>
(ii) and (iii) should give you a good idea about the current goals and
vision of KÃ¹zu. If you know GDBMSs well, you should skip over (i).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview-of-gdbmss-and-a-bit-of-history">Overview of GDBMSs and a Bit of History<a href="#overview-of-gdbmss-and-a-bit-of-history" class="hash-link" aria-label="Direct link to Overview of GDBMSs and a Bit of History" title="Direct link to Overview of GDBMSs and a Bit of History">â€‹</a></h2><p>In one sentence, GDBMSs are read-optimized analytical DBMSs for modeling and querying application
data as a graph. As a consequence they are optimized for fast querying of node and
relationship records.
Modern GDBMSs, such as Neo4j, Tigergraph, MemGraph, or KÃ¹zu,
adopt the <a href="https://neo4j.com/developer/graph-database/#property-graph" target="_blank" rel="noopener noreferrer">property graph data model</a>
(or its variants), where you can model your records as a set of labeled nodes and
edges/relationships, and key-value properties on these relationships. When
I say GDBMSs in this post, I specifically refer to the systems that adopt this
model but I will also discuss <a href="https://en.wikipedia.org/wiki/Triplestore" target="_blank" rel="noopener noreferrer">RDF systems</a> (aka triplestores)
here and there, which are also DBMSs that adopt a graph-based model.</p><p>Here's a side comment that I have to make because I'm a professor and
professors are always ready to profess.
DBMSs based on graph models are anything but new. They have existed even before the relational
model: DBMS die-hards love remembering
that the <a href="https://en.wikipedia.org/wiki/Integrated_Data_Store" target="_blank" rel="noopener noreferrer">IDS system</a> from 1960s was based on the "network model",
which is is just another term for graph. IDS was lead by the amazing
Charlie Bachmann, <img loading="lazy" align="left" style="width:380px;padding-right:15px" src="/docusaurus/assets/images/bachmann-869ea053f50b618f11a3288ac0bdb2b6.png" class="img_ev3q"> <a href="https://amturing.acm.org/award_winners/bachman_9385610.cfm" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://youtu.be/iDVsNqFEkB0" target="_blank" rel="noopener noreferrer">2</a>, <a href="https://youtu.be/jByIpJNrm50" target="_blank" rel="noopener noreferrer">3</a>), whose photo is shown on the left and who is credited for inventing DBMSs<sup id="fnref-1-f6cc9d"><a href="#fn-1-f6cc9d" class="footnote-ref">1</a></sup>.
If you click on <a href="http://wp.sigmod.org/wp-content/uploads/2012/12/image4.jpg" target="_blank" rel="noopener noreferrer">this 1962 ad of the IDS system</a>, you will see a graph of node and
edge records. Note 1960s are pre-relational times. Ever since, every decade has seen a surge of DBMSs
that adopted a graph-based model with mixed levels of adoption success:
hierarchical model, XML, and RDF are examples.
In my view, current property GDBMSs is the most generic
and suitable to model a very broad range of application data out of these.
So they probably established themselves most successfully out of these.
There is a very fundamental reason why graph-based DBMSs have always existed and will
always exist: graphs and tables are the two most natural and generic abstract data structures
to model application data. It's no surprise they were the first two proposed data models
when the field of DBMSs were born and both have existed ever since and will continue to exist.</p><p>Back to property GDBMSs. How about their query languages? They support SQL-like high-level
query languages with several graph-specific syntax.
I call them "graph-specific" SQL. Let's look at a query snippet. Assume this is
on a database that models a set of financial "accounts" and money "transfers"
between accounts:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b.ID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is a query expressed in Cypher. Instead of a SELECT/FROM/WHERE,
you are looking at MATCH/WHERE/RETURN.
If intelligent Martians saw Cypher and SQL, their immediate reaction
would not be to notice the minor syntactic differences but instead
the fundamental similarities:  their clauses describe joins,
filters, projections, group by and aggregates, and other relational
operations that process sets of tuples.
There is of course syntactic differences that are important. Query languages of
GDBMSs adopt graph-specific syntax that are often very elegant to express several computations.
For example, the arrow syntax ((a)-<!-- -->[e]<!-- -->-&gt;(b)) in Cypher describes joins between node records. This
is much more elegant than listing names of tables that model
node records in a FROM clause, with a complex WHERE clause.
Much more importantly, they adopt a very elegant and direct syntax,
such as the Kleene star "*", to
express recursive queries. Expressing recursive computations with vanilla SQL is
objectively harder. I'll come to recursive queries later.</p><p>Now get ready for a blasphemous observation: <em>GDBMSs are relational at their cores!</em><sup id="fnref-2-f6cc9d"><a href="#fn-2-f6cc9d" class="footnote-ref">2</a></sup>.
Well, OK anyone who has studied the principles of DBMSs knows there is nothing
blasphemous here because GDBMSs actually have to be relational
because of this simple fact:
<em>the only known practical way to implement declarative high-level
query languages is to compile them to relational operators that
take in and output sets of tuples</em>. Type "Explain" to any of your
queries in your favorite  GDBMs (or RDF system) and look at their query plans and
you will see joins, scans, filters, projections, group bys, unions,
intersections, etc. You might see some graph-specific operators
but they will also be processing sets of tuples. That was the primary
observation of <a href="https://en.wikipedia.org/wiki/Edgar_F._Codd" target="_blank" rel="noopener noreferrer">Ted Codd</a> when he proposed
that data management should be done by systems implementing
relational operators that process sets of tuples. </p><p>But don't worry, I do love GDBMSs and you should too! The fact that at their cores
GDBMSs are relational doesn't mean they don't offer value beyond RDBMSs.
DBMSs are very complex software systems and they make a ton of design tradeoffs in terms of
what they optimize for. There is a very distinctive set of technical features that
GDBMSs should optimize for and excel in, where RDBMSs and SQL traditionally don't.
This feature set is exactly what
KÃ¹zu aims to perfect over time, which is what I hope to articulate in this post.
In short: GDBMSs do offer a ton of value if
they are architected correctly and every software engineer should know
about GDBMSs<sup id="fnref-3-f6cc9d"><a href="#fn-3-f6cc9d" class="footnote-ref">3</a></sup>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="features-every-competent-gdbms-should-optimize-for-">Features Every Competent GDBMS Should Optimize For <sup id="fnref-4-f6cc9d"><a href="#fn-4-f6cc9d" class="footnote-ref">4</a></sup><a href="#features-every-competent-gdbms-should-optimize-for-" class="hash-link" aria-label="Direct link to features-every-competent-gdbms-should-optimize-for-" title="Direct link to features-every-competent-gdbms-should-optimize-for-">â€‹</a></h2><p>Here is a list of features that differentiate GDBMSs from RDBMSs and GDBMS should
highly optimize for and support.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-1-pre-definedpointer-based-joins">Feature 1: Pre-defined/pointer-based Joins<a href="#feature-1-pre-definedpointer-based-joins" class="hash-link" aria-label="Direct link to Feature 1: Pre-defined/pointer-based Joins" title="Direct link to Feature 1: Pre-defined/pointer-based Joins">â€‹</a></h3><p>This is perhaps the most ubiquitously adopted technique in GDBMSs that is ubiquitously missing in RDBMSs.
Although GDBMSs
can join arbitrary node records with each other, most common user queries in GDBMSs
join node records with their "neighbors". A GDBMS knows about these
neighbor node records because they are predefined to the system as relationships.
So GDBMSs universally exploit this and optimize for these types of joins. For example,
almost universally they all create a <strong>join index</strong> (aka an adjacency list index)<sup id="fnref-5-f6cc9d"><a href="#fn-5-f6cc9d" class="footnote-ref">5</a></sup>.
Here's a demonstrative example showing a "forward", i.e., from src to dst, join index:</p><img loading="lazy" src="/docusaurus/assets/images/ex-fwd-join-index-49f7fc95a380307fc81426311608634d.png" width="800" class="img_ev3q"><p>Note that the join index does not store the actual data values, which
are strings (e.g., "Ali", "Noura", etc.) in the example. Instead,
it stores dense system level node record IDs.
As a result, GDBMSs can be fast on these joins because they can use: (1) the join index;
and (2) dense integer IDs to joins (instead of, say running string equality conditions). </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-2-many-to-many-growing-joins">Feature 2: Many-to-many Growing Joins<a href="#feature-2-many-to-many-growing-joins" class="hash-link" aria-label="Direct link to Feature 2: Many-to-many Growing Joins" title="Direct link to Feature 2: Many-to-many Growing Joins">â€‹</a></h3><p>In many application data stored on GDBMSs, node records
have many-to-many relationships with each other. Think of any data as a graph,
say a network of financial transactions or who bought which items or
who is friends with whom. In many of these datasets, an entity/node connects with
many other nodes. In addition, many of the killer apps of GDBMSs search for complex patterns
on these relationships.
A classic example we like using is a Twitter friend recommendation engine that is looking for diamond patterns to implement
the following rule: If a user A follows two users B and C, who both follow D, recommend
D to A. This is the pattern:</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/diamond-pattern-7c9786e237f65ca486ce787631f06303.png" width="200" class="img_ev3q"></div><p>The whitepapers of existing GDBMSs are full of these patterns, e.g., branching trees, money laundering circles,
cliques of customers who buy similar items, etc. These correspond to complex
many-to-many joins, which by their nature are growing. If on average each of your nodes
connect with k other nodes and you have t many relationships in the pattern you are searching,
you are asking a system to search through k^t many possible combinations and guess what: exponential
functions are scary. We have been advocating the integration of 2 specific techniques
into the query processors of GDBMSs for several years now: (i) factorization; and (ii) worst-case optimal joins.
Both of these techniques are specifically designed for
many-to-many growing joins and we have integrated them in KÃ¹zu. Stay tuned for for my next two posts on this. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-3-recursive-join-queries">Feature 3: Recursive Join Queries<a href="#feature-3-recursive-join-queries" class="hash-link" aria-label="Direct link to Feature 3: Recursive Join Queries" title="Direct link to Feature 3: Recursive Join Queries">â€‹</a></h3><p>This is probably the most obvious feature where GDBMSs should excel in. First, objectively
the query languages of GDBMSs have much better support
for recursive join queries than SQL. Consider this query on our previous financial transaction network
example: "Give me all direct or indirect money flows into Alice's account from Canada." Now
look at this elegant way to ask this in Cypher using the Kleene star '<!-- -->*<!-- -->':</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Transfer*]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.country = 'Canada' and b.name = 'Alice'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.ID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similar to regexes, '<!-- -->*<!-- -->' represents possible 1 or more repetitions of the Transfer
edge in the join. So the join could be a direct join between (a) and (b) or a 2-hop one,
or a 3-hop one etc. You can do this with SQL of course, but it's objectively harder. Recursion
has been an afterthought when standardizing SQL. It came 20 years after SQL standardization started and is really a hack.
In contrast, recursion has been first-class citizen
feature in every graph-based DBMS's query language.
This distinction is even much more visible
if you want to do other graph-specific recursive computation, such as finding shortest paths.
In  KÃ¹zu, we are starting to work on implementing
and optimizing recursive query support and we hope to have first a basic version and
then optimized versions that hopefully works very well and contributes to the principles of how these
queries should be evaluated.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-4-schema-querying">Feature 4: Schema Querying<a href="#feature-4-schema-querying" class="hash-link" aria-label="Direct link to Feature 4: Schema Querying" title="Direct link to Feature 4: Schema Querying">â€‹</a></h3><p>Another important feature of GDBMSs that cannot be done in
RDBMSs is that the query languages allow querying the schema of a database in addition
to the data in the database. Suppose in a modified financial transaction network,
there are three relationship types: Wire, Deposit, and ETransfer and you
you wanted to search for a path where the first edge and the second edge types
are different. Note that the predicate is <em>on the schema</em>, specifically on the type
of the nodes/relations. You can write the following query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1]-&gt;(b:Account)-[e2]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE type(e1) != type(e2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Something akin to this cannot directly be done in SQL. One would have to write a query
that unions many sub-queries: one that joins node records over Wire and then Deposit,
another on Wire and ETransfer, another on Deposit and then Wire etc. This will be
messy. The ability to <em>not</em> specify a label on relationships,
specifically on e1 and e2, is an
elegant way to effectively express such unions of join queries.
It says: "join a and b nodes over every possible relationship".
The <code>type()</code> function on these variables allows doing querying over the schema.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs">Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., "Knowledge Graphs")<a href="#feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs" class="hash-link" aria-label="Direct link to Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)" title="Direct link to Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)">â€‹</a></h3><p>An important application domain of GDBMSs
is "knowledge graphs". This term means different things
in different contexts and I'll take it
to refer to highly heterogenous datasets that are
often naturally modeled as RDF triples. Again, I don't want to go into the
details of this model but I assume many readers will already be familiar with
RDF. RDF is a simple data model where data is represented as (subject, predicate, object)
triples that represent facts about a domain. A great application is when modeling and
querying encyclopedic facts, such as those extracted from Wikipedia data.
For example, the following triple stores the fact
that Justin Trudeau is married to Sophie Trudeau:
(<a href="http://dbpedia.org/resource/Justin_Trudeau" target="_blank" rel="noopener noreferrer">http://dbpedia.org/resource/Justin_Trudeau</a>, <a href="http://dbpedia.org/ontology/spouse" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/spouse</a>,
<a href="http://dbpedia.org/resource/Sophie_Gr%C3%A9goire_Trudeau" target="_blank" rel="noopener noreferrer">http://dbpedia.org/resource/Sophie_GrÃ©goire_Trudeau</a>).
There are 2 immediate challenges for a DBMS to manage
such data: </p><ol><li><p>Structuring such datasets is very difficult. Structuring here
refers to designing a relational schema for the data.
Entities can have many types, e.g., Justin Trudeau is both a "rdf:type"
<a href="http://dbpedia.org/ontology/Person" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/Person</a> as well as
<a href="http://dbpedia.org/ontology/Politician" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/Politician</a>. Further, within a single type, entities can have many different
and distinct properties, so good luck coming up with and maintaining a relational
schema for all that.
This is a direct result of
the overly ambitious domain the dataset is modeling: all encyclopedic human knowledge!
You need a data model that allows flexibility in what can be associated with entities
and their types<sup id="fnref-6-f6cc9d"><a href="#fn-6-f6cc9d" class="footnote-ref">6</a></sup>.</p></li><li><p>Those long strings used to identify entities, e.g., Justin
Trudea, are called URIs (for universal resource identifiers),
and queries will frequently access and specify them. So systems should
be competent in handling those.</p></li></ol><p>GDBMSs tend to support semi-structured schemas and certainly RDF systems
have good techniques to handle URIs.
These applications are directly in the realm of graph-based DBMSs.
Currently, they are directly targeted by RDF systems but I'm convinced
GDBMSs should also implement techniques to efficiently support them<sup id="fnref-7-f6cc9d"><a href="#fn-7-f6cc9d" class="footnote-ref">7</a></sup>. </p><p><strong>Final note on the above feature set:</strong> I referred to several classic applications but
many other applications require and benefit
from the above feature set.  One can
think of the dataset and workloads of these applications as the "beyond relational/SQL" datasets/workloads, which
often require modeling and querying in a graph-based DBMS, and
we want KÃ¹zu to excel in and represent the state-of-art in this feature set! </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="kÃ¹zu-as-a-gdbms-for-graph-data-science-pipelines">KÃ¹zu as a GDBMS for Graph Data Science Pipelines<a href="#kÃ¹zu-as-a-gdbms-for-graph-data-science-pipelines" class="hash-link" aria-label="Direct link to KÃ¹zu as a GDBMS for Graph Data Science Pipelines" title="Direct link to KÃ¹zu as a GDBMS for Graph Data Science Pipelines">â€‹</a></h2><p>Finally, let me tell you a little bit about
a particular application domain we are currently excited
about and we want to see KÃ¹zu used in: graph data science in the python ecosystem!
This figure from my CIDR slides describes this vision pictorially:</p><p><img loading="lazy" alt="KÃ¹zu as a GDBMS for Graph Data Science Pipelines" src="/docusaurus/assets/images/kuzu-as-gdbms-of-gds-9ddb233d59157ec29f6a392d1acf275b.png" width="2433" height="1938" class="img_ev3q"></p><p>Suppose you are building a graph analytics, machine learning, or visualization
pipeline from raw record files on disk. You will want to model your raw records
as nodes and edges, clean them, extract features, query them, transform them,
and then you will extract data to an upstream python library, such as Pytorch Geometric, DGL,
NetworkX or a graph visualization library.
You might even want a pipeline
that extracts regular tables from your graphs to a tabular data science library,
such as NumPy,
since the outputs of queries in Cypher are tables of records.
We want people to use KÃ¹zu as an embeddable library in their Python scripts,
to do their modeling, querying, feature extraction,
cleaning, and other transformations, all by benefiting from a high-level query language
and state-of-art graph data management techniques
that we are implementing. This is exactly what DuckDB did for tabular data science/analytics.
We are looking at DuckDB here and want to fill the same gap for graph data science/analytics!
We are currently understanding the ecosystem better and appreciate feedback
and suggestions for features we should implement to enable your workloads.</p><p>OK, this is it for now. In the next two blog posts, I will discuss
factorization and worst-case optimal join algorithms and describe
some of the principles that we adopted in KÃ¹zu's query processor.
Until then, happy new years from the cold but cozy winter of ðŸ‡¨ðŸ‡¦
and <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">pip install kuzu</a>!</p><div class="footnotes"><hr><ol><li id="fn-1-f6cc9d">Interestingly, Bachmann is one of a handful of Turing laureates without any academic career. If you love DBMSs, <a href="https://youtu.be/iDVsNqFEkB0" target="_blank" rel="noopener noreferrer">listen to this talk</a>  where he remembers his IDS days! Amusingly, he also talks about how he didn't know who Turing was when got the Turing award and how he met Turing's mother in England for tea ðŸ˜€.<a href="#fnref-1-f6cc9d" class="footnote-backref">â†©</a></li><li id="fn-2-f6cc9d">When I say GDBMSs here, I'm referring to the core engines that implement the high-level languages of these systems and not the analytics libraries (e.g., <a href="https://neo4j.com/product/graph-data-science/" target="_blank" rel="noopener noreferrer">1</a>, <a href="https://memgraph.com/mage" target="_blank" rel="noopener noreferrer">2</a>) above these core engines that run iterative graph analytics computations, such as finding connected components, or PageRank, or betweenness centrality. These computations are better understood through either direct graph formalisms or linear algebra (and not relational) operations.<a href="#fnref-2-f6cc9d" class="footnote-backref">â†©</a></li><li id="fn-3-f6cc9d">I am a strong supporter of devoting a few lectures to GDBMSs after covering the fundamental topics on the relational model and RDBMSs in core introduction to DBMSs courses in undergraduate curriculums. Students should broaden their perspectives on the available data models and query/programming languages to them when they develop applications. GDBMSs is an obvious choice here. So is Datalog and RDF/SparQL.<a href="#fnref-3-f6cc9d" class="footnote-backref">â†©</a></li><li id="fn-4-f6cc9d">We articulated this list of features in our CIDR 2023 paper. Incidentally, <a href="https://www.cidrdb.org/cidr2023/papers/p66-wolde.pdf" target="_blank" rel="noopener noreferrer">a paper</a> written by CWI on a graph query extension to DuckDB, had a 12-item list of "techniques" that GDBMSs should implement at their cores. Let me call this the CWI list. These items are not features in the sense I'm using the word, so I call them techniques. As you'll see my features are higher-level system properties from user's perspective. Peter Boncz, who is renowned in the field for having written or advised many successful DBMSs that spinned off, presented the CWI paper. I highly recommend this as another reading if you want to know more about Peter and his co-authors' technical insights about how GDBMSs should be architected. Importantly, KÃ¹zu has integrated or is in the process of integrating 11 of the 12 techniques in the CWI list(bulk path finding is the one we have to do more thinking on) and our prior publications had also articulated many of these insights,  such as the fact that <a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf" target="_blank" rel="noopener noreferrer">GDBMSs should be columnar systems</a> doing vectorized querying and of course we did a ton of work on <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">worst-case optimal joins</a> and <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">factorization</a>, which are also in the CWI list. I should acknowledge that Peter had been advocating for some of the techniques on the CWI list at least since 2018. I remember a presentation he gave in 2018 to GDBMSs researchers and developers titled "Why are Existing GDBMSs Incompetent?", which listed some of the techniques in the CWI list and visibly has inspired the title of this blog.<a href="#fnref-4-f6cc9d" class="footnote-backref">â†©</a></li><li id="fn-5-f6cc9d">Although some refer to these as an "adjacency list index" because that's a common term in graph terminology, I need to pay my respects to the giants in the field: these are plain old <a href="https://dl.acm.org/doi/abs/10.1145/22952.22955" target="_blank" rel="noopener noreferrer">1980s Valduriez join indices</a>. And no, they were invented in the context of RDBMSs. That said, they never found much adoption in RDBMSs. But they are almost universally adopted in GDBMSs.<a href="#fnref-5-f6cc9d" class="footnote-backref">â†©</a></li><li id="fn-6-f6cc9d">Designing the schema, i.e., defining the types of entities and relationships and class structures and constraints of such complex domains can be decades of work. What I'm referring to as schema is called an "ontology" in knowledge graph/semantic web space. If you ever thought you modeled a hard application domain, take a look at <a href="https://en.wikipedia.org/wiki/SNOMED_CT" target="_blank" rel="noopener noreferrer">SNOMED</a>, which is a decades long effort to model and standardize human medical knowledge. Last term, I had a seminar on SNODEM in my graduate course on knowledge graphs and students were baffled by the complexity of this "ontology", which  describes the types of entities and their relationships and constraints, which RDF technology stack is quite good at.<a href="#fnref-6-f6cc9d" class="footnote-backref">â†©</a></li><li id="fn-7-f6cc9d">Before we released KÃ¹zu, we had support for adding arbitrary node/edge properties but we removed a large chunk of code out of the system to release a thinner code base. So currently you need to specify a schema for your nodes and relationships in KÃ¹zu. We will wait and see if/when that demand comes and how strongly it comes. We know from our conversations with many users and developers of GDBMSs over the years that most datasets in enterprises are not this complex and can be structured. At least after a proof of concept phase of applications, developers structure their data.<a href="#fnref-7-f6cc9d" class="footnote-backref">â†©</a></li></ol></div>]]></content>
        <author>
            <name>Semih SalihoÄŸlu</name>
            <uri>https://cs.uwaterloo.ca/~ssalihog/</uri>
        </author>
        <category label="vision" term="vision"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Meet KÃ¹zu ðŸ¤—]]></title>
        <id>https://kuzudb.com/docusaurus/blog/meet-kuzu</id>
        <link href="https://kuzudb.com/docusaurus/blog/meet-kuzu"/>
        <updated>2022-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Today we are very excited to make an initial version of KÃ¹zu public on github!]]></summary>
        <content type="html"><![CDATA[<p>Today we are very excited to make an initial version of <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">KÃ¹zu public on github</a>!
KÃ¹zu is a new embeddable property graph database management system (GDBMS) that is
designed for high scalability and very fast querying. We are releasing
KÃ¹zu today under a permissible MIT license. Through years of research on GDBMSs, we observed a lack of
highly efficient GDBMS in the market that adopts state-of-the-art
querying and storage techniques and that can very easily integrate into applications,
similar to DuckDB or SQLite. KÃ¹zu aims to fill this space and evolve into the
go-to open-source system to develop
graph database applications, e.g., to manage and query your knowledge graphs,
and develop graph machine learning and analytics pipelines,
e.g., in the Python data science ecosystem. </p><p>KÃ¹zu's core architecture is informed by 6 years of research we conducted
at University of Waterloo on an earlier prototype GDBMS called <a href="http://graphflow.io/" target="_blank" rel="noopener noreferrer">GraphflowDB</a>.
Unlike GraphflowDB, which was intended to be a prototype for our research, KÃ¹zu aims to be
a usable feature-rich system. Some of the primary features of KÃ¹zu's  architecture are:</p><ul><li>Flexible Property Graph Data Model and Cypher query language</li><li>Embeddable, serverless integration into applications</li><li>Columnar disk-based storage</li><li>Columnar sparse row-based (CSR) adjacency list/join indices</li><li>Vectorized and factorized query processor</li><li>Novel and very fast join algorithms</li><li>Multi-core query parallelism</li><li>Serializable ACID transactions</li></ul><p>What we are releasing today includes many of the features of the core engine. This is what we
called the "Phase 1" of the project. In the next "Phase 2" of the project, as we continue adding
more features to the core engine, e.g., better support for ad-hoc properties, string compression,
and support for new recursive queries, we will also be focusing developing around the core engine
to more easily ingest data into the system and output data to downstream data science/graph data science
libraries. You can keep an eye on our tentative <a href="https://github.com/kuzudb/kuzu/issues/981" target="_blank" rel="noopener noreferrer">roadmap here</a>.
You can also read more about some of our longer term goals and vision as a system
in <a href="https://cs.uwaterloo.ca/~ssalihog/papers/kuzu-tr.pdf" target="_blank" rel="noopener noreferrer">our new CIDR 2023 paper</a>,
which we will present in Amsterdam next January. </p><p><em>And most importantly please start using KÃ¹zu, tell us your feature requests, use cases, and report bugs. We can evolve into a
more stable, usable, and feature-rich system only through your feedback!</em> </p><p>We are looking forward to to your feedback and a long and exciting journey as we continue developing KÃ¹zu ðŸ¤—. </p><sub>*ps: For interested readers: the word kÃ¹-zu is the Sumerian (the oldest known human language) word for "wisdom".*</sub>]]></content>
        <author>
            <name>KÃ¹zu Team</name>
            <uri>https://github.com/kuzudb/</uri>
        </author>
        <category label="release" term="release"/>
    </entry>
</feed>