<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu | Kùzu</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" property="og:url" content="https://kuzudb.com/docusaurus/blog/what-every-gdbms-should-do-and-vision"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="og:locale" content="en_US"><meta data-rh="true" name="og:type" content="article"><meta data-rh="true" name="og:site_name" content="Kùzu"><meta data-rh="true" name="og:image" content="https://kuzudb.com/img/logo-u-with-orange-tick.jpg"><meta data-rh="true" name="twitter:card" content="summary"><meta data-rh="true" name="twitter:site" content="@kuzudb"><meta data-rh="true" name="twitter:creator" content="@kuzudb"><meta data-rh="true" name="twitter:image" content="https://kuzudb.com/img/logo-u-with-orange-tick.jpg"><meta data-rh="true" property="og:title" content="What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu | Kùzu"><meta data-rh="true" name="description" content="As a co-implementor of the Kùzu GDBMS and"><meta data-rh="true" property="og:description" content="As a co-implementor of the Kùzu GDBMS and"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-01-12T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://cs.uwaterloo.ca/~ssalihog/"><meta data-rh="true" property="article:tag" content="vision"><link data-rh="true" rel="icon" href="/docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kuzudb.com/docusaurus/blog/what-every-gdbms-should-do-and-vision"><link data-rh="true" rel="alternate" href="https://kuzudb.com/docusaurus/blog/what-every-gdbms-should-do-and-vision" hreflang="en"><link data-rh="true" rel="alternate" href="https://kuzudb.com/docusaurus/blog/what-every-gdbms-should-do-and-vision" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://XV0PE3XW33-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/docusaurus/blog/rss.xml" title="Kùzu RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docusaurus/blog/atom.xml" title="Kùzu Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Kùzu" href="/docusaurus/opensearch.xml">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/docusaurus/assets/css/styles.a72d597a.css">
<link rel="preload" href="/docusaurus/assets/js/runtime~main.3f6fcfe5.js" as="script">
<link rel="preload" href="/docusaurus/assets/js/main.2d80c558.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://kuzudb.com/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/docusaurus/img/kuzu-logo.png" alt="Kùzu" class="themedImage_ToTc themedImage--light_HNdA"><img src="/docusaurus/img/kuzu-logo-inverse.png" alt="Kùzu" class="themedImage_ToTc themedImage--dark_i4oU"></div></a><a class="navbar__item navbar__link" href="/docusaurus/installation">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docusaurus/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item">
            <a href="https://github.com/kuzudb/kuzu" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-github fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-slack fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://twitter.com/kuzudb" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-twitter fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://www.youtube.com/@KuzuDB" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-youtube fa-xl"></i>
            </a>
            </div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.7-release">Kùzu 0.0.7 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/iamgraphviz">IAMGraphViz: Visualizing AWS IAM Permissions with Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.6-release">Kùzu 0.0.6 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.5-release">Kùzu 0.0.5 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.4-release">Kùzu 0.0.4 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-pyg-remote-backend">Scaling Pytorch Geometric GNNs With Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.3-release">Kùzu 0.0.3 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/wcoj">Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.2-release">Kùzu 0.0.2 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/factorization">Factorization &amp; Great Ideas from Database Theory</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/meet-kuzu">Meet Kùzu 🤗</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-01-12T00:00:00.000Z" itemprop="datePublished">January 12, 2023</time> · <!-- -->19 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://cs.uwaterloo.ca/~ssalihog/" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://kuzudb.com/img/blog/semih.jpg" alt="Semih Salihoğlu"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://cs.uwaterloo.ca/~ssalihog/" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Semih Salihoğlu</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>As a co-implementor of the Kùzu GDBMS and
a professor at University of Waterloo,
I have been thinking of GDBMSs day in and day out for many years now.
After years of understanding and publishing on the architectural principles
of graph data management (<a href="http://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf" target="_blank" rel="noopener noreferrer">2</a>,
<a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf" target="_blank" rel="noopener noreferrer">3</a>,
<a href="https://www.vldb.org/pvldb/vol15/p1533-chen.pdf" target="_blank" rel="noopener noreferrer">4</a>),
we decided to develop
<a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">Kùzu</a> as a state-of-the-art modern embeddable GDBMS.
This post covers my broad opinions on GDBMSs, and the feature set they should
optimize for and why. In doing so, it also gives an overall vision of Kùzu!</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>Overview of GDBMSs</strong>: GDBMSs are relational in their cores but offer an elegant graph model
to model application data and SQL-like query languages with elegant
graph-specific syntax. Many applications, e.g., in <a href="https://tinyurl.com/3x89ceum" target="_blank" rel="noopener noreferrer">fraud detection</a>,
<a href="https://www.tigergraph.com/solutions/recommendation-engine/" target="_blank" rel="noopener noreferrer">recommendations</a>,
<a href="https://tinyurl.com/3z9bckmm" target="_blank" rel="noopener noreferrer">personalization</a>, etc. benefit from such modeling and query language features.</li><li><strong>Key Feature Set of GDBMSs</strong>: Despite being relational, GDBMSs optimize (or at
least they should!) for a distinct set of
features/use cases that RDBMSs do not traditionally optimize for: (i) pre-defined/pointer-based joins;
(ii) growing many-to-many joins;
(iii) recursive joins;
(iv) schema querying;
(v) efficient storage of semi-structured data and URIs.
GDBMSs that want to be competitive in terms of performance
need to perfect this feature set and that&#x27;s exactly what Kùzu aims to do!</li><li><strong>Kùzu as the GDBMS for Graph Data Science</strong>:
One example application domain the Kùzu team is excited about is
to be a usable, efficient, and scalable GDBMS of graph data science in the Python graph analytics ecosystem.
Here we are looking at how DuckDB revolutionized tabular data science and
want to repeat it in graph data science! </li></ul></div></div><p>This week, I presented Kùzu to the database community at the <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR 2023</a>
conference in Amsterdam. For those who are not familiar with academic database conferences,
CIDR brings together work from academia and industry to discuss recent research on
systems aspects of database technology. Our paper was about Kùzu&#x27;s
goals and vision and its core query processor design for evaluating complex growing joins.
We intentionally targeted CIDR for our paper because of its systems
focus and we thought many system gurus would be there: the attendees included
creators of <a href="https://www.monetdb.org/" target="_blank" rel="noopener noreferrer">MonetDB</a>, <a href="https://en.wikipedia.org/wiki/Vectorwise" target="_blank" rel="noopener noreferrer">Vectorwise</a>,
<a href="https://duckdb.org/" target="_blank" rel="noopener noreferrer">DuckDB</a>,
<a href="https://www.snowflake.com/en/" target="_blank" rel="noopener noreferrer">Snowflake</a>, <a href="https://www.databricks.com/" target="_blank" rel="noopener noreferrer">Databricks</a>, amongst others. It also meant a lot to share
our ambitious goal of developing a usable GDBMS from an academic setting in this CIDR because
it was  organized locally by CWI. The late <a href="https://en.wikipedia.org/wiki/Martin_L._Kersten" target="_blank" rel="noopener noreferrer">Martin Kersten</a>
founded the CWI database group and was a pioneer of this style of research projects and
his successors are continuing this tradition very successfully today.
CWI has created many successful DBMSs, including MonetDB (Martin&#x27;s legacy), Vectorwise, and
most recently DuckDB. People paid their respects to Martin during an emotional memorial
on the first night of the conference.
As a surprise, <a href="https://memgraph.com/" target="_blank" rel="noopener noreferrer">MemGraph</a> co-founder and CTO  <a href="https://www.linkedin.com/in/markobudiselic/" target="_blank" rel="noopener noreferrer">Marko Budiselić</a>
was also there (it was his first CIDR)! Marko is an extremely friendly
and humble person you should meet and it was great to share our insights about where GDBMSs make a difference in
enterprise applications.</p><p>I want to start a 3-part blog post to cover the contents of our CIDR paper in a less academic language: </p><ul><li>Post 1: Kùzu&#x27;s goals and vision as a system </li><li>Post 2: <a href="/docusaurus/blog/factorization">Factorization technique for compression</a></li><li>Post 3: <a href="/docusaurus/blog/wcoj">Worst-case optimal join algorithms</a></li></ul><p>In this Post 1, I discuss the following:
(i)   <a href="#overview-of-gdbms-and-a-bit-of-history">an overview of GDBMSs</a>.
(ii)  <a href="#features-every-competent-gdbms-should-optimize-for-">the features GDBMSs should optimize  for and why;</a> and
(iii) <a href="#k%C3%B9zu-as-a-gdbms-for-graph-data-science-pipelines">an example application domain (graph data science!) we are immediately targeting with Kùzu. </a>
(ii) and (iii) should give you a good idea about the current goals and
vision of Kùzu. If you know GDBMSs well, you should skip over (i).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview-of-gdbmss-and-a-bit-of-history">Overview of GDBMSs and a Bit of History<a href="#overview-of-gdbmss-and-a-bit-of-history" class="hash-link" aria-label="Direct link to Overview of GDBMSs and a Bit of History" title="Direct link to Overview of GDBMSs and a Bit of History">​</a></h2><p>In one sentence, GDBMSs are read-optimized analytical DBMSs for modeling and querying application
data as a graph. As a consequence they are optimized for fast querying of node and
relationship records.
Modern GDBMSs, such as Neo4j, Tigergraph, MemGraph, or Kùzu,
adopt the <a href="https://neo4j.com/developer/graph-database/#property-graph" target="_blank" rel="noopener noreferrer">property graph data model</a>
(or its variants), where you can model your records as a set of labeled nodes and
edges/relationships, and key-value properties on these relationships. When
I say GDBMSs in this post, I specifically refer to the systems that adopt this
model but I will also discuss <a href="https://en.wikipedia.org/wiki/Triplestore" target="_blank" rel="noopener noreferrer">RDF systems</a> (aka triplestores)
here and there, which are also DBMSs that adopt a graph-based model.</p><p>Here&#x27;s a side comment that I have to make because I&#x27;m a professor and
professors are always ready to profess.
DBMSs based on graph models are anything but new. They have existed even before the relational
model: DBMS die-hards love remembering
that the <a href="https://en.wikipedia.org/wiki/Integrated_Data_Store" target="_blank" rel="noopener noreferrer">IDS system</a> from 1960s was based on the &quot;network model&quot;,
which is is just another term for graph. IDS was lead by the amazing
Charlie Bachmann, <img loading="lazy" align="left" style="width:380px;padding-right:15px" src="/docusaurus/assets/images/bachmann-869ea053f50b618f11a3288ac0bdb2b6.png" class="img_ev3q"> <a href="https://amturing.acm.org/award_winners/bachman_9385610.cfm" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://youtu.be/iDVsNqFEkB0" target="_blank" rel="noopener noreferrer">2</a>, <a href="https://youtu.be/jByIpJNrm50" target="_blank" rel="noopener noreferrer">3</a>), whose photo is shown on the left and who is credited for inventing DBMSs<sup id="fnref-1-f6cc9d"><a href="#fn-1-f6cc9d" class="footnote-ref">1</a></sup>.
If you click on <a href="http://wp.sigmod.org/wp-content/uploads/2012/12/image4.jpg" target="_blank" rel="noopener noreferrer">this 1962 ad of the IDS system</a>, you will see a graph of node and
edge records. Note 1960s are pre-relational times. Ever since, every decade has seen a surge of DBMSs
that adopted a graph-based model with mixed levels of adoption success:
hierarchical model, XML, and RDF are examples.
In my view, current property GDBMSs is the most generic
and suitable to model a very broad range of application data out of these.
So they probably established themselves most successfully out of these.
There is a very fundamental reason why graph-based DBMSs have always existed and will
always exist: graphs and tables are the two most natural and generic abstract data structures
to model application data. It&#x27;s no surprise they were the first two proposed data models
when the field of DBMSs were born and both have existed ever since and will continue to exist.</p><p>Back to property GDBMSs. How about their query languages? They support SQL-like high-level
query languages with several graph-specific syntax.
I call them &quot;graph-specific&quot; SQL. Let&#x27;s look at a query snippet. Assume this is
on a database that models a set of financial &quot;accounts&quot; and money &quot;transfers&quot;
between accounts:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.name = &#x27;Alice&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b.ID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is a query expressed in Cypher. Instead of a SELECT/FROM/WHERE,
you are looking at MATCH/WHERE/RETURN.
If intelligent Martians saw Cypher and SQL, their immediate reaction
would not be to notice the minor syntactic differences but instead
the fundamental similarities:  their clauses describe joins,
filters, projections, group by and aggregates, and other relational
operations that process sets of tuples.
There is of course syntactic differences that are important. Query languages of
GDBMSs adopt graph-specific syntax that are often very elegant to express several computations.
For example, the arrow syntax ((a)-<!-- -->[e]<!-- -->-&gt;(b)) in Cypher describes joins between node records. This
is much more elegant than listing names of tables that model
node records in a FROM clause, with a complex WHERE clause.
Much more importantly, they adopt a very elegant and direct syntax,
such as the Kleene star &quot;*&quot;, to
express recursive queries. Expressing recursive computations with vanilla SQL is
objectively harder. I&#x27;ll come to recursive queries later.</p><p>Now get ready for a blasphemous observation: <em>GDBMSs are relational at their cores!</em><sup id="fnref-2-f6cc9d"><a href="#fn-2-f6cc9d" class="footnote-ref">2</a></sup>.
Well, OK anyone who has studied the principles of DBMSs knows there is nothing
blasphemous here because GDBMSs actually have to be relational
because of this simple fact:
<em>the only known practical way to implement declarative high-level
query languages is to compile them to relational operators that
take in and output sets of tuples</em>. Type &quot;Explain&quot; to any of your
queries in your favorite  GDBMs (or RDF system) and look at their query plans and
you will see joins, scans, filters, projections, group bys, unions,
intersections, etc. You might see some graph-specific operators
but they will also be processing sets of tuples. That was the primary
observation of <a href="https://en.wikipedia.org/wiki/Edgar_F._Codd" target="_blank" rel="noopener noreferrer">Ted Codd</a> when he proposed
that data management should be done by systems implementing
relational operators that process sets of tuples. </p><p>But don&#x27;t worry, I do love GDBMSs and you should too! The fact that at their cores
GDBMSs are relational doesn&#x27;t mean they don&#x27;t offer value beyond RDBMSs.
DBMSs are very complex software systems and they make a ton of design tradeoffs in terms of
what they optimize for. There is a very distinctive set of technical features that
GDBMSs should optimize for and excel in, where RDBMSs and SQL traditionally don&#x27;t.
This feature set is exactly what
Kùzu aims to perfect over time, which is what I hope to articulate in this post.
In short: GDBMSs do offer a ton of value if
they are architected correctly and every software engineer should know
about GDBMSs<sup id="fnref-3-f6cc9d"><a href="#fn-3-f6cc9d" class="footnote-ref">3</a></sup>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="features-every-competent-gdbms-should-optimize-for-">Features Every Competent GDBMS Should Optimize For <sup id="fnref-4-f6cc9d"><a href="#fn-4-f6cc9d" class="footnote-ref">4</a></sup><a href="#features-every-competent-gdbms-should-optimize-for-" class="hash-link" aria-label="Direct link to features-every-competent-gdbms-should-optimize-for-" title="Direct link to features-every-competent-gdbms-should-optimize-for-">​</a></h2><p>Here is a list of features that differentiate GDBMSs from RDBMSs and GDBMS should
highly optimize for and support.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-1-pre-definedpointer-based-joins">Feature 1: Pre-defined/pointer-based Joins<a href="#feature-1-pre-definedpointer-based-joins" class="hash-link" aria-label="Direct link to Feature 1: Pre-defined/pointer-based Joins" title="Direct link to Feature 1: Pre-defined/pointer-based Joins">​</a></h3><p>This is perhaps the most ubiquitously adopted technique in GDBMSs that is ubiquitously missing in RDBMSs.
Although GDBMSs
can join arbitrary node records with each other, most common user queries in GDBMSs
join node records with their &quot;neighbors&quot;. A GDBMS knows about these
neighbor node records because they are predefined to the system as relationships.
So GDBMSs universally exploit this and optimize for these types of joins. For example,
almost universally they all create a <strong>join index</strong> (aka an adjacency list index)<sup id="fnref-5-f6cc9d"><a href="#fn-5-f6cc9d" class="footnote-ref">5</a></sup>.
Here&#x27;s a demonstrative example showing a &quot;forward&quot;, i.e., from src to dst, join index:</p><img loading="lazy" src="/docusaurus/assets/images/ex-fwd-join-index-49f7fc95a380307fc81426311608634d.png" width="800" class="img_ev3q"><p>Note that the join index does not store the actual data values, which
are strings (e.g., &quot;Ali&quot;, &quot;Noura&quot;, etc.) in the example. Instead,
it stores dense system level node record IDs.
As a result, GDBMSs can be fast on these joins because they can use: (1) the join index;
and (2) dense integer IDs to joins (instead of, say running string equality conditions). </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-2-many-to-many-growing-joins">Feature 2: Many-to-many Growing Joins<a href="#feature-2-many-to-many-growing-joins" class="hash-link" aria-label="Direct link to Feature 2: Many-to-many Growing Joins" title="Direct link to Feature 2: Many-to-many Growing Joins">​</a></h3><p>In many application data stored on GDBMSs, node records
have many-to-many relationships with each other. Think of any data as a graph,
say a network of financial transactions or who bought which items or
who is friends with whom. In many of these datasets, an entity/node connects with
many other nodes. In addition, many of the killer apps of GDBMSs search for complex patterns
on these relationships.
A classic example we like using is a Twitter friend recommendation engine that is looking for diamond patterns to implement
the following rule: If a user A follows two users B and C, who both follow D, recommend
D to A. This is the pattern:</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/diamond-pattern-7c9786e237f65ca486ce787631f06303.png" width="200" class="img_ev3q"></div><p>The whitepapers of existing GDBMSs are full of these patterns, e.g., branching trees, money laundering circles,
cliques of customers who buy similar items, etc. These correspond to complex
many-to-many joins, which by their nature are growing. If on average each of your nodes
connect with k other nodes and you have t many relationships in the pattern you are searching,
you are asking a system to search through k^t many possible combinations and guess what: exponential
functions are scary. We have been advocating the integration of 2 specific techniques
into the query processors of GDBMSs for several years now: (i) factorization; and (ii) worst-case optimal joins.
Both of these techniques are specifically designed for
many-to-many growing joins and we have integrated them in Kùzu. Stay tuned for for my next two posts on this. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-3-recursive-join-queries">Feature 3: Recursive Join Queries<a href="#feature-3-recursive-join-queries" class="hash-link" aria-label="Direct link to Feature 3: Recursive Join Queries" title="Direct link to Feature 3: Recursive Join Queries">​</a></h3><p>This is probably the most obvious feature where GDBMSs should excel in. First, objectively
the query languages of GDBMSs have much better support
for recursive join queries than SQL. Consider this query on our previous financial transaction network
example: &quot;Give me all direct or indirect money flows into Alice&#x27;s account from Canada.&quot; Now
look at this elegant way to ask this in Cypher using the Kleene star &#x27;<!-- -->*<!-- -->&#x27;:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Transfer*]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.country = &#x27;Canada&#x27; and b.name = &#x27;Alice&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.ID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similar to regexes, &#x27;<!-- -->*<!-- -->&#x27; represents possible 1 or more repetitions of the Transfer
edge in the join. So the join could be a direct join between (a) and (b) or a 2-hop one,
or a 3-hop one etc. You can do this with SQL of course, but it&#x27;s objectively harder. Recursion
has been an afterthought when standardizing SQL. It came 20 years after SQL standardization started and is really a hack.
In contrast, recursion has been first-class citizen
feature in every graph-based DBMS&#x27;s query language.
This distinction is even much more visible
if you want to do other graph-specific recursive computation, such as finding shortest paths.
In  Kùzu, we are starting to work on implementing
and optimizing recursive query support and we hope to have first a basic version and
then optimized versions that hopefully works very well and contributes to the principles of how these
queries should be evaluated.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-4-schema-querying">Feature 4: Schema Querying<a href="#feature-4-schema-querying" class="hash-link" aria-label="Direct link to Feature 4: Schema Querying" title="Direct link to Feature 4: Schema Querying">​</a></h3><p>Another important feature of GDBMSs that cannot be done in
RDBMSs is that the query languages allow querying the schema of a database in addition
to the data in the database. Suppose in a modified financial transaction network,
there are three relationship types: Wire, Deposit, and ETransfer and you
you wanted to search for a path where the first edge and the second edge types
are different. Note that the predicate is <em>on the schema</em>, specifically on the type
of the nodes/relations. You can write the following query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1]-&gt;(b:Account)-[e2]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE type(e1) != type(e2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Something akin to this cannot directly be done in SQL. One would have to write a query
that unions many sub-queries: one that joins node records over Wire and then Deposit,
another on Wire and ETransfer, another on Deposit and then Wire etc. This will be
messy. The ability to <em>not</em> specify a label on relationships,
specifically on e1 and e2, is an
elegant way to effectively express such unions of join queries.
It says: &quot;join a and b nodes over every possible relationship&quot;.
The <code>type()</code> function on these variables allows doing querying over the schema.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs">Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)<a href="#feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs" class="hash-link" aria-label="Direct link to Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)" title="Direct link to Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)">​</a></h3><p>An important application domain of GDBMSs
is &quot;knowledge graphs&quot;. This term means different things
in different contexts and I&#x27;ll take it
to refer to highly heterogenous datasets that are
often naturally modeled as RDF triples. Again, I don&#x27;t want to go into the
details of this model but I assume many readers will already be familiar with
RDF. RDF is a simple data model where data is represented as (subject, predicate, object)
triples that represent facts about a domain. A great application is when modeling and
querying encyclopedic facts, such as those extracted from Wikipedia data.
For example, the following triple stores the fact
that Justin Trudeau is married to Sophie Trudeau:
(<a href="http://dbpedia.org/resource/Justin_Trudeau" target="_blank" rel="noopener noreferrer">http://dbpedia.org/resource/Justin_Trudeau</a>, <a href="http://dbpedia.org/ontology/spouse" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/spouse</a>,
<a href="http://dbpedia.org/resource/Sophie_Gr%C3%A9goire_Trudeau" target="_blank" rel="noopener noreferrer">http://dbpedia.org/resource/Sophie_Grégoire_Trudeau</a>).
There are 2 immediate challenges for a DBMS to manage
such data: </p><ol><li><p>Structuring such datasets is very difficult. Structuring here
refers to designing a relational schema for the data.
Entities can have many types, e.g., Justin Trudeau is both a &quot;rdf:type&quot;
<a href="http://dbpedia.org/ontology/Person" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/Person</a> as well as
<a href="http://dbpedia.org/ontology/Politician" target="_blank" rel="noopener noreferrer">http://dbpedia.org/ontology/Politician</a>. Further, within a single type, entities can have many different
and distinct properties, so good luck coming up with and maintaining a relational
schema for all that.
This is a direct result of
the overly ambitious domain the dataset is modeling: all encyclopedic human knowledge!
You need a data model that allows flexibility in what can be associated with entities
and their types<sup id="fnref-6-f6cc9d"><a href="#fn-6-f6cc9d" class="footnote-ref">6</a></sup>.</p></li><li><p>Those long strings used to identify entities, e.g., Justin
Trudea, are called URIs (for universal resource identifiers),
and queries will frequently access and specify them. So systems should
be competent in handling those.</p></li></ol><p>GDBMSs tend to support semi-structured schemas and certainly RDF systems
have good techniques to handle URIs.
These applications are directly in the realm of graph-based DBMSs.
Currently, they are directly targeted by RDF systems but I&#x27;m convinced
GDBMSs should also implement techniques to efficiently support them<sup id="fnref-7-f6cc9d"><a href="#fn-7-f6cc9d" class="footnote-ref">7</a></sup>. </p><p><strong>Final note on the above feature set:</strong> I referred to several classic applications but
many other applications require and benefit
from the above feature set.  One can
think of the dataset and workloads of these applications as the &quot;beyond relational/SQL&quot; datasets/workloads, which
often require modeling and querying in a graph-based DBMS, and
we want Kùzu to excel in and represent the state-of-art in this feature set! </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="kùzu-as-a-gdbms-for-graph-data-science-pipelines">Kùzu as a GDBMS for Graph Data Science Pipelines<a href="#kùzu-as-a-gdbms-for-graph-data-science-pipelines" class="hash-link" aria-label="Direct link to Kùzu as a GDBMS for Graph Data Science Pipelines" title="Direct link to Kùzu as a GDBMS for Graph Data Science Pipelines">​</a></h2><p>Finally, let me tell you a little bit about
a particular application domain we are currently excited
about and we want to see Kùzu used in: graph data science in the python ecosystem!
This figure from my CIDR slides describes this vision pictorially:</p><p><img loading="lazy" alt="Kùzu as a GDBMS for Graph Data Science Pipelines" src="/docusaurus/assets/images/kuzu-as-gdbms-of-gds-9ddb233d59157ec29f6a392d1acf275b.png" width="2433" height="1938" class="img_ev3q"></p><p>Suppose you are building a graph analytics, machine learning, or visualization
pipeline from raw record files on disk. You will want to model your raw records
as nodes and edges, clean them, extract features, query them, transform them,
and then you will extract data to an upstream python library, such as Pytorch Geometric, DGL,
NetworkX or a graph visualization library.
You might even want a pipeline
that extracts regular tables from your graphs to a tabular data science library,
such as NumPy,
since the outputs of queries in Cypher are tables of records.
We want people to use Kùzu as an embeddable library in their Python scripts,
to do their modeling, querying, feature extraction,
cleaning, and other transformations, all by benefiting from a high-level query language
and state-of-art graph data management techniques
that we are implementing. This is exactly what DuckDB did for tabular data science/analytics.
We are looking at DuckDB here and want to fill the same gap for graph data science/analytics!
We are currently understanding the ecosystem better and appreciate feedback
and suggestions for features we should implement to enable your workloads.</p><p>OK, this is it for now. In the next two blog posts, I will discuss
factorization and worst-case optimal join algorithms and describe
some of the principles that we adopted in Kùzu&#x27;s query processor.
Until then, happy new years from the cold but cozy winter of 🇨🇦
and <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">pip install kuzu</a>!</p><div class="footnotes"><hr><ol><li id="fn-1-f6cc9d">Interestingly, Bachmann is one of a handful of Turing laureates without any academic career. If you love DBMSs, <a href="https://youtu.be/iDVsNqFEkB0" target="_blank" rel="noopener noreferrer">listen to this talk</a>  where he remembers his IDS days! Amusingly, he also talks about how he didn&#x27;t know who Turing was when got the Turing award and how he met Turing&#x27;s mother in England for tea 😀.<a href="#fnref-1-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-2-f6cc9d">When I say GDBMSs here, I&#x27;m referring to the core engines that implement the high-level languages of these systems and not the analytics libraries (e.g., <a href="https://neo4j.com/product/graph-data-science/" target="_blank" rel="noopener noreferrer">1</a>, <a href="https://memgraph.com/mage" target="_blank" rel="noopener noreferrer">2</a>) above these core engines that run iterative graph analytics computations, such as finding connected components, or PageRank, or betweenness centrality. These computations are better understood through either direct graph formalisms or linear algebra (and not relational) operations.<a href="#fnref-2-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-3-f6cc9d">I am a strong supporter of devoting a few lectures to GDBMSs after covering the fundamental topics on the relational model and RDBMSs in core introduction to DBMSs courses in undergraduate curriculums. Students should broaden their perspectives on the available data models and query/programming languages to them when they develop applications. GDBMSs is an obvious choice here. So is Datalog and RDF/SparQL.<a href="#fnref-3-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-4-f6cc9d">We articulated this list of features in our CIDR 2023 paper. Incidentally, <a href="https://www.cidrdb.org/cidr2023/papers/p66-wolde.pdf" target="_blank" rel="noopener noreferrer">a paper</a> written by CWI on a graph query extension to DuckDB, had a 12-item list of &quot;techniques&quot; that GDBMSs should implement at their cores. Let me call this the CWI list. These items are not features in the sense I&#x27;m using the word, so I call them techniques. As you&#x27;ll see my features are higher-level system properties from user&#x27;s perspective. Peter Boncz, who is renowned in the field for having written or advised many successful DBMSs that spinned off, presented the CWI paper. I highly recommend this as another reading if you want to know more about Peter and his co-authors&#x27; technical insights about how GDBMSs should be architected. Importantly, Kùzu has integrated or is in the process of integrating 11 of the 12 techniques in the CWI list(bulk path finding is the one we have to do more thinking on) and our prior publications had also articulated many of these insights,  such as the fact that <a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf" target="_blank" rel="noopener noreferrer">GDBMSs should be columnar systems</a> doing vectorized querying and of course we did a ton of work on <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">worst-case optimal joins</a> and <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">factorization</a>, which are also in the CWI list. I should acknowledge that Peter had been advocating for some of the techniques on the CWI list at least since 2018. I remember a presentation he gave in 2018 to GDBMSs researchers and developers titled &quot;Why are Existing GDBMSs Incompetent?&quot;, which listed some of the techniques in the CWI list and visibly has inspired the title of this blog.<a href="#fnref-4-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-5-f6cc9d">Although some refer to these as an &quot;adjacency list index&quot; because that&#x27;s a common term in graph terminology, I need to pay my respects to the giants in the field: these are plain old <a href="https://dl.acm.org/doi/abs/10.1145/22952.22955" target="_blank" rel="noopener noreferrer">1980s Valduriez join indices</a>. And no, they were invented in the context of RDBMSs. That said, they never found much adoption in RDBMSs. But they are almost universally adopted in GDBMSs.<a href="#fnref-5-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-6-f6cc9d">Designing the schema, i.e., defining the types of entities and relationships and class structures and constraints of such complex domains can be decades of work. What I&#x27;m referring to as schema is called an &quot;ontology&quot; in knowledge graph/semantic web space. If you ever thought you modeled a hard application domain, take a look at <a href="https://en.wikipedia.org/wiki/SNOMED_CT" target="_blank" rel="noopener noreferrer">SNOMED</a>, which is a decades long effort to model and standardize human medical knowledge. Last term, I had a seminar on SNODEM in my graduate course on knowledge graphs and students were baffled by the complexity of this &quot;ontology&quot;, which  describes the types of entities and their relationships and constraints, which RDF technology stack is quite good at.<a href="#fnref-6-f6cc9d" class="footnote-backref">↩</a></li><li id="fn-7-f6cc9d">Before we released Kùzu, we had support for adding arbitrary node/edge properties but we removed a large chunk of code out of the system to release a thinner code base. So currently you need to specify a schema for your nodes and relationships in Kùzu. We will wait and see if/when that demand comes and how strongly it comes. We know from our conversations with many users and developers of GDBMSs over the years that most datasets in enterprises are not this complex and can be structured. At least after a proof of concept phase of applications, developers structure their data.<a href="#fnref-7-f6cc9d" class="footnote-backref">↩</a></li></ol></div></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docusaurus/blog/tags/vision">vision</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docusaurus/blog/factorization"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Factorization &amp; Great Ideas from Database Theory</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docusaurus/blog/meet-kuzu"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Meet Kùzu 🤗</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#overview-of-gdbmss-and-a-bit-of-history" class="table-of-contents__link toc-highlight">Overview of GDBMSs and a Bit of History</a></li><li><a href="#features-every-competent-gdbms-should-optimize-for-" class="table-of-contents__link toc-highlight">Features Every Competent GDBMS Should Optimize For </a><ul><li><a href="#feature-1-pre-definedpointer-based-joins" class="table-of-contents__link toc-highlight">Feature 1: Pre-defined/pointer-based Joins</a></li><li><a href="#feature-2-many-to-many-growing-joins" class="table-of-contents__link toc-highlight">Feature 2: Many-to-many Growing Joins</a></li><li><a href="#feature-3-recursive-join-queries" class="table-of-contents__link toc-highlight">Feature 3: Recursive Join Queries</a></li><li><a href="#feature-4-schema-querying" class="table-of-contents__link toc-highlight">Feature 4: Schema Querying</a></li><li><a href="#feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs" class="table-of-contents__link toc-highlight">Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., &quot;Knowledge Graphs&quot;)</a></li></ul></li><li><a href="#kùzu-as-a-gdbms-for-graph-data-science-pipelines" class="table-of-contents__link toc-highlight">Kùzu as a GDBMS for Graph Data Science Pipelines</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" target="_blank" rel="noopener noreferrer" class="footer__link-item">Slack<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/kuzudb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.youtube.com/@KuzuDB" target="_blank" rel="noopener noreferrer" class="footer__link-item">YouTube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://space.bilibili.com/410352593" target="_blank" rel="noopener noreferrer" class="footer__link-item">Bilibili<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docusaurus/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Kùzu Team. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docusaurus/assets/js/runtime~main.3f6fcfe5.js"></script>
<script src="/docusaurus/assets/js/main.2d80c558.js"></script>
</body>
</html>