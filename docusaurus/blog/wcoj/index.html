<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms | Kùzu</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" property="og:url" content="https://kuzudb.com/docusaurus/blog/wcoj"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="og:locale" content="en_US"><meta data-rh="true" name="og:type" content="article"><meta data-rh="true" name="og:site_name" content="Kùzu"><meta data-rh="true" name="og:image" content="https://kuzudb.com/img/logo-u-with-orange-tick.jpg"><meta data-rh="true" name="twitter:card" content="summary"><meta data-rh="true" name="twitter:site" content="@kuzudb"><meta data-rh="true" name="twitter:creator" content="@kuzudb"><meta data-rh="true" name="twitter:image" content="https://kuzudb.com/img/logo-u-with-orange-tick.jpg"><meta data-rh="true" property="og:title" content="Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms | Kùzu"><meta data-rh="true" name="description" content="Joins of a sets of records is objectively the most expensive operation in DBMSs."><meta data-rh="true" property="og:description" content="Joins of a sets of records is objectively the most expensive operation in DBMSs."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-02-22T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://cs.uwaterloo.ca/~ssalihog/"><meta data-rh="true" property="article:tag" content="internals"><link data-rh="true" rel="icon" href="/docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kuzudb.com/docusaurus/blog/wcoj"><link data-rh="true" rel="alternate" href="https://kuzudb.com/docusaurus/blog/wcoj" hreflang="en"><link data-rh="true" rel="alternate" href="https://kuzudb.com/docusaurus/blog/wcoj" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://XV0PE3XW33-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/docusaurus/blog/rss.xml" title="Kùzu RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docusaurus/blog/atom.xml" title="Kùzu Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Kùzu" href="/docusaurus/opensearch.xml">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/docusaurus/assets/css/styles.a72d597a.css">
<link rel="preload" href="/docusaurus/assets/js/runtime~main.67b2cda9.js" as="script">
<link rel="preload" href="/docusaurus/assets/js/main.2d80c558.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://kuzudb.com/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/docusaurus/img/kuzu-logo.png" alt="Kùzu" class="themedImage_ToTc themedImage--light_HNdA"><img src="/docusaurus/img/kuzu-logo-inverse.png" alt="Kùzu" class="themedImage_ToTc themedImage--dark_i4oU"></div></a><a class="navbar__item navbar__link" href="/docusaurus/installation">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docusaurus/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item">
            <a href="https://github.com/kuzudb/kuzu" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-github fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-slack fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://twitter.com/kuzudb" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-twitter fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://www.youtube.com/@KuzuDB" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-youtube fa-xl"></i>
            </a>
            </div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.7-release">Kùzu 0.0.7 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/iamgraphviz">IAMGraphViz: Visualizing AWS IAM Permissions with Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.6-release">Kùzu 0.0.6 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.5-release">Kùzu 0.0.5 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.4-release">Kùzu 0.0.4 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-pyg-remote-backend">Scaling Pytorch Geometric GNNs With Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.3-release">Kùzu 0.0.3 Release</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/docusaurus/blog/wcoj">Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.2-release">Kùzu 0.0.2 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/factorization">Factorization &amp; Great Ideas from Database Theory</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/meet-kuzu">Meet Kùzu 🤗</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-02-22T00:00:00.000Z" itemprop="datePublished">February 22, 2023</time> · <!-- -->21 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://cs.uwaterloo.ca/~ssalihog/" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://kuzudb.com/img/blog/semih.jpg" alt="Semih Salihoğlu"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://cs.uwaterloo.ca/~ssalihog/" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Semih Salihoğlu</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>Joins of a sets of records is objectively the most expensive operation in DBMSs.
In my previous post on <a href="/docusaurus/blog/factorization">factorization</a>, I said that in the field of databases, once
in a while you run into a very simple idea that deviates from the norm that gets you very excited.
Today, I will discuss another such idea, worst-case optimal join (wcoj) algorithms.
Wcoj algorithms and the theory around it in one sentence says this:</p><ul><li>Queries involving complex &quot;cyclic joins&quot; over many-to-many relationships should be
evaluated column at a time instead of table at a time, which is the norm. </li></ul><p>Wcoj algorithms find their best applications when finding cyclic patterns on graphs,
such as cliques or cycles, which is common in the workloads of fraud detection and
recommendation applications. As such, they should be integrated into every graph DBMS
(and possibly to RDBMSs) and I am convinced that they eventually will.</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>History of Wcoj Algorithms:</strong> Research on wcoj algorithms started with a solution to open question
about the maximum sizes of join queries. This result made researchers realize this: the traditional
&quot;binary join plans&quot; paradigm of generating query plans that join 2 tables a time
until all of the tables in the query are joined is provably
suboptimal for some queries. Specifically, when join queries are
cyclic, which in graph terms means when the searched graph pattern has cycles
in it, and the relationships between records are many-to-many, then this
paradigm can generate unnecessarily large amounts of intermediate results.</li><li><strong>Core Algorithmic Step of Wcoj Algorithms:</strong>  Wcoj algorithms fix this sub-optimality by
performing the joins one column at a time (instead of 2 tables at a time) using multiway intersections.</li><li><strong>How Kùzu Integrates Wcoj Algorithms:</strong> Kùzu generates plans that seamlessly mix binary joins
and wcoj-style multiway intersections. Multiway intersections are performed by an operator called
&quot;multiway HashJoin&quot;, which has one or more build phases that creates one or more hash tables that stores
sorted adjacency lists; and a probe phase that performs multi-way intersections using the sorted lists.</li><li><strong>Yes, the Term &quot;Worst-case Optimal&quot; Is Confusing Even to Don Knuth:</strong> I know, Don Knuth also found the term
&quot;worst-case optimal&quot; a bit confusing. See my <a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">anecdote on this</a>.
It basically means that the worst-case runtimes of these algorithms are asymptotically optimal.</li></ul></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="joins-running-example--traditional-table-at-a-time-joins">Joins, Running Example &amp; Traditional Table-at-a-time Joins<a href="#joins-running-example--traditional-table-at-a-time-joins" class="hash-link" aria-label="Direct link to Joins, Running Example &amp; Traditional Table-at-a-time Joins" title="Direct link to Joins, Running Example &amp; Traditional Table-at-a-time Joins">​</a></h2><p>Joins are objectively the most expensive and powerful operation in DBMSs.
In SQL, you indicate them in the FROM clause by listing
a set of table names, in Cypher in the MATCH clause, where you draw a graph pattern
to describe how to join node records with each other.
As a running example, consider a simple social network of users and followers,
whose node-link diagram is shown below. I am also showing the table that contains these records
in a <code>User</code> (ignore the <code>name</code> property for now) and <code>Follows</code> tables.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-running-ex-data-cba423e4b308520aec94e4553da2914c.png" class="img_ev3q"></div><p>Consider finding triangles, which is one of the simplest
forms of cycles and cliques, in this network. The SQL and Cypher
versions of this query are shown below. </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SQL:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM  Follows f1, Follows f2, Follows f3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE f1.dst=f2.src AND f2.dst=f3.src AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      f3.dst = f1.src</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Cypher:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:User)-[f1:Follows]-&gt;(b:User)-[f2:Follows]-&gt;(c:User)-[f3:Follows]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN  *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That long MATCH clause &quot;draws&quot; a triangle and for our case here, this is equivalent
to joining three copies of the Follows table. </p><p>Now ever since the System R days and <a href="https://courses.cs.duke.edu/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf" target="_blank" rel="noopener noreferrer">Patricia Selinger&#x27;s 1979 seminal paper</a> that
described how System R compiled and optimized SQL queries, there has been an
unchallenged dogma in DBMSs that the joins specified in the query would be
evaluated pairwise, table at a time.
Here&#x27;s a blurb from Selinger&#x27;s paper, where one can see this
assumption:
&quot;<em>In System R a user need not know how the
tuples are physically stored ... Nor does a user
specify in what order joins are to be performed. The System
R optimizer chooses both join order and ...</em>&quot;
To this day, this is the norm. DBMSs pick a &quot;join order&quot; which is the order in
which the tables should be joined iteratively 2 at a time.
In the above example, for example
there are three possible join orders. One way to represent these orders is by
writing different parenthesization of the joins: </p><ul><li>(i) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F2) \bowtie F3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>; (ii) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mo stretchy="false">(</mo><mi>F</mi><mn>2</mn><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F1 \bowtie (F2 \bowtie F3))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">))</span></span></span></span></span>;
and (iii) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F3) \bowtie F2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span>. </li></ul><p>The optimization problem for a system is of course more complex than just
ordering tables because the system also has to choose which
binary join algorithm to use when joining each pair of tables, e.g., hash joins vs merge joins.
But take any system you want, and they will all follow the same paradigm of
joining 2 base or intermediate tables iteratively, until all tables are joined:
hence the term <em>binary joins</em> to describe the plans of existing systems.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-math-puzzle-that-started-it-all">A Math Puzzle That Started it All<a href="#a-math-puzzle-that-started-it-all" class="hash-link" aria-label="Direct link to A Math Puzzle That Started it All" title="Direct link to A Math Puzzle That Started it All">​</a></h2><p>So, what&#x27;s the problem with binary join plans? When join queries are cyclic
and the relationships are many-to-many, they can generate provably large amounts
of (so unnecessary in a formal sense) intermediate results. First, cyclicity for
join queries has formal (and a bit intimidating) definitions but if you think of
graph patterns, it simply means that the searched pattern&#x27;s undirected version has
cycles. Why do binary joins generate unnecessarily large intermediate results? I&#x27;ll
get to this below but first a bit of history on the origins of this insight.
The whole topic of &quot;worst-case optimal joins&quot; started with 2 papers, a <a href="https://arxiv.org/abs/1711.04506" target="_blank" rel="noopener noreferrer">2007 SODA</a>
and a <a href="https://arxiv.org/abs/1711.03860" target="_blank" rel="noopener noreferrer">2008 FOCS</a>
paper, which are top venues in algorithms and theory. In these papers,
several theoreticians solved a fundamental open question
about join queries. Suppose I give you:</p><ol><li>An arbitrary natural join query, say of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span> relations. In DBMS literature we denote such
queries as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>R</mi><mn>1</mn><mo stretchy="false">(</mo><msub><mi>a</mi><mn>11</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>r</mi><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>⋈</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⋈</mo><mi>R</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>r</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q=R1(a_{11}, ..., a_{r1}) \bowtie ... \bowtie Rm(a_{m1}, ..., a_{rm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.</li><li>Sizes of R1, ..., Rm, e.g., for simplicity assume they all have <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many tuples. </li></ol><p>&quot;Natural&quot; here means that the join predicates are equality predicates on identical column
names. You, as the second person in this puzzle, are allowed to set the values inside these relations.
<strong>The open question was: how large can you make the final output?</strong> So for example, if I told you that there are
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many tuples in the <code>Follows</code> tables, what is the maximum number of triangle outputs there can  be?<sup id="fnref-1-627daf"><a href="#fn-1-627daf" class="footnote-ref">1</a></sup>
Even more concretely for the triangle query, the question is: out of all possible graphs with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> many edges,
what is the maximum number of triangles they contain?</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-edge-covers-35e349b3d28dc29585b69a3173b820da.png" class="img_ev3q"></div><p>It still surprises me that the answer to this question was not known until 2008.
It just looks like a fundamental question someone in databases must have answered before.
Now excuse me for bombarding your brains with some necessary math definitions.
These two papers showed that the answer is: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><msup><mi>ρ</mi><mo>∗</mo></msup></msup></mrow><annotation encoding="application/x-tex">IN^{\rho^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8973em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8973em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ρ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\rho^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> is a property
of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span></span></span></span></span> called the <em>fractional edge cover number</em> of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span></span></span></span></span>.
This is the solution to
an optimization problem and best explained by thinking about the &quot;join query graph&quot;,
which, for our purposes, is the triangle graph pattern (ignoring the edge directions), shown
in Fig 2a and 2b.</p><p>The optimization problem is this:
put a weight between <!-- -->[0, 1]<!-- --> to
each &quot;query edge&quot; such that each &quot;query node&quot; is &quot;covered&quot;, i.e., the sum of
the query edges touching each query node is &gt; 1. Each such solution is called an
edge cover. The problem is to find the edge cover whose total weight is the minimum. That is
called the fractional edge cover number of the query. For the triangle query,
one edge cover, shown in Fig 2a, is <!-- -->[1, 1, 0]<!-- -->, which has
a total weight of 1 + 1 + 0 = 2.
The minimum weight edge cover is <!-- -->[1/2, 1/2, 1/2]<!-- -->, shown in Fig 2b,
with a total weight  of 1.5. Therefore, the fractional edge cover number <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ρ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\rho^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>
of the triangle query is 1.5.
In general, each edge cover is an upper bound but the FOCS paper showed
that the fractional edge cover number is the tight upper bound.
So the maximum number of triangles there can be on a graph with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">IN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> edges is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(IN^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
and this is tight, i.e., there are such graphs. Nice scientific progress!
Nowadays, the quantity <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><msup><mi>ρ</mi><mo>∗</mo></msup></msup></mrow><annotation encoding="application/x-tex">IN^{\rho^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8973em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8973em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> is known as the <code>AGM bound</code> of a query,
after the first letters of the last names of the authors of the FOCS paper.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="problem-with-table-at-a-timebinary-joins">Problem With Table-at-a-time/Binary Joins<a href="#problem-with-table-at-a-timebinary-joins" class="hash-link" aria-label="Direct link to Problem With Table-at-a-time/Binary Joins" title="Direct link to Problem With Table-at-a-time/Binary Joins">​</a></h2><p>Now this immediately made the same researchers realize that binary join plans are
provably sub-optimal because they can generate polynomially more intermediate results
than the AGM bound of the query. This happens because on cyclic queries,
the strategy of joining tables
2 at a time may lead to unnecessarily computing some acyclic sub-joins.
For example, in the triangle query, the plan
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo><mo>⋈</mo><mi>F</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((F1 \bowtie F2) \bowtie F3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> first computes <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mn>1</mn><mo>⋈</mo><mi>F</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F1 \bowtie F2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> sub-join,
which in graph terms computes the 2-paths in the graph.
This is a problem because often there can be many more of these acyclic sub-joins
than there can be outputs for the cyclic join.
For this plan, there can
be <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">IN^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> many 2-paths (which is the AGM bound of 2-paths),
which is polynomially larger than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup></mrow><annotation encoding="application/x-tex">IN^{1.5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span></span></span></span></span>.
For example in our running example, there are 1000<!-- -->*<!-- -->1000 = 1M many 2 paths,
but on a graph with 2001 edges there can be at most 89.5K triangles (well ours
has only 3 triangles (because the triangle query we are using is symmetric
the sole triangle would generate 3 outputs for 3 rotations of it)).</p><p>Any other plan in this case would have generated <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">IN^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> many 2-paths,
so there is no good binary join plan here. I want to emphasize that this sub-optimality does not occur
when the queries are acyclic or when the dataset does not have
many-to-many relationships. If the joins were primary-foreign key non-growing joins,
then binary join plans will work just fine. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solution-column-at-a-time-worst-case-optimal-join-algorithms">Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms<a href="#solution-column-at-a-time-worst-case-optimal-join-algorithms" class="hash-link" aria-label="Direct link to Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms" title="Direct link to Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms">​</a></h2><p>So the immediate
next question is: are there algorithms whose runtimes can be bounded by
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(IN^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>? If so, how are they different? The answer to this question
is a bit anti-climactic. The core idea existed in the 2007 SODA and 2008 FOCS papers,
though it was refined more ~4 years later in some theoretical papers
by <a href="https://hung-q-ngo.github.io/" target="_blank" rel="noopener noreferrer">Hung Ngo</a>, <a href="https://u.cs.biu.ac.il/~porat/" target="_blank" rel="noopener noreferrer">Ely Porat</a>,
<a href="https://cs.stanford.edu/~chrismre/" target="_blank" rel="noopener noreferrer">Chris Ré</a>, and <a href="https://cse.buffalo.edu/faculty/atri/" target="_blank" rel="noopener noreferrer">Atri Rudra</a>
in the database fields <a href="https://dl.acm.org/doi/10.1145/2213556.2213565" target="_blank" rel="noopener noreferrer">PODS</a> and
<a href="https://dl.acm.org/doi/10.1145/2590989.2590991" target="_blank" rel="noopener noreferrer">SIGMOD Record</a>. The answer is simply
to perform the join column at a time, using multiway
intersections. &quot;Intersections of what?&quot; you should be asking.
For joins over arbtrary relations, we need special indices but I want to
skip this detail.
In the context of GDBMSs, GDBMSs already
have join indices (aka adjacency list indices) and for the common joins
they perform, this will be enough for our purposes.</p><p>I will next demonstrate a wcoj
algorithm known as &quot;Generic Join&quot; from the <a href="https://dl.acm.org/doi/10.1145/2590989.2590991" target="_blank" rel="noopener noreferrer">SIGMOD Record paper</a>.
It can be seen as the simplest of all wcoj algorithms.
As &quot;join order&quot;, we will pick a &quot;column order&quot;
instead of Selinger-style table order. So in our triangle query,
the order could be a,b,c. Then we will build indices over each relation
that is consistent with this order. In our case there are conceptually three (identical)
relations: <code>Follows1(a, b)</code>, <code>Follows2(b, c)</code>, <code>Follows3(c, a)</code>. For <code>Follows1</code>,
we need to be able to read all <code>b</code> values for a given <code>a</code> value (e.g., <code>a=5</code>).
In graph terms, this just means that we need &quot;forward join index&quot;.
For <code>Follows3</code>, because <code>a</code> comes earlier than <code>c</code>, we will want an index
that gives us <code>c</code> values for a given <code>a</code> value. This is equivalent to a
&quot;backward join index&quot;. In graphs, because joins happen through the
relationship records, which can, for the purpose of the joins,
be taught of as a binary relation (src, dst), 2 indices is enough
for our purposes. On general relations, one may need many more indices.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-gj-simulation-fa62f030f92938f86bccfef623730795.png" style="width:600px" class="img_ev3q"></div><p>We will iteratively find: (i) all <code>a</code> values
that can be in the final triangles; (ii) all <code>ab</code>&#x27;s that be in the final
triangles; and (iii) all <code>abc</code>&#x27;s, which are the triangles. Let&#x27;s simulate the computation:</p><ul><li>Step 1: Find all <code>a</code>&#x27;s. Here we will just take
all nodes as possible a values. This is shown under &quot;Step 1&quot; in the above figure.</li><li>Step 2: For each a value, e.g., a=1, we extend it to find all <code>ab</code>&#x27;s that
can be part of triangles: Here we use the forward index to look up all
<code>b</code> values for node with ID 1. So on and so forth. This will generate the
second intermediate relation.</li><li>Step 3: For each <code>ab</code> value, e.g., the tuple (a=1 b=0), we will
intersect all <code>c</code>&#x27;s with <code>a</code>=1, and all <code>c</code>&#x27;s with <code>b</code>=0. That is, we will intersect
the backward adjacency list of the node with ID 1, and forward adjacency list of
the node with ID 0. If the intersection is non-empty, we produce some triangles.
In this case, we will produce the triangle (<code>a</code>=1, <code>b</code>=0, <code>c</code>=1001)
The result of this computation will produce the third and final
output table in the figure.</li></ul><img loading="lazy" align="right" style="width:200px;padding-left:3px" src="/docusaurus/assets/images/wcoj-4-clique-7f96dfbbc1f31fd9ff502128749eb055.png" class="img_ev3q">Note that this process did not produce the 2-paths as an intermediate step, which is how wcoj algorithms fix for the sub-optimality of binary join algorithms. If your query was more complex then a wcoj algorithm can do k-way intersections where k &gt; 2. For example on the 4-clique query shown on the right, suppose the column order is abcd, then given abc triangles, we would do a 3-way intersection of forward index of a&#x27;s, backward index of b&#x27;s, and forward index of c&#x27;s, to complete the triangles to joins. This type of multiway intersections is the necessary algorithmic step to be efficient on cyclic queries.<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-kùzu-performs-worst-case-optimal-join-algorithms">How Kùzu Performs Worst-case Optimal Join Algorithms:<a href="#how-kùzu-performs-worst-case-optimal-join-algorithms" class="hash-link" aria-label="Direct link to How Kùzu Performs Worst-case Optimal Join Algorithms:" title="Direct link to How Kùzu Performs Worst-case Optimal Join Algorithms:">​</a></h2><p>Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a> describes this in detail, so I will be brief here.
First, Kùzu mixes binary joins and wcoj-like multiway intersections
following some principles that my PhD student <a href="http://amine.io/" target="_blank" rel="noopener noreferrer">Amine Mhedhbi</a>
had worked quite hard on early in his PhD. I recommend these two papers,
one by <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf" target="_blank" rel="noopener noreferrer">Amine and me</a>
and one by the <a href="https://db.in.tum.de/~freitag/papers/p1891-freitag.pdf" target="_blank" rel="noopener noreferrer">Umbra group</a>
on several different ways people have proposed for mixing binary and wcoj algorithms in query plans.
Overall message of these studies is that, wcoj are critical when the query has a very cyclic component
and multiway intersections can help. If the query does not have this property,
systems should just use binary joins.
So wcoj-like computations should be seen as complementing binary join plans.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/wcoj-kuzu-multiway-hash-join-a88a24d208d62d3d41d7475f5c15596a.png" style="width:600px" class="img_ev3q"></div><p>Second, Kùzu performs multiway intersections in a <em>Multiway HashJoin</em> operator.
In our CIDR paper we call this operator Multiway ASPJoin. It can be thought
of a modified hash-join operator where we use multiple hash tables and do
an intersection to produce outputs as I will simulate.
Let me change the query a little and add a filter on <code>a.name = Noura</code>,
where <code>name</code> is the primary key of <code>User</code> records. You can see from Fig 1a
that Noura is the primary key of node with ID 1. In my simulation,
the Multiway HashJoin operator will take <code>ab</code> tuples and extend them
to <code>abc</code> tuples through a 2-way intersection. In general multiway HashJoin
has 3 phases: 1 accumulate phase, build phases to build k-2 hash tables,
and a probe phase. Here are the steps.</p><ul><li>Step 1 - Accumulate Phase: The operator receives the <code>ab</code> tuples which will be extended
to triangles. This allows the system to see exactly
the forward/backward lists of which nodes will be intersected. Then, the operator passes
this information sideways to only scan those lists. In this case,
because there is a primary key filter on Noura, the only <code>ab</code> tuple that will be read
is (a=1,b=0). This is stored in a temporary buffer that we call &quot;Factorized Table&quot; in the system.</li><li>Step 2 - Build Phase 1: In the first build step, Multway HashJoin will pass a nodeID filter
to the <code>Scan Follows (a)&lt;-(c)</code> operator with only 1=true for node ID 1, and 0 for every other node ID.
The operator can do this because at this stage the operator knows exactly which backward
adjacency lists will be needed when we extend the tuple (in this case only node with ID 1&#x27;s
backward list is needed). The Scan operator uses this node ID filter to scan only this backward list,
{1001}, and avoids
scanning the rest of the file that stores the backwards Follows edges. This list is first sorted
based on the IDs of the neighbor IDs and stored in a hash table, denoted as &quot;Hash Table (a)&lt;-(c)&quot;
in the figure.</li><li>Step 3 - Build Phase 2: This is similar to Build phase 1. Using a semijoin filter
with node 0&#x27;s ID, we scan only node 2&#x27;s forward <code>Follows</code> list {1001, 1002, ..., 2000},
sort it, and then store in a hash table &quot;Hash Table (b)-&gt;(c)&quot;.</li><li>Step 4 - Probe: We re-scan the accumulated <code>ab</code> tuples from the factorized table.
For each tuple, we first probe &quot;Hash Table (a)&lt;-(c)&quot;
and then &quot;Hash Table (b)-&gt;(c)&quot; to fetch two lists, intersect them, and produce outputs.
In this case there is only one tuple (a=1, b=0), so we will fetch a=1&#x27;s backward list and b=0&#x27;s forward list,
intersect these lists, and produce the triangle (a=1, b=0, c=1001).</li></ul><p>This performs quite well. Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a> has some performance numbers
comparing against other types of WCO joins implementations (see the experiments in Table 3). Since I did not cover other ways to implement
wco join algorithms inside DBMSs, these experiments would be difficult to explain here.
Instead, let me just demonstrate some simple comparisons between using binary joins and wco joins
in Kùzu on a simple triangle query. On larger cyclic queries, e.g., 4- or 5- cliques,
the differences are much larger and often binary join plans do not finish on time.
You can try this experiment too. </p><p>Here is the configuration. The dataset I&#x27;m using
is a popular web graph that is used in academic papers called <a href="https://snap.stanford.edu/data/web-BerkStan.html" target="_blank" rel="noopener noreferrer">web-BerkStan</a>.
It has 685K nodes and 7.6M edges.
I modeled these as a simple <code>Page</code> nodes and <code>Links</code> edges.</p><p>I start Kùzu on my own laptop, which is a Macbook Air 2020 with Apple M1 chip, 16G memory,
and 512GB SSD, and run the following two queries (by default, Kùzu uses all thread available, which is 8 in this case):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Q1: Kùzu-WCO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Page)-[e1:Links]-&gt;(b:Page)-[e2:Links]-&gt;(c:Page)-[e3:Links]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This will compile plan that uses a wco Multiway HashJoin operator. I will refer to this
plan as Kùzu-WCO below. I am also running the following query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Q2: Kùzu-BJ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Page)-[e1:Links]-&gt;(b:Page)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WITH *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (b:Page)-[e2:Links]-&gt;(c:Page)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WIH *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (c)-[e3:Links]-&gt;(a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Currently Kùzu compiles each MATCH/WITH block separately so this is hack to force the system
to use binary join plan. The plan will join <code>e1</code> <code>Links</code> with <code>e2</code> <code>Links</code> and then
join the result of that with <code>e3</code> <code>Links</code>, all using binary HashJoin operator. I will
refer to this as Kùzu-BJ. Here are the results:</p><table><thead><tr><th>Configuration</th><th align="center">Time</th></tr></thead><tbody><tr><td>Kùzu-WCO</td><td align="center">1.62s</td></tr><tr><td>Kùzu-BJ</td><td align="center">51.17s</td></tr></tbody></table><p>There are ~41M triangles in the output. We see <strong>31.6x</strong> performance improvement in this simple query.
In larger densely cyclic queries, binary join plans just don&#x27;t work.</p><p>To try this locally, you can download our prepared CSV files from <a href="https://github.com/kuzudb/kuzudb.github.io/tree/main/data/web-berkstan" target="_blank" rel="noopener noreferrer">here</a>, and compile from our <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">latest master</a><sup id="fnref-2-627daf"><a href="#fn-2-627daf" class="footnote-ref">2</a></sup> (<code>make clean &amp;&amp; make release NUM_THREADS=8</code>).
Then start Kùzu&#x27;s shell, and load data into Kùzu:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./build/release/tools/shell/kuzu_shell -i web.db</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; CREATE NODE TABLE Page (id INT64, PRIMARY KEY(INT64));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; CREATE REL TABLE Links (FROM Page TO Page, MANY_MANY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; COPY Page FROM &#x27;web-node.csv&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kuzu&gt; COPY Links FROM &#x27;web-edge.csv&#x27;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, run those two queries (Kùzu-WCO and Kùzu-BJ) to see the difference!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">A Thank You &amp; an Anecdote About Knuth&#x27;s Reaction to the Term &quot;Worst-case Optimal&quot;<a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal" class="hash-link" aria-label="Direct link to A Thank You &amp; an Anecdote About Knuth&#x27;s Reaction to the Term &quot;Worst-case Optimal&quot;" title="Direct link to A Thank You &amp; an Anecdote About Knuth&#x27;s Reaction to the Term &quot;Worst-case Optimal&quot;">​</a></h2><p>Before wrapping up, I want to say thank you to <a href="https://cs.stanford.edu/~chrismre/" target="_blank" rel="noopener noreferrer">Chris Ré</a>, who is a
co-inventor of earliest wcoj algorithms.
In the 5th year of my PhD, Chris had introduced me to this area and
we had written a paper together on the topic in the context of evaluating
joins in distributed systems, such as MapReduce and Spark. I ended up working on
these algorithms and trying to make them performant in actual systems
for many more years than I initially predicted.
I also want to say thank you to <a href="https://hung-q-ngo.github.io/" target="_blank" rel="noopener noreferrer">Hung Ngo</a> and <a href="https://cse.buffalo.edu/faculty/atri/" target="_blank" rel="noopener noreferrer">Atri Rudra</a>,
with whom I have had several conversations during those years on these algorithms.</p><p>Finally, let me end with a fun story about the term &quot;worst-case optimal&quot;:
Several years ago <a href="https://uwaterloo.ca/computer-science/events/dls-donald-knuth-all-questions-answered" target="_blank" rel="noopener noreferrer">Don Knuth</a> was visiting UWaterloo
to give a Distinguished Lecture Seminar, which is our department&#x27;s most prestigious
lecture series. A colleague of mine and I had a 1-1 meeting with him.
Knuth must be known to anyone with a CS degree but importantly he is
credited for founding the field of algorithm analysis (e.g., for popularizing
the big-oh notation for analyzing algorithms&#x27; performances).
In our meeting, he asked me what I was working on
and I told him about these new algorithms called &quot;worst-case optimal join algorithms&quot;.
The term was so confusing to him and his immediate interpretation
was: &quot;Are they so good that they are optimal even in their worst-case performances?&quot; </p><p>The term actually means that the worst-case runtime of these algorithms
meets a known lower bound for the worst-case runtime of any join algorithm,
which is  <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>I</mi><msup><mi>N</mi><msup><mi>ρ</mi><mo>∗</mo></msup></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(IN^{\rho^*})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1473em;vertical-align:-0.25em"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8973em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.
Probably a more standard term would be to call them
&quot;asymptotically optimal&quot;, just like people call sort merge an asymptotically optimal
sorting algorithm under the comparison model.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-words">Final Words<a href="#final-words" class="hash-link" aria-label="Direct link to Final Words" title="Direct link to Final Words">​</a></h2><p>What other fundamental algorithmic developments have
been made in the field on join processing? It is surprising but there are still main gaps
in the field&#x27;s understanding of how fast joins can be processed.
There has been some very interesting
work in an area called <em>beyond worst-case optimal join algorithms</em>. These papers
ask very fundamental questions about joins, such as how can we prove that a join algorithm
is correct, i.e., it produces the correct output given its input?
The high-level answer is that each join algorithm must be producing a proof that its output is correct,
through the comparison operations it makes.
The goal of this line of research is to design practical algorithms whose implicit proofs are optimal,
i.e., as small as possible. This is
probably the most ambitious level of optimality one can go for in algorithm design.
There are already some algorithms, e.g., an algorithm called <a href="https://dl.acm.org/doi/pdf/10.1145/2967101" target="_blank" rel="noopener noreferrer">Tetris</a>. The area
is fascinating and has deep connections to computational geometry. I
advised a <a href="https://arxiv.org/abs/1909.12102" target="_blank" rel="noopener noreferrer">Master&#x27;s thesis</a> on the topic once and learned quite a bit about
computational geometry that I never thought could be relevant to my work. The current
beyond worst-case optimal join algorithms however are currently not practical.
Some brave souls need to get into the space and think hard about whether
practical versions of these algorithms can be developed. That would be very exciting.</p><p>This completes my 3-part blog on the contents of our CIDR paper and 2 core techniques:
<a href="/docusaurus/blog/factorization">factorization</a> and worst-case optimal join algorithms that we have integrated into
Kùzu to optimize for many-to-many joins. My goal in these blog
posts was to explain these ideas to a general CS/software engineering audience and
I hope these posts have made this material more approachable. My other goal
was to show the role of theory in advancing systems. Both of these ideas emerged from
pen-and-paper theory papers that theoreticians wrote but gave clear advice to DBMS developers.
As I said many times, I&#x27;m convinced that among many other techniques, these two
techniques need to be integral to any GDBMS that wants to be competitive in performance,
because queries with many-to-many joins are first-class-citizens in the workloads of these systems.</p><p>We will keep writing more blog posts in the later months about our new releases,
and other technical topics. If there are things you&#x27;d like us to write about,
please reach out to us! Also please give Kùzu a try, prototype applications with it,
break it, let us know of your performance or other bugs, so we can continue improving
it. Give us a <a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer">GitHub star</a> too and take care until the next posts!</p><div class="footnotes"><hr><ol><li id="fn-1-627daf">The question is interesting in the set semantics when you cannot pick every column value of every tuple the same value, which forces a Cartesian product of all the relations.<a href="#fnref-1-627daf" class="footnote-backref">↩</a></li><li id="fn-2-627daf">We found a minor bug in the latest release 0.0.2 when a node has a very large number of edges, which is fixed in the master branch, that&#x27;s why we suggest using the master branch.<a href="#fnref-2-627daf" class="footnote-backref">↩</a></li></ol></div></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docusaurus/blog/tags/internals">internals</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docusaurus/blog/kuzu-0.0.3-release"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Kùzu 0.0.3 Release</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docusaurus/blog/kuzu-0.0.2-release"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Kùzu 0.0.2 Release</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#joins-running-example--traditional-table-at-a-time-joins" class="table-of-contents__link toc-highlight">Joins, Running Example &amp; Traditional Table-at-a-time Joins</a></li><li><a href="#a-math-puzzle-that-started-it-all" class="table-of-contents__link toc-highlight">A Math Puzzle That Started it All</a></li><li><a href="#problem-with-table-at-a-timebinary-joins" class="table-of-contents__link toc-highlight">Problem With Table-at-a-time/Binary Joins</a></li><li><a href="#solution-column-at-a-time-worst-case-optimal-join-algorithms" class="table-of-contents__link toc-highlight">Solution: Column-at-a-time &quot;Worst-case Optimal&quot; Join Algorithms</a></li><li><a href="#how-kùzu-performs-worst-case-optimal-join-algorithms" class="table-of-contents__link toc-highlight">How Kùzu Performs Worst-case Optimal Join Algorithms:</a></li><li><a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal" class="table-of-contents__link toc-highlight">A Thank You &amp; an Anecdote About Knuth&#39;s Reaction to the Term &quot;Worst-case Optimal&quot;</a></li><li><a href="#final-words" class="table-of-contents__link toc-highlight">Final Words</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" target="_blank" rel="noopener noreferrer" class="footer__link-item">Slack<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/kuzudb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.youtube.com/@KuzuDB" target="_blank" rel="noopener noreferrer" class="footer__link-item">YouTube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://space.bilibili.com/410352593" target="_blank" rel="noopener noreferrer" class="footer__link-item">Bilibili<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docusaurus/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Kùzu Team. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docusaurus/assets/js/runtime~main.67b2cda9.js"></script>
<script src="/docusaurus/assets/js/main.2d80c558.js"></script>
</body>
</html>