<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Factorization &amp; Great Ideas from Database Theory | Kùzu</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" property="og:url" content="https://kuzudb.com/docusaurus/blog/factorization"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="og:locale" content="en_US"><meta data-rh="true" name="og:type" content="article"><meta data-rh="true" name="og:site_name" content="Kùzu"><meta data-rh="true" name="og:image" content="https://kuzudb.com/img/logo-u-with-orange-tick.jpg"><meta data-rh="true" name="twitter:card" content="summary"><meta data-rh="true" name="twitter:site" content="@kuzudb"><meta data-rh="true" name="twitter:creator" content="@kuzudb"><meta data-rh="true" name="twitter:image" content="https://kuzudb.com/img/logo-u-with-orange-tick.jpg"><meta data-rh="true" property="og:title" content="Factorization &amp; Great Ideas from Database Theory | Kùzu"><meta data-rh="true" name="description" content="Many of the core principles of how to develop DBMSs are well understood."><meta data-rh="true" property="og:description" content="Many of the core principles of how to develop DBMSs are well understood."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-01-20T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://cs.uwaterloo.ca/~ssalihog/"><meta data-rh="true" property="article:tag" content="internals"><link data-rh="true" rel="icon" href="/docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kuzudb.com/docusaurus/blog/factorization"><link data-rh="true" rel="alternate" href="https://kuzudb.com/docusaurus/blog/factorization" hreflang="en"><link data-rh="true" rel="alternate" href="https://kuzudb.com/docusaurus/blog/factorization" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://XV0PE3XW33-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/docusaurus/blog/rss.xml" title="Kùzu RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docusaurus/blog/atom.xml" title="Kùzu Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Kùzu" href="/docusaurus/opensearch.xml">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/docusaurus/assets/css/styles.a72d597a.css">
<link rel="preload" href="/docusaurus/assets/js/runtime~main.226ef243.js" as="script">
<link rel="preload" href="/docusaurus/assets/js/main.71e2b852.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://kuzudb.com/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/docusaurus/img/kuzu-logo.png" alt="Kùzu" class="themedImage_ToTc themedImage--light_HNdA"><img src="/docusaurus/img/kuzu-logo-inverse.png" alt="Kùzu" class="themedImage_ToTc themedImage--dark_i4oU"></div></a><a class="navbar__item navbar__link" href="/docusaurus/installation">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docusaurus/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item">
            <a href="https://github.com/kuzudb/kuzu" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-github fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-slack fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://twitter.com/kuzudb" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-twitter fa-xl"></i>
            </a>
            </div><div class="navbar__item">
            <a href="https://www.youtube.com/@KuzuDB" class="navbar__link navbar__link--social">
              <i class="fa-brands fa-youtube fa-xl"></i>
            </a>
            </div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzuexplorer">KùzuExplorer: Visualizing Query Results and Schemas</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.11-release">Kùzu 0.0.11 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.10-release">Kùzu 0.0.10 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.9-release">Kùzu 0.0.9 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.8-release">Kùzu 0.0.8 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.7-release">Kùzu 0.0.7 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/iamgraphviz">IAMGraphViz: Visualizing AWS IAM Permissions with Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.6-release">Kùzu 0.0.6 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.5-release">Kùzu 0.0.5 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.4-release">Kùzu 0.0.4 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-pyg-remote-backend">Scaling Pytorch Geometric GNNs With Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.3-release">Kùzu 0.0.3 Release</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/wcoj">Why (Graph) DBMSs Need New Join Algorithms: The Story of Worst-case Optimal Join Algorithms</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/kuzu-0.0.2-release">Kùzu 0.0.2 Release</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/docusaurus/blog/factorization">Factorization &amp; Great Ideas from Database Theory</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docusaurus/blog/meet-kuzu">Meet Kùzu 🤗</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Factorization &amp; Great Ideas from Database Theory</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-01-20T00:00:00.000Z" itemprop="datePublished">January 20, 2023</time> · <!-- -->23 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://cs.uwaterloo.ca/~ssalihog/" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://kuzudb.com/img/blog/semih.jpg" alt="Semih Salihoğlu"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://cs.uwaterloo.ca/~ssalihog/" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Semih Salihoğlu</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>Many of the core principles of how to develop DBMSs are well understood.
For example, a very good query compilation paradigm is to
map high-level queries to a logical plan of relational operators, then optimize this plan,
and then further map it to an executable code often in the form of a physical query plan.
Similarly, if you want updates to a DBMS to be atomic and durable,
a good paradigm is to use a write-ahead log that serves as a source of truth
and can be used to undo or redo operations. Many systems adopt such common wisdom paradigms.
As core DBMS researcher, once in a while however, you run into a very simple idea
that deviates from the norm that gets you very excited.
Today, I want to write about one such idea called <a href="https://www.cs.ox.ac.uk/dan.olteanu/papers/os-sigrec16.pdf" target="_blank" rel="noopener noreferrer">factorization</a>. </p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>Tldr: The key takeaways are:</div><div class="admonitionContent_S0QG"><ul><li><strong>Overview of Factorization &amp; Why Every GDBMS Must Adopt It</strong>: Factorization
is a compression technique to compress the intermediate results
that query processors generate when evaluating many-to-many (m-n) joins.
Factorization can compress an intermediate result size exponentially
in the number m-n joins in the query.</li><li><strong>Example Benefits of Factorization</strong>: Benefits of keeping intermediate
results smaller reduces the computation processors perform
on many queries. Examples include reducing copies by keeping the output
data size small, reducing filter and expression evaluation computations exponentially,
and performing very fast aggregations.</li><li><strong>How Kùzu Implements Factorization:</strong> Kùzu&#x27;s query processor
is designed to achieve 3 design goals: (i) factorize intermediate results;
(ii) always perform sequential scans of database files; and (iii) avoid
scanning large chunks of database files when possible. In addition, the processor is
vectorized as in modern columnar DBMSs. These design goals are achieved by passing
multiple <em>factorized vectors</em> between each other and using modified HashJoin operators
that do <em>sideways information passing</em> to avoid scans of entire files.</li></ul></div></div><p>This is a quite technical and long blog post and will appeal more to people who are interested
in internals of DBMSs. It&#x27;s about a technique that&#x27;s quite dear to my heart called factorization,
which is a very
simple data compression technique. Probably all
compression techniques you know are designed to compress database files that
are stored on disk. Think of run-length encoding, dictionary compression, or bitpacking.
In contrast, you can&#x27;t use factorization to compress your raw database files.
Factorization has a very unique property:
it is designed to compress the intermediate
data that are generated when query processors of DBMSs evaluate
many-to-many (m-n) growing joins. If you have read <a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">my previous blog</a>,
efficiently handling m-n joins was one of the items on my list of properties
that competent GDBMSs should excel in. This is because
the workloads of GDBMSs commonly contain m-n joins
across node records. Each user in a social network or an account in a financial transaction network
or will have thousands of connections and if you want
a GDBMS to find patterns on your graphs, you are
asking queries with m-n joins. Factorization is directly designed
for these workloads and because of that every competent GDBMS must develop
a factorized query processor. In fact, if I were to try to write a new analytical RDBMS,
I would probably also integrate factorization into it.</p><p>This post forms the 2nd part of my 3-part posts on the contents of our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>
where we introduced Kùzu. The 3rd piece will be on another technique called worst-case
optimal join algorithms, which is also designed for a specific class of m-n joins.
Both in this post and the next, I have two goals. First is to try to articulate these techniques
using a language that is accessible to general software engineers.
Second, is to make people appreciate the role of
pen-and-paper theory in advancing the field of DBMSs. Both of these techniques were first
articulated in a series of purely theoretical papers which gave excellent
practical advice on how to improve DBMS performance.
Credit goes to the great theoreticians who pioneered these techniques whom I will cite
in these posts. Their work should be highly appreciated.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-quick-background-traditional-query-processing-using-flat-tuples">A Quick Background: Traditional Query Processing Using Flat Tuples<a href="#a-quick-background-traditional-query-processing-using-flat-tuples" class="hash-link" aria-label="Direct link to A Quick Background: Traditional Query Processing Using Flat Tuples" title="Direct link to A Quick Background: Traditional Query Processing Using Flat Tuples">​</a></h2><p>Here is a short background on the basics of
query processors before I explain factorization. If you know about
query plans and how to interpret them,
you can skip to <a href="#factorization-in-a-nutshell">here</a> after reading
my running example.
Consider a database of Account node and Transfer edge records below.
The two Accounts with <code>accID</code> fields L1 and L2 are owned by Liz and
each have 100 incoming and 100 outgoing Transfer edges.</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/2-hop-data-50098805289935a1f613617907dcb303.png" width="600" class="img_ev3q"></div><p>Now consider a 2-hop path query in Cypher returning the accID&#x27;s of source
and destinations of money flows Liz&#x27;s accounts are facilitating:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[t1:Transfer]-&gt;(b:Account)-[t2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = &#x27;Liz&#x27; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN a.accID, c.accID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here&#x27;s the SQL version of the query if you modeled your records as relations.
Same query different syntax:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT a.accID, c.accID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM Account a, Transfer t1, Account b, Transfer t2, Account c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = &#x27;Liz&#x27; AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      t1.src = a.accID AND t1.dst = b.accID AND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      t2.src = b.accID AND t2.dst = c.accID</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A standard query plan for this query is shown on the left in Fig. 2.
The plan contains some Scan operators to scan the raw node or edge records (edges could be
scanned from a join index) and some hash join operators to perform the joins, and
a final projection operator.
In some GDBMSs, you might see &quot;linear plans&quot; that look as in Fig. 3.</p><p><span><img loading="lazy" src="/docusaurus/assets/images/2-hop-query-plan-hash-join-1749ba183a543df750077e115557b565.png" style="width:50%" class="img_ev3q"></span><span><img loading="lazy" src="/docusaurus/assets/images/2-hop-query-plan-extend-4e1220b8e7fda83e9f20c611b4afb028.png" style="width:50%" class="img_ev3q"></span></p><p>The linear plan is from our previous GraphflowDB system. Here
you are seeing an operator called Extend, which joins node records with their Transfer relationships to
read the system-level IDs of the neighbors of those node records.
Following the Extend is another Join operator to join the accID properties of those neighbors
(specifically c.accID and a.accID).
In Neo4j, you&#x27;ll instead see an Expand(All) operator, which does the Extend+Join
in GraphflowDB in a single operator<sup id="fnref-1-10fd85"><a href="#fn-1-10fd85" class="footnote-ref">1</a></sup>. For very good reasons
we removed these Extend/Expand type operators in Kùzu. I will come back to this.</p><p>The interpretation of plans is that tuples are flowing from the bottom to top and
each operator will take in sets of tuples and produce sets of tuples (in a pipelined fashion).
The key motivation for factorization is that what flows
between operators are <strong>flat tuples</strong>. When the joins are m-n, this
leads to many data repetitions, which one way or another leads to repeated
computation in the operators. For example,
the final projection operator in our example would take the table shown in Figure 4 (left).</p><div class="img-center"><img loading="lazy" src="/docusaurus/assets/images/flat-vs-factorized-4a4ea855b7bda3921e29e9d05a2157f8.png" width="700" class="img_ev3q"></div><p>There are 20K tuples in the flat representation because both L1 and L2 are part of
100 incoming x 100 outgoing=10K many 2-paths. Notice the many repetitions in this relation:
L1, L2, or Liz values, or the values in a.accID and c.accID.
What gets replicated may change across systems. Some may replicate the actual values,
some may replicate indices where these values are stored but overall exactly 20K
tuples would be generated. This redundancy leads to redundant computation here and there
during query processing.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="factorization-in-a-nutshell">Factorization In a Nutshell<a href="#factorization-in-a-nutshell" class="hash-link" aria-label="Direct link to Factorization In a Nutshell" title="Direct link to Factorization In a Nutshell">​</a></h2><p>Factorization addresses exactly this problem. The core reason for the redundancy
is this observation: <em>given a fixed b value, all a&#x27;s and c&#x27;s are conditionally independent</em>.
More concretely, once b is bound to node L1, each incoming neighbor <code>a</code> for L1 will join
with each outgoing neighbor <code>c</code> of L1. If you took the first standard undergraduate course in DBMSs at a university
and you covered the theory of normalization, this is what is
called a <a href="https://en.wikipedia.org/wiki/Multivalued_dependency" target="_blank" rel="noopener noreferrer">multi-valued dependency</a>
in relations. Factorization exploits such dependencies to compress
relations using Cartesian products.
Above in Figure 4 (right),
I&#x27;m showing the same 20K tuples in a factorized format using only 400 values
(so 2<!-- -->*<!-- -->(100+100) instead of 2<!-- -->*<!-- -->100<!-- -->*<!-- -->100 values). </p><p>That&#x27;s it! That&#x27;s the core of the idea! Now of course, this simple observation leads to a ton of
hard and non-obvious questions that the entire theory on factorization answers. For example,
given a query, what are the &quot;factorization structures&quot;, i.e., the Cartesian product structures
that can be used to compress it? Consider a simple query that counts the number of
paths that are slightly longer:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Wire]-&gt;(b:Account)-[:Deposit]&gt;(c:Account)-[:ETransfer]-&gt;(d:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Should you condition on b and factor out
a&#x27;s from (c, d)&#x27;s or condition on c and factor out (a, b)&#x27;s from d&#x27;s?
Or you could condition on (b, c) and factor out (a)&#x27;s from (d)&#x27;s?
To make a choice, a system has to reason about the number of Wire, Deposit,
and ETransfer records in the database.
How much and on which queries can you benefit from factorization?
The theoretical questions are endless.
The theory of factorization develops the formal foundation so that such questions can be answered and
provides principled first answers to these questions.
<a href="https://www.ifi.uzh.ch/en/dast/people/Olteanu.html" target="_blank" rel="noopener noreferrer">Dan Olteanu</a> and his
colleagues, who lead this field, recently won the <a href="https://databasetheory.org/ICDT/test-of-time" target="_blank" rel="noopener noreferrer">ICDT test of time award</a>
for their work on factorization. ICDT is one of the two main
academic venues for theoretical work on DBMSs.</p><p>But let&#x27;s take a step back and appreciate this theory because it gives an excellent
advice to system developers: <em>factorize your intermediate
results if your queries contain many-to-many joins!</em>
Recall that GDBMSs most commonly evaluate many-to-many joins. So hence my point that
GDBMSs should develop factorized query processors.
The great thing this theory shows us is that this can all be done by static analysis of the query
during compilation time by only inspecting the dependencies between variables in
the query! I won&#x27;t cover the exact rules but at least in my running example,
I hope it&#x27;s clear that because there is no predicate between a&#x27;s and c&#x27;s, once
b is fixed, we can factor out a&#x27;s from c&#x27;s.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="examples-when-factorization-significantly-benefits">Examples When Factorization Significantly Benefits:<a href="#examples-when-factorization-significantly-benefits" class="hash-link" aria-label="Direct link to Examples When Factorization Significantly Benefits:" title="Direct link to Examples When Factorization Significantly Benefits:">​</a></h2><p>Factorized intermediate relations can be exponentially smaller
(in terms of the number of joins in the query)
than their flat versions, which
can yield orders of magnitude speed ups in query performance
for many different reasons. I will discuss three most obvious ones.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="less-data-copiesmovement">Less Data Copies/Movement<a href="#less-data-copiesmovement" class="hash-link" aria-label="Direct link to Less Data Copies/Movement" title="Direct link to Less Data Copies/Movement">​</a></h3><p>The most obvious benefit is that factorization reduces
the amount of data copied between buffers used by operators
during processing and to final <code>QueryResult</code> structure
that the application gets access to. For example, a very cool feature of Kùzu
is that it keeps final outputs in factorized format in its <code>QueryResult</code> class and
enumerates them one by one only when the user starts calling <code>QueryResult::getNext()</code>
to read the tuples.
In our running example, throughout processing Kùzu would do copies of
400 data values roughly instead of 20K to produce its <code>QueryResult</code>.
Needless to say, I could have picked a more exaggerated query, say a &quot;star&quot; query
with 6 relationships, and arbitrarily increased the difference in the copies done
between a flat vs factorized processor.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fewer-predicate-and-expression-evaluations">Fewer Predicate and Expression Evaluations<a href="#fewer-predicate-and-expression-evaluations" class="hash-link" aria-label="Direct link to Fewer Predicate and Expression Evaluations" title="Direct link to Fewer Predicate and Expression Evaluations">​</a></h3><p>Factorization can also reduce the amount of predicate or expression executions the system performs.
Suppose we modify our 2-hop query a bit and put two additional filters on the query:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1:Transfer]-&gt;(b:Account)-[e2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.name = &#x27;Liz&#x27; AND a.balance &gt; b.balance AND c.balance &gt; b.balance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN *</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>I&#x27;m omitting a plan for this query but a common plan would extend the plan in Figure 2 (or 3) above
to also scan the balance properties and to run two filter operations:
(i) above the join that joins a&#x27;s and b&#x27;s,
to run the predicate <code>a.balance &gt; b.balance</code>; (ii) after the final join in Figure 2
to run the predicate <code>c.balance &gt; b.balance</code>. Suppose the first filter did not eliminate any tuples.
Then, a flat processor would evaluate 20K filter executions in the second filter.
In contrast, the input to the second filter operator in a factorized processor
would be the 2 factorized tuples
shown in Figure 4 (right) but extended with <code>balance</code> properties
on a, b, and c&#x27;s. Therefore there would be only 200 filter executions: (i)
for the first factorized tuple, there are only
100 comparisons to execute <code>c.balance &gt; b.balance</code> since b is matched to a single
value and there are 100 c values.; (ii) similarly for the 2nd factorized tuple.
We can obtain similar benefits when running other expressions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="aggregations">Aggregations<a href="#aggregations" class="hash-link" aria-label="Direct link to Aggregations" title="Direct link to Aggregations">​</a></h3><p>This is perhaps where factorization yields largest benefits.
One can perform several aggregations directly on factorized tuples using
algebraic properties of several aggregation functions. Let&#x27;s
for instance modify our above query to a count(<!-- -->*<!-- -->) query: Find the number of 2-paths that Liz is
facilitating. A factorized processor can simply count that there are 100<!-- -->*<!-- -->100 flat tuples in the first
factorized tuple and similarly in the second one to compute that the answer is 20K.
Or consider doing min/max aggregation on factorized variables:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[e1:Transfer]-&gt;(b:Account)-[e2:Transfer]-&gt;(c:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.accID = &#x27;L1&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN max(a.balance), min(c.balance)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is asking: find the 2-path money flow that Liz&#x27;s L1 account facilitates from the highest
to lowest balance accounts (and only print the balances). If a processor
processes the 10K 2-paths that L1 is part of in factorized form, then
the processor can  compute the max and min aggregations
with only 100 comparisons each (instead of 10K comparisons each). </p><p>In short, the benefits of factorizing intermediate results just
reduces computation and data copies here and there in many cases.
You can try some of these queries on Kùzu and compare its performance on large
datasets with non-factorized systems. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-does-kùzu-perform-factorized-query-processing">How Does Kùzu Perform Factorized Query Processing?<a href="#how-does-kùzu-perform-factorized-query-processing" class="hash-link" aria-label="Direct link to How Does Kùzu Perform Factorized Query Processing?" title="Direct link to How Does Kùzu Perform Factorized Query Processing?">​</a></h2><p>The rest will be even more technical and forms part of the technical meat of our CIDR paper;
so continue reading if you are interested in database implementations.
When designing the query processor of Kùzu, we had 3 design goals: </p><ol><li>Factorize intermediate growing join results. </li><li>Always perform sequential scans of database files from disk.</li><li>When possible avoid scanning entire database files from disk.</li></ol><p>3rd design goal requires some motivation, which I will provide below. Let&#x27;s go one by one.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-factorization">1. Factorization<a href="#1-factorization" class="hash-link" aria-label="Direct link to 1. Factorization" title="Direct link to 1. Factorization">​</a></h3><p>Kùzu has a vectorized query processor, which is the common wisdom
in analytical read-optimized systems. </p><img loading="lazy" align="left" style="width:350px;padding-right:15px" src="/docusaurus/assets/images/factorized-vectors-fa0c388632af28cb8b3448fcdad3f8cf.png" class="img_ev3q">Vectorization, in the context of DBMS query processors refers to the design where operators pass a set of tuples, 1024 or 2048, between each other during processing[^2]. Existing vectorized query processors (in fact processors of all systems I&#x27;m aware of) pass *a single vector of flat tuples*. Instead, Kùzu&#x27;s operators pass (possibly) multiple *factorized vectors of tuples* between each other. Each vector  can either be *flat* and represent a single value or *unflat* and represent a set of values, which is marked in a field called `curIdx` associated with each vector. For example, the first 10K tuples from my running example would be represented with 3 factorized vectors as on the left and would be passed to the final projection in the query plan in Figure 2. The interpretation is this: what is passed is the Cartesian product of all sets of tuples in those vectors. Operators know during compilation time how many vector groups they will take in and how many they will output. Importantly, we still do vectorized processing, i.e., each primitive operator operates on a vector of values inside tight for loops. Credit where credit&#x27;s due: this simple-to-implement design was proposed by my PhD student [Amine Mhedhbi](http://amine.io/) with some feedback from me and my ex-Master&#x27;s student [Pranjal Gupta](https://www.linkedin.com/in/g31pranjal/?originalSubdomain=in) and [Xiyang Feng](https://www.linkedin.com/in/xingyang-feng-14198491/?originalSubdomain=ca), who is now a core developer of Kùzu. And we directly adopted it in Kùzu. Amine has continued doing other excellent work on factorization, which we have not yet integrated, and you will need to wait until his PhD thesis is out.<h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-ensuring-sequential-scans">2. Ensuring Sequential Scans<a href="#2-ensuring-sequential-scans" class="hash-link" aria-label="Direct link to 2. Ensuring Sequential Scans" title="Direct link to 2. Ensuring Sequential Scans">​</a></h3><p>I already told you above that
Extend/Expand type join operators lead to non-sequential scans of database files.
These operators are not robust and if you are developing a disk-based system:
non-sequential scans will kill you on many queries. That&#x27;s a mistake. Instead,
Kùzu uses (modified) HashJoins which are much more robust. HashJoins do not perform any scans
as part of the actual join computation so if the down stream scans
are sequential, you get sequential scans. I&#x27;ll give a simulation momentarily.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-avoiding-full-scans-of-database-files">3. Avoiding Full Scans of Database Files<a href="#3-avoiding-full-scans-of-database-files" class="hash-link" aria-label="Direct link to 3. Avoiding Full Scans of Database Files" title="Direct link to 3. Avoiding Full Scans of Database Files">​</a></h3><p>Although I don&#x27;t like Extend/Expand-type join operators,
they have a performance advantage. Suppose you had a simple 1-hop query that only asked for
the names of accounts that Liz&#x27;s L1 account has transfered money to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.accID = &#x27;L1&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN b.name</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Suppose your database has billions of transfers but L1 has made only 3 transfers to
accounts with system-level record/node IDs: 107, 5, and 15. Then if you had
a linear plan like I showed in Figure 3, then an Extend/Expand-type
operator could read these system-level IDs and then only scan
the name properties of these 3 nodes, avoiding the full scan of the names
of all Accounts. If your query needs to read neighborhoods of millions of nodes,
this type of  computation that &quot;reads the properties of each node&#x27;s neighbors&quot;
will degrade very quickly because: (i) each neighborhood
of each node will require reading
different parts of the disk files that store those properties; and (ii)
the system might repeatedly read the same properties over and over from disk,
as nodes share neighbors.
Instead, you want to
read all of the properties and create a hash table and read those properties
from memory.
However, if your query is accessing the neighborhoods of a few nodes,
then avoiding the scan of entire database file is an advantage.
In Kùzu, we wanted to use HashJoins but we also wanted a mechanism to scan
only the necessary parts of database files. We
do this through a technique called <em>sideways information passing</em><sup id="fnref-3-10fd85"><a href="#fn-3-10fd85" class="footnote-ref">3</a></sup>.
I&#x27;ll simulate this below.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-simple-simulation">A Simple Simulation<a href="#a-simple-simulation" class="hash-link" aria-label="Direct link to A Simple Simulation" title="Direct link to A Simple Simulation">​</a></h3><p>For simplicity, we&#x27;ll work on a simpler 1-hop query, so the benefits of factorization will not
be impressive but it will allow me to explain an entire query processing pipeline.
Consider this count(<!-- -->*<!-- -->) query that counts the number of transfers the L1 account has made:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Account)-[t1:Transfer]-&gt;(b:Account)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE a.accID = L1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN count(*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An annotated query plan we generate is shown below. The figure shows step by step
the computation that will be performed and the data that will be passed between operators.
For this simulation, I am assuming that the record/nodeIDs of Accounts are as in
Figure 1a above.</p><img loading="lazy" align="left" style="width:500px;padding-right:15px" src="/docusaurus/assets/images/factorized-execution-simulation-1b0f9917e3eead4cf85e02818fd579db.png" class="img_ev3q"><ol><li>A Scan operator will scan the accId column and find the records of
nodes with accID=L1. There is only 1 tuple (199, Liz) that will be output.</li><li>This tuple will passed to HashJoin&#x27;s build side, which will create a hash table from it.</li><li>At this point the processor knows exactly the IDs of nodes, whose Transfer edges need
to be scanned on the probe side: only the edges of node with ID 199! This is where we
do sideways information passing.
Specifically, the HashJoin constructs and passes a &quot;nodeID filter&quot; (effectively a bitmap)
to the probe side Scan operator. Here, I&#x27;m assuming the database has 1M Accounts but as you
can see only the position 199 is 1 and others are 0.</li><li>The probe-side Scan uses the filter to only scan
the edges of 199 and avoids
scanning the entire Transfers file.
Since Kùzu is a GDBMS, we store the edges of nodes (and their properties)
in a graph-optimized format called <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)" target="_blank" rel="noopener noreferrer">CSR</a>.
Importantly, all of the edges of 199 are stored consecutively and we output them in factorized format as:
<!-- -->[(199) X {201, 202, ..., 300}]<!-- -->.</li><li>Next step can be skipped in an optimized system but currently we will probe the <!-- -->[(199) X {201, 202, ..., 300}]<!-- -->
tuple in the hash table and produce <!-- -->[(199, L1) X {201, 202, ..., 300}]<!-- -->, which is passed to the
final aggregation operator.</li><li>The agggregation operator counts that there are 100 &quot;flat&quot; tuples in <!-- -->[(199, L1) X {201, 202, ..., 300}]<!-- -->, simply
by inspecting the size of the 2nd vector {201, 202, ..., 300} in the tuple.</li></ol><p>As you see the processing was factorized, we only did sequential scans
but we also avoided scanning the entire Transfer database file, achieving our 3 design goals.
This is a simplifid example and there are many queries that are more complex and where we
have more advanced modified hash join operators. But the simulation presents all core techniques
in the system. You can read our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf" target="_blank" rel="noopener noreferrer">CIDR paper</a>
if you are curious about the details!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="example-experiment">Example Experiment<a href="#example-experiment" class="hash-link" aria-label="Direct link to Example Experiment" title="Direct link to Example Experiment">​</a></h3><p>How does it all perform? Quite well! Specifically this type of processing is quite robust.
Here&#x27;s an experiment from our CIDR paper to give a sense of the behavior of
using modified hash joins and factorization on a micro benchmark query. This query
does a 2-hop query with aggregations on every node variable. This is on
an <a href="https://ldbcouncil.org/benchmarks/snb/" target="_blank" rel="noopener noreferrer">LDBC</a>
social network benchmark (SNB) dataset at scale factor 100 (so ~100GB of database). LDBC SNB
models a social network where user post comments and react to these comments. </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (a:Comment)&lt;-[:Likes]-(b:Person)-[:Likes]-&gt;(c:Comment)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE b.ID &lt; X</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN min(a.ID), min(b.ID), min(c.ID)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Needless to say, we are picking this as it is a simple query that can demonstrate
the benefits of all of the 3 techniques above. Also needless to say, we could have exaggerated
the benefits by picking
larger stars or branched tree patterns but this will do.
In the experiment we are changing the selectivity of the predicate on the middle node, which
changes the output size. What we will compare is the behavior of Kùzu, which integrates
the 3 techniques above with (i) Kùzu-Extend: A configuration of Kùzu that uses factorization but instead of
our modified HashJoins uses an Extend-like operator;
and (ii) <a href="https://umbra-db.com/" target="_blank" rel="noopener noreferrer">Umbra</a><sup id="fnref-4-10fd85"><a href="#fn-4-10fd85" class="footnote-ref">4</a></sup>, which represents the
state of the art RDBMS. Umbra is as fast as existing RDBMSs get. It probably integrates
every known low-level performance technique in the field.
Umbra however does not
do factorization or have a mechanism to avoid scanning entire database files, so we
expect it to perform poorly on the above query. </p><p>Here&#x27;s the performance table.</p><img loading="lazy" align="right" style="width:350px;padding-right:15px" src="/docusaurus/assets/images/2-hop-factorization-experiment-20c4be9f7a0f21358cd888fd15ba38a9.png" class="img_ev3q">When the selectivity is very low, Extend-like operators + factorization do quite well because they don&#x27;t yet suffer much from non-sequential scans and they avoid several overheads of our modified hash joins: no hash table creation and no semijoin filter mask creation. But they are not robust and degrade quickly. We can also see that even if you&#x27;re Umbra, without factorization or a mechanism to avoid scanning entire files, you will not perform very well on these queries with m-n joins (even if there is only 2 of them here). We conducted several other experiments all demonstrating the robustness and scalability of factorized processing using modified hash join operators. I won&#x27;t cover them but they are all in [our CIDR paper](https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf).<h2 class="anchor anchorWithStickyNavbar_LWe7" id="final-marks">Final marks:<a href="#final-marks" class="hash-link" aria-label="Direct link to Final marks:" title="Direct link to Final marks:">​</a></h2><p>I am convinced that modern GDBMSs have to be factorized systems to remain
competitive in performance. If your system assumes that most joins will be growing,
factorization is one of a handful of modern technique for such workloads
whose principles are relatively well understood
and one can actually implement in a system. I am sure different factorized query processors will
be proposed as more people attempt at it. I was happy to see in CIDR that at least 2 systems
gurus told me they want to integrate factorization into their systems.
If someone proposes a technique that can on some queries
lead to exponential computation reductions even in a pen-and-paper theory, it is a good sign
that for many queries it can make the difference between a system timing out vs providing
an actual answer.</p><p>Finally  there is much more on the theory of factorization, which I did not cover. From my side,
most interestingly, there
are even more compressed ways to represent the intermediate results than the
vanilla Cartesian product scheme I covered in this post. Just to raise some curiosity, what I have
in mind is called
<a href="https://fdbresearch.github.io/principles.html" target="_blank" rel="noopener noreferrer">d-representations</a> but that will have to wait
for another time. For now, I invite you to check our performance out on large queries
and let us know if we are slow on some queries! The Kùzu team says hi (👋 🙋‍♀️ 🙋🏽) and
is at your service to fix all performance bugs as we continue implementing the system!
My next post will be about the novel <a href="/docusaurus/blog/wcoj">worst-case optimal join algorithms</a>, which emerged
from another theoretical insight on m-n joins! Take care until then!</p><div class="footnotes"><hr><ol><li id="fn-1-10fd85">If you come from a very graph-focused background and/or exposed to a ton of GDBMS marketing, you might react to my statement that what I am showing are standard plans that do joins. Maybe you expected to see graph-specific operators, such as a BFS or a DFS operator because the data is a graph. Or maybe someone even dared to tell you that GDBMSs don&#x27;t do joins but they do traversals. Stuff like that. These word tricks and confusing jargon really has to stop and helps no one. If joins are in the nature of the computation  you are asking a DBMSs to do, calling it something else won&#x27;t change the nature of the computation. Joins are joins. Every DBMSs needs to join their records with each other.<a href="#fnref-1-10fd85" class="footnote-backref">↩</a></li><li id="fn-3-10fd85">Note that GDBMSs are able to avoid scans of entire files because notice that they do the join on internal record/node IDs, which mean something very specific. If a system needs to scan the name property of node with record/node ID 75, it can often arithmetically compute the disk page and offset where this is stored, because record IDs are dense, i.e., start from 0, 1, 2..., and so can serve as  pointers if the system&#x27;s storage design exploits this. This is what I was referring to as &quot;Predefined/pointer-based joins&quot; in my <a href="/docusaurus/blog/what-every-gdbms-should-do-and-vision">previous blog post</a>. This is a good feature of GDBMSs that allows them to efficiently evaluate the joins of node records that are happening along the &quot;predefined&quot; edges in the database. I don&#x27;t know of a mechanism where RDBMSs can do something similar, unless they develop a mechanism to convert value-based joins to pointer-based joins. See my student <a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf" target="_blank" rel="noopener noreferrer">Guodong&#x27;s work last year in VLDB</a> of how this can be done. In Kùzu, our sideways information passing technique follows Guodong&#x27;s design in this work.<a href="#fnref-3-10fd85" class="footnote-backref">↩</a></li><li id="fn-4-10fd85">Umbra is being developed by <a href="https://www.professoren.tum.de/en/neumann-thomas" target="_blank" rel="noopener noreferrer">Thomas Neumann</a> and his group. If Thomas&#x27;s name does not ring a bell let me explain his weight in the field like this. As the joke goes, in the field of DBMSs: there are gods at the top, then there is Thomas Neumann, and then other holy people, and then we mere mortals.<a href="#fnref-4-10fd85" class="footnote-backref">↩</a></li></ol></div></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docusaurus/blog/tags/internals">internals</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docusaurus/blog/kuzu-0.0.2-release"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Kùzu 0.0.2 Release</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docusaurus/blog/what-every-gdbms-should-do-and-vision"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">What Every Competent GDBMS Should Do (aka The Goals &amp; Vision of Kùzu</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#a-quick-background-traditional-query-processing-using-flat-tuples" class="table-of-contents__link toc-highlight">A Quick Background: Traditional Query Processing Using Flat Tuples</a></li><li><a href="#factorization-in-a-nutshell" class="table-of-contents__link toc-highlight">Factorization In a Nutshell</a></li><li><a href="#examples-when-factorization-significantly-benefits" class="table-of-contents__link toc-highlight">Examples When Factorization Significantly Benefits:</a><ul><li><a href="#less-data-copiesmovement" class="table-of-contents__link toc-highlight">Less Data Copies/Movement</a></li><li><a href="#fewer-predicate-and-expression-evaluations" class="table-of-contents__link toc-highlight">Fewer Predicate and Expression Evaluations</a></li><li><a href="#aggregations" class="table-of-contents__link toc-highlight">Aggregations</a></li></ul></li><li><a href="#how-does-kùzu-perform-factorized-query-processing" class="table-of-contents__link toc-highlight">How Does Kùzu Perform Factorized Query Processing?</a><ul><li><a href="#1-factorization" class="table-of-contents__link toc-highlight">1. Factorization</a></li><li><a href="#2-ensuring-sequential-scans" class="table-of-contents__link toc-highlight">2. Ensuring Sequential Scans</a></li><li><a href="#3-avoiding-full-scans-of-database-files" class="table-of-contents__link toc-highlight">3. Avoiding Full Scans of Database Files</a></li><li><a href="#a-simple-simulation" class="table-of-contents__link toc-highlight">A Simple Simulation</a></li><li><a href="#example-experiment" class="table-of-contents__link toc-highlight">Example Experiment</a></li></ul></li><li><a href="#final-marks" class="table-of-contents__link toc-highlight">Final marks:</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1w0thj6s7-0bLaU8Sb~4fDMKJ~oejG_g" target="_blank" rel="noopener noreferrer" class="footer__link-item">Slack<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/kuzudb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.youtube.com/@KuzuDB" target="_blank" rel="noopener noreferrer" class="footer__link-item">YouTube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://space.bilibili.com/410352593" target="_blank" rel="noopener noreferrer" class="footer__link-item">Bilibili<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docusaurus/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kuzudb/kuzu" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Kùzu Team. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docusaurus/assets/js/runtime~main.226ef243.js"></script>
<script src="/docusaurus/assets/js/main.71e2b852.js"></script>
</body>
</html>